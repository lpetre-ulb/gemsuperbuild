diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index ba55d7d18..650986413 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,6 +1,6 @@
 variables:
   EXTERN_PACKAGES: "extern/oracle extern/dim extern/smi extern/yui extern/caen/a2818 extern/caen/a3818 extern/caen/CAENUSBdrvB extern/caen/caenvmelib extern/caen/caencomm extern/caen/caenbridgeupgrade extern/caen/caenupgrader"
-  WORKSUITE_PACKAGES: "xdaq2rc interface/evb interface/shared evb jobcontrol xpci/drv xpci hal/generic hal/utilities hal/busAdapter/dummy hal/busAdapter/caen hal/busAdapter/pci pheaps/drv/cmem_rcc pheaps jal/jtagChain jal/jtagController jal/jtagSVFSequencer ttc/utils ttc/monitoring ttc/ttcci tts/ttsbase tts/atts tts/cpcibase tts/fmmtd tts/ipcutils tts/fmm tts/fmmcontroller tts/fmmdbi tts/fmmtester d2s/utils d2s/fedemulator d2s/gtpe d2s/gtpecontroller d2s/firmwareloader fedstreamer fedkit ferol ferol40 psx/sapi psx/mapi psx psx/watchdog sentinel sentinel/utils sentinel/probe sentinel/sentineld sentinel/tester sentinel/bridge2g sentinel/spotlight2g sentinel/spotlightocci sentinel/arc/utils sentinel/arc tstore/utils tstore/client tstore tstore/api xmas/admin xmas/broker2g xmas/heartbeat xmas/heartbeat/probe xmas/heartbeat/heartbeatd xmas/las2g xmas/collector2g xmas/utils xmas/sensord xmas/probe xmas/tester xmas/bridge2g xmas/slash2g xmas/store2g xmas/smarthub ibvla pt/udapl pt/ibv gevb2g es/api es/xtreme es/xbeat elastic/api elastic/timestream amc13controller"
+  WORKSUITE_PACKAGES: "xdaq2rc interface/evb interface/shared evb jobcontrol xpci/drv xpci hal/generic hal/utilities hal/busAdapter/dummy hal/busAdapter/caen hal/busAdapter/pci pheaps/drv/cmem_rcc pheaps jal/jtagChain jal/jtagController jal/jtagSVFSequencer ttc/utils ttc/monitoring ttc/ltc ttc/ttcci tts/ttsbase tts/atts tts/cpcibase tts/fmmtd tts/ipcutils tts/fmm tts/fmmcontroller tts/fmmdbi tts/fmmtester d2s/utils d2s/fedemulator d2s/gtpe d2s/gtpecontroller d2s/firmwareloader fedstreamer fedkit ferol ferol40 psx/sapi psx/mapi psx psx/watchdog sentinel sentinel/utils sentinel/probe sentinel/sentineld sentinel/tester sentinel/bridge2g sentinel/spotlight2g sentinel/spotlightocci sentinel/arc/utils sentinel/arc tstore/utils tstore/client tstore tstore/api xmas/admin xmas/broker2g xmas/heartbeat xmas/heartbeat/probe xmas/heartbeat/heartbeatd xmas/las2g xmas/collector2g xmas/utils xmas/sensord xmas/probe xmas/tester xmas/bridge2g xmas/slash2g xmas/store2g xmas/smarthub ibvla pt/udapl pt/ibv gevb2g es/api es/xtreme es/xbeat elastic/api elastic/timestream amc13controller"
   RPM_REPO_DIR: "/tmp/$CI_PROJECT_NAME/$CI_JOB_NAME/repo"
   YUM_DIR: "/tmp/$CI_PROJECT_NAME/$CI_COMMIT_REF_NAME/cc7/x86_64/RPMS"
 
@@ -53,25 +53,25 @@ prepare:
 
 .build_package_template: &build_package_definition  # Hidden key that defines an anchor named 'build_package_definition'
   stage: build
-  image: "gitlab-registry.cern.ch/cmsos/docker/docker-image-cmsos-master-cc7-x86_64-worksuite:1.0.0.0"
+  image: "gitlab-registry.cern.ch/cmsos/docker/docker-image-cmsos-master-cc7-x86_64-worksuite:2.0.0.0"
   dependencies:
     - prepare
   script:
     - source /opt/rh/devtoolset-8/enable
     - gcc --version
     - export RPM_RELEASE_NAME=$CI_COMMIT_REF_NAME
-    - export RPM_BUILD_NUMBER="0"
+    - export MARK_TIME=$(date -r $CI_PROJECT_DIR/prerequisites/marktime '+%s')
+    - export RPM_BUILD_NUMBER="0."$MARK_TIME
     - export OPERATION_TYPE=$(echo $CI_COMMIT_REF_NAME | awk '{split($0,a,"_"); print a[1]}')
     - export RELEASE_NUMBER=$(echo $CI_COMMIT_REF_NAME | awk '{split($0,a,"_"); print a[2]}')
     - export BUILD_NUMBER=$(echo $CI_COMMIT_REF_NAME | awk '{split($0,a,"_"); print a[5]}')
+    - if [ "$OPERATION_TYPE" == "release" -a "$BUILD_NUMBER" == "0" ]; then echo "Releases should use build number >= 1! Exiting..."; exit 1; fi
     - if [ "$OPERATION_TYPE" == "release" ]; then export RPM_RELEASE_NAME="r"$RELEASE_NUMBER; export RPM_BUILD_NUMBER=$BUILD_NUMBER; fi
     - if [ -v DEPENDENCY_LIST ]; then echo $DEPENDENCY_LIST; else export DEPENDENCY_LIST=""; echo $DEPENDENCY_LIST; fi
     - if [ -v RPM_LIST ]; then echo $RPM_LIST; else export RPM_LIST="$CI_JOB_NAME"; echo $RPM_LIST; fi
     - export PACKAGE_LIST="$DEPENDENCY_LIST $RPM_LIST"
     - echo $PACKAGE_LIST
     - echo "make rpm PACKAGES="$CI_JOB_NAME" PACKAGE_RELEASE="$RPM_RELEASE_NAME" BUILD_VERSION="$RPM_BUILD_NUMBER" BUILD_SUPPORT=build PROJECT_NAME="$CI_PROJECT_NAME
-    - export MARK_TIME=$(date -r $CI_PROJECT_DIR/prerequisites/marktime '+%s')
-    - if [ "$OPERATION_TYPE" != "release" ]; then export RPM_BUILD_NUMBER=$MARK_TIME; fi
     - export XDAQ_ROOT=/opt/xdaq
     - export PVSS_II_HOME=/opt/WinCC_OA/3.16
     - echo "calling make with PACKAGES="$CI_JOB_NAME" PACKAGE_RELEASE="$RPM_RELEASE_NAME" BUILD_VERSION="$RPM_BUILD_NUMBER" BUILD_SUPPORT=build PROJECT_NAME="$CI_PROJECT_NAME
@@ -441,6 +441,11 @@ ttc/monitoring:
   before_script:
   <<: *build_package_definition
 
+ttc/ltc:
+  before_script:
+  - export DEPENDENCY_LIST="extern/caen/caenvmelib hal/generic hal/utilities hal/busAdapter/dummy hal/busAdapter/caen ttc/utils ttc/monitoring"
+  <<: *build_package_definition
+
 ttc/ttcci:
   before_script:
   - export DEPENDENCY_LIST="extern/caen/caenvmelib hal/generic hal/utilities hal/busAdapter/dummy hal/busAdapter/caen ttc/utils ttc/monitoring"
@@ -592,6 +597,7 @@ git:
     - extern/caen/caenupgrader
     - ttc/utils
     - ttc/monitoring
+    - ttc/ltc
     - ttc/ttcci
     - tts/atts
     - tts/cpcibase
@@ -720,6 +726,7 @@ yum:
     - extern/caen/caenupgrader
     - ttc/utils
     - ttc/monitoring
+    - ttc/ltc
     - ttc/ttcci
     - tts/atts
     - tts/cpcibase
diff --git a/Makefile b/Makefile
index e735d7a22..09e90828b 100644
--- a/Makefile
+++ b/Makefile
@@ -50,6 +50,7 @@ PACKAGES= \
 	jal/jtagSVFSequencer \
 	ttc/utils \
 	ttc/monitoring \
+	ttc/ltc \
 	ttc/ttcci \
 	tts/ttsbase \
 	tts/atts \
diff --git a/d2s/fedemulator/include/d2s/fedemulator/FEDEmulator.hh b/d2s/fedemulator/include/d2s/fedemulator/FEDEmulator.hh
index 9b54129c4..17a5cef9f 100755
--- a/d2s/fedemulator/include/d2s/fedemulator/FEDEmulator.hh
+++ b/d2s/fedemulator/include/d2s/fedemulator/FEDEmulator.hh
@@ -88,8 +88,7 @@ public:
   
   
   
-  FEDEmulator(xdaq::ApplicationStub* stub) 
-    throw (xdaq::exception::Exception);
+  FEDEmulator(xdaq::ApplicationStub* stub);
   
   virtual ~FEDEmulator();
   
@@ -97,8 +96,7 @@ public:
    * Retrieve counters' values from the hardware 
    * 
    */
-  void Get_Counters()  
-    throw(xcept::Exception);
+  void Get_Counters();
   
   /**
    * Read counters when "RetrieveItem" action is performed 
@@ -112,8 +110,7 @@ public:
    * Creates address table and fedEmulatorCard.
    * Perform software Reset, sets event counter to 0x01.
    */
-  void ConfigureAction(toolbox::Event::Reference e) 
-    throw(toolbox::fsm::exception::Exception);
+  void ConfigureAction(toolbox::Event::Reference e);
   
   
   /**
@@ -122,32 +119,28 @@ public:
    * the eventSizeStdDev is 0, lognormal otherwise).
    * Sets the eventCounterOn and the start bit.
    */
-  void EnableAction(toolbox::Event::Reference e) 
-    throw(toolbox::fsm::exception::Exception);
+  void EnableAction(toolbox::Event::Reference e);
   
   /**
    * XDAQ state transition callback.
    * Called when running puts the FedEmulator in the 
    * state Configured (ready to start the next run)
    */
-  void StopAction(toolbox::Event::Reference e) 
-    throw(toolbox::fsm::exception::Exception);
+  void StopAction(toolbox::Event::Reference e);
   
   
   /**
    * XDAQ state transition callback.
    * Resets the start bit in the hardware.
    */
-  void SuspendAction(toolbox::Event::Reference e) 
-    throw(toolbox::fsm::exception::Exception);
+  void SuspendAction(toolbox::Event::Reference e);
   
   
   /**
    * XDAQ state transition callback.
    * Sets the start bit in the hardware.
    */
-  void ResumeAction(toolbox::Event::Reference e) 
-    throw(toolbox::fsm::exception::Exception);
+  void ResumeAction(toolbox::Event::Reference e);
   
   /**
    * XDAQ state transition callback.
@@ -156,26 +149,21 @@ public:
    * in case someone is interested in the last values. 
    * Deletes the address table and the fedEmulatorCard.
    */
-  void HaltAction(toolbox::Event::Reference e) 
-    throw(toolbox::fsm::exception::Exception);
+  void HaltAction(toolbox::Event::Reference e);
   
   
-  void stateChanged(toolbox::fsm::FiniteStateMachine & fsm )  
-    throw (toolbox::fsm::exception::Exception);
+  void stateChanged(toolbox::fsm::FiniteStateMachine & fsm );
   
-  void failedTransition(toolbox::Event::Reference e ) 
-    throw (toolbox::fsm::exception::Exception);
+  void failedTransition(toolbox::Event::Reference e );
   
   /**
    * HyperDAQ default WEB PAGE for the application
    * 
    */
   
-  void defaultWebPage(xgi::Input *in, xgi::Output *out) 
-    throw (xgi::exception::Exception);
+  void defaultWebPage(xgi::Input *in, xgi::Output *out);
   
-  void setParameter(xgi::Input * in, xgi::Output * out ) 
-    throw (xgi::exception::Exception);
+  void setParameter(xgi::Input * in, xgi::Output * out );
   
   /**
    * Gives a manual trigger and generates one event.
@@ -183,22 +171,19 @@ public:
    * original value.
    */
   
-  xoap::MessageReference UserTrigger ( xoap::MessageReference message ) 
-    throw(xcept::Exception);
+  xoap::MessageReference UserTrigger ( xoap::MessageReference message );
 
   /**
    * Write an item to a FEDEmulatorCard.
    * This function is intended for debugging only.
    */
-  xoap::MessageReference writeItem( xoap::MessageReference message ) 
-    throw(xcept::Exception, xoap::exception::Exception);
+  xoap::MessageReference writeItem( xoap::MessageReference message );
 
   /**
    * Read an item from a FEDEmulatorCard via SOAP.
    * This function is for debugging only.
    */
-  xoap::MessageReference readItem( xoap::MessageReference message ) 
-    throw(xcept::Exception, xoap::exception::Exception);
+  xoap::MessageReference readItem( xoap::MessageReference message );
 
   /**
    * XDAQ callback.
@@ -207,20 +192,15 @@ public:
    * the hardware.
    */
   
-  xoap::MessageReference readpar ( xoap::MessageReference message )
-    throw(xcept::Exception);
+  xoap::MessageReference readpar ( xoap::MessageReference message );
 
-  xoap::MessageReference setWriteFile ( xoap::MessageReference message )
-    throw(xcept::Exception);
+  xoap::MessageReference setWriteFile ( xoap::MessageReference message );
   
-  xoap::MessageReference setSTTSPattern( xoap::MessageReference msg ) 
-    throw(xcept::Exception, xoap::exception::Exception);
+  xoap::MessageReference setSTTSPattern( xoap::MessageReference msg );
 
-  xoap::MessageReference cycleSTTSPatterns( xoap::MessageReference msg ) 
-    throw(xcept::Exception, xoap::exception::Exception);
+  xoap::MessageReference cycleSTTSPatterns( xoap::MessageReference msg );
 
-  xoap::MessageReference setSTTSControl( xoap::MessageReference msg ) 
-    throw(xcept::Exception, xoap::exception::Exception);
+  xoap::MessageReference setSTTSControl( xoap::MessageReference msg );
 
 private:
   
@@ -233,16 +213,14 @@ private:
   xoap::MessageReference makeReply( std::string command, std::string answerString  );
   xoap::MessageReference makeFaultReply( std::string command, std::string answerString  );
   
-  xoap::MessageReference changeState (xoap::MessageReference msg) 
-    throw (xoap::exception::Exception);
+  xoap::MessageReference changeState (xoap::MessageReference msg);
   
   /**
    * Creates a SOAP response message for the specified FSM event and
    * result state.
    */
   xoap::MessageReference createFsmSoapResponseMsg ( const std::string event,
-						    const std::string state)
-    throw (xcept::Exception);
+						    const std::string state);
   
   HAL::PCIDevice::PCILocationIdentifier BusLoc_;
   HAL::PCILinuxBusAdapter *busAdapter_; // Made a pointer by Steve 04.10.05
diff --git a/d2s/fedemulator/include/d2s/fedemulator/FEDEmulatorCard.hh b/d2s/fedemulator/include/d2s/fedemulator/FEDEmulatorCard.hh
index db49e19ac..3e94111b7 100755
--- a/d2s/fedemulator/include/d2s/fedemulator/FEDEmulatorCard.hh
+++ b/d2s/fedemulator/include/d2s/fedemulator/FEDEmulatorCard.hh
@@ -38,14 +38,12 @@ namespace d2s {
     FEDEmulatorCard( HAL::PCIAddressTable& fedEmulatorAddressTable,
 		     HAL::PCIBusAdapterInterface& busAdapter,
 		     HAL::PCIDevice::PCILocationIdentifier busLocation,
-		     Logger logger)
-      throw(HAL::HardwareAccessException);
+		     Logger logger);
     
     FEDEmulatorCard( HAL::PCIAddressTable& fedEmulatorAddressTable,
 		     HAL::PCIBusAdapterInterface& busAdapter,
 		     uint32_t pciIndex,
-		     Logger logger)
-      throw(HAL::HardwareAccessException);
+		     Logger logger);
     
     virtual ~FEDEmulatorCard();
 
@@ -54,8 +52,7 @@ namespace d2s {
 	   */
     void setFixedEventSize( uint32_t source,
 			    uint32_t eventSize,
-			    uint32_t deltaT  ) 
-      throw( HAL::HardwareAccessException );
+			    uint32_t deltaT  );
     
     void setLogNormalEventSize( uint32_t mean,
 				uint32_t source,
@@ -64,14 +61,12 @@ namespace d2s {
 				uint32_t seed,
 				uint32_t stdDev,
 				uint32_t minSize,
-				uint32_t maxSize ) 
-      throw( HAL::HardwareAccessException );
+				uint32_t maxSize );
     
     /**
      * preload events from file into GIII memory
      */
-    void preloadEvents( std::string fileName ) 
-      throw( HAL::HardwareAccessException );
+    void preloadEvents( std::string fileName );
     
   private:
     Logger logger_;
diff --git a/d2s/fedemulator/src/common/FEDEmulator.cc b/d2s/fedemulator/src/common/FEDEmulator.cc
index 0215ed566..35a5c7a1e 100755
--- a/d2s/fedemulator/src/common/FEDEmulator.cc
+++ b/d2s/fedemulator/src/common/FEDEmulator.cc
@@ -260,7 +260,7 @@ xoap::MessageReference d2s::FEDEmulator::changeState (xoap::MessageReference msg
 	      return createFsmSoapResponseMsg(commandName,
 					      stateName_.toString());
 	    }
-	  catch(xcept::Exception e)
+	  catch(xcept::Exception &e)
 	    {
 	      XCEPT_RETHROW(xoap::exception::Exception,
                             "Failed to create FSM SOAP response message", e);
@@ -535,8 +535,7 @@ void d2s::FEDEmulator::setParameter(xgi::Input * in, xgi::Output * out )
   
 }
 
-void d2s::FEDEmulator::StopAction( toolbox::Event::Reference e )
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::FEDEmulator::StopAction( toolbox::Event::Reference e ) {
 
   try 
     {
@@ -552,8 +551,7 @@ void d2s::FEDEmulator::StopAction( toolbox::Event::Reference e )
   stateName_ = "Ready";
 }
 
-void d2s::FEDEmulator::ConfigureAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::FEDEmulator::ConfigureAction(toolbox::Event::Reference e) {
   
   uint32_t giiiversion;
 
@@ -740,8 +738,7 @@ void d2s::FEDEmulator::ConfigureAction(toolbox::Event::Reference e)
   
 }
 
-void d2s::FEDEmulator::EnableAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::FEDEmulator::EnableAction(toolbox::Event::Reference e) {
   
   LOG4CPLUS_DEBUG(getApplicationLogger(), "FEDEmulator enable start");
   
@@ -788,8 +785,7 @@ void d2s::FEDEmulator::EnableAction(toolbox::Event::Reference e)
 
 
 
-void d2s::FEDEmulator::SuspendAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::FEDEmulator::SuspendAction(toolbox::Event::Reference e) {
 
   try 
     {
@@ -805,8 +801,7 @@ void d2s::FEDEmulator::SuspendAction(toolbox::Event::Reference e)
 }
 
 
-void d2s::FEDEmulator::ResumeAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::FEDEmulator::ResumeAction(toolbox::Event::Reference e) {
 
   try 
     {
@@ -822,8 +817,7 @@ void d2s::FEDEmulator::ResumeAction(toolbox::Event::Reference e)
 }
 
 
-void d2s::FEDEmulator::HaltAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::FEDEmulator::HaltAction(toolbox::Event::Reference e) {
   
   if( fsm_.getStateName( fsm_.getCurrentState()) != "Halted") { 
     try 
@@ -906,8 +900,7 @@ void d2s::FEDEmulator::HaltAction(toolbox::Event::Reference e)
 }
 
 
-xoap::MessageReference d2s::FEDEmulator::setWriteFile ( xoap::MessageReference message) 
-  throw(xcept::Exception) {
+xoap::MessageReference d2s::FEDEmulator::setWriteFile ( xoap::MessageReference message) {
   
   writeFile_ = 1; 
   // send back a reply:
@@ -919,8 +912,7 @@ xoap::MessageReference d2s::FEDEmulator::setWriteFile ( xoap::MessageReference m
 }
 
 
-xoap::MessageReference d2s::FEDEmulator::readpar ( xoap::MessageReference message) 
-  throw(xcept::Exception) {
+xoap::MessageReference d2s::FEDEmulator::readpar ( xoap::MessageReference message) {
   
   FEDEmulator::Get_Counters();      
   
@@ -945,8 +937,7 @@ xoap::MessageReference d2s::FEDEmulator::readpar ( xoap::MessageReference messag
 //   </SOAP-ENV:Body>
 // </SOAP-ENV:Envelope>
 // 
-xoap::MessageReference d2s::FEDEmulator::setSTTSControl( xoap::MessageReference msg ) 
-  throw(xcept::Exception, xoap::exception::Exception) {
+xoap::MessageReference d2s::FEDEmulator::setSTTSControl( xoap::MessageReference msg ) {
 
   uint32_t control = 0;
 
@@ -1011,8 +1002,7 @@ xoap::MessageReference d2s::FEDEmulator::setSTTSControl( xoap::MessageReference
 //   </SOAP-ENV:Body>
 // </SOAP-ENV:Envelope>
 // 
-xoap::MessageReference d2s::FEDEmulator::cycleSTTSPatterns( xoap::MessageReference msg ) 
-  throw(xcept::Exception, xoap::exception::Exception) {
+xoap::MessageReference d2s::FEDEmulator::cycleSTTSPatterns( xoap::MessageReference msg ) {
 
   uint32_t cycles = 0;
 
@@ -1078,8 +1068,7 @@ xoap::MessageReference d2s::FEDEmulator::cycleSTTSPatterns( xoap::MessageReferen
 //   </SOAP-ENV:Body>
 // </SOAP-ENV:Envelope>
 // 
-xoap::MessageReference d2s::FEDEmulator::setSTTSPattern( xoap::MessageReference msg ) 
-  throw(xcept::Exception, xoap::exception::Exception) {
+xoap::MessageReference d2s::FEDEmulator::setSTTSPattern( xoap::MessageReference msg ) {
 
   uint32_t pattern = 0;
 
@@ -1137,8 +1126,7 @@ xoap::MessageReference d2s::FEDEmulator::setSTTSPattern( xoap::MessageReference
 //   </SOAP-ENV:Body>
 // </SOAP-ENV:Envelope>
 // 
-xoap::MessageReference d2s::FEDEmulator::readItem( xoap::MessageReference msg ) 
-  throw(xcept::Exception, xoap::exception::Exception) {
+xoap::MessageReference d2s::FEDEmulator::readItem( xoap::MessageReference msg ) {
 
   uint32_t result = 0;
   uint32_t offset = 0;
@@ -1202,8 +1190,7 @@ xoap::MessageReference d2s::FEDEmulator::readItem( xoap::MessageReference msg )
 //   </SOAP-ENV:Body>
 // </SOAP-ENV:Envelope>
 // 
-xoap::MessageReference d2s::FEDEmulator::writeItem( xoap::MessageReference msg ) 
-  throw(xcept::Exception, xoap::exception::Exception) {
+xoap::MessageReference d2s::FEDEmulator::writeItem( xoap::MessageReference msg ) {
 
   uint32_t data   = 0;
   uint32_t offset = 0;
@@ -1292,8 +1279,7 @@ xoap::MessageReference d2s::FEDEmulator::makeFaultReply( std::string command, st
   return reply;
 }
 
-xoap::MessageReference d2s::FEDEmulator::UserTrigger( xoap::MessageReference message ) 
-  throw(xcept::Exception) {
+xoap::MessageReference d2s::FEDEmulator::UserTrigger( xoap::MessageReference message ) {
   try 
     {
       uint32_t oldState;
@@ -1331,8 +1317,7 @@ xoap::MessageReference d2s::FEDEmulator::UserTrigger( xoap::MessageReference mes
   return makeReply("UserTriggerResponse", "" );                        
 }
 
-void d2s::FEDEmulator::Get_Counters()  
-  throw(xcept::Exception) {
+void d2s::FEDEmulator::Get_Counters() {
 
   uint32_t readparam;
 
@@ -1388,7 +1373,7 @@ xoap::MessageReference d2s::FEDEmulator::createFsmSoapResponseMsg( const std::st
       
       return message;
     }
-  catch(xcept::Exception e)
+  catch(xcept::Exception &e)
     {
       XCEPT_RETHROW(xcept::Exception,
 		    "Failed to create FSM SOAP response message for event:" +
diff --git a/d2s/fedemulator/src/common/FEDEmulatorCard.cc b/d2s/fedemulator/src/common/FEDEmulatorCard.cc
index a4cf95a96..50023639c 100755
--- a/d2s/fedemulator/src/common/FEDEmulatorCard.cc
+++ b/d2s/fedemulator/src/common/FEDEmulatorCard.cc
@@ -12,8 +12,7 @@
 d2s::FEDEmulatorCard::FEDEmulatorCard( HAL::PCIAddressTable& fedEmulatorAddressTable,
 				       HAL::PCIBusAdapterInterface& busAdapter,
 				       const HAL::PCIDevice::PCILocationIdentifier busLocation,
-				       Logger logger) 
-  throw(HAL::HardwareAccessException)
+				       Logger logger)
   : PCIDevice( fedEmulatorAddressTable , 
 	       busAdapter,
 	       busLocation,
@@ -29,8 +28,7 @@ d2s::FEDEmulatorCard::FEDEmulatorCard( HAL::PCIAddressTable& fedEmulatorAddressT
 d2s::FEDEmulatorCard::FEDEmulatorCard( HAL::PCIAddressTable& fedEmulatorAddressTable,
 				       HAL::PCIBusAdapterInterface& busAdapter,
 				       uint32_t pciIndex,
-				       Logger logger) 
-  throw(HAL::HardwareAccessException)
+				       Logger logger)
   : PCIDevice( fedEmulatorAddressTable , 
 	       busAdapter,
 	       FEDEMULATOR_VENDORID,
@@ -53,8 +51,7 @@ d2s::FEDEmulatorCard::~FEDEmulatorCard( ) {
 
 void d2s::FEDEmulatorCard::setFixedEventSize( uint32_t eventSize,
 					      uint32_t source ,
-					      uint32_t deltaT ) 
-  throw( HAL::HardwareAccessException ) {
+					      uint32_t deltaT ) {
   
   LOG4CPLUS_DEBUG (logger_," setfixedsize " <<  eventSize );
   if ( eventSize < 24 ) {
@@ -89,8 +86,7 @@ void d2s::FEDEmulatorCard::setLogNormalEventSize( uint32_t mean,
 					     uint32_t seed,
 					     uint32_t stdDev,
 					     uint32_t minSize,
-					     uint32_t maxSize )
-  throw( HAL::HardwareAccessException ) {
+					     uint32_t maxSize ) {
   
   
   double sum, sum2, cmean, crms;
@@ -168,8 +164,7 @@ void d2s::FEDEmulatorCard::setLogNormalEventSize( uint32_t mean,
 }
 
 
-void d2s::FEDEmulatorCard::preloadEvents( std::string fileName ) 
-  throw( HAL::HardwareAccessException ) {
+void d2s::FEDEmulatorCard::preloadEvents( std::string fileName ) {
 
   // open the event file
   std::ifstream infile( fileName.c_str(), std::ios::binary|std::ios::in );
diff --git a/d2s/firmwareloader/scripts/cmsdaq_fwloader b/d2s/firmwareloader/scripts/cmsdaq_fwloader
index 92520227b..e24fdb56e 100755
--- a/d2s/firmwareloader/scripts/cmsdaq_fwloader
+++ b/d2s/firmwareloader/scripts/cmsdaq_fwloader
@@ -1,16 +1,13 @@
 #!/bin/bash
 
-if test ".$XDAQ_ROOT" = "."; then
-  echo "Error: XDAQ_ROOT environment variable not set"
-  exit 1
-fi
+export BUILD_HOME=../../..
 
 if test ".$XDAQ_PLATFORM" = "."; then
   export XDAQ_PLATFORM=`uname -m`
   if test ".$XDAQ_PLATFORM" != ".x86_64"; then
     export XDAQ_PLATFORM=x86
   fi
-  checkos=`$XDAQ_ROOT/config/checkos.sh`
+  checkos=`/opt/xdaq/build/checkos.sh`
   echo $checkos
   export XDAQ_PLATFORM=$XDAQ_PLATFORM"_"$checkos
   echo "Warning: PLATFORM env. variable not set, guessed to " ${XDAQ_PLATFORM}
@@ -24,18 +21,18 @@ if test ".$XDAQ_OS" = "."; then
   echo "Warning: OS env. variable not set, guessed to " ${XDAQ_OS}
 fi
 
+export LD_LIBRARY_PATH=$BUILD_HOME/d2s/firmwareloader/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/tts/ipcutils/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/jal/jtagSVFSequencer/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/jal/jtagChain/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/jal/jtagController/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/hal/generic/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/hal/busAdapter/pci/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/xpci/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/extern/generic_pci_access/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/extern/xerces/${XDAQ_PLATFORM}/lib
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/xcept/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/config/lib/$XDAQ_OS/$XDAQ_PLATFORM
+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/xdaq/lib
 
-export LD_LIBRARY_PATH=$XDAQ_ROOT/daq/d2s/firmwareloader/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/tts/ipcutils/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/jal/jtagSVFSequencer/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/jal/jtagChain/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/jal/jtagController/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/hal/$XDAQ_PLATFORM/lib
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/extern/generic_pci_access/$XDAQ_PLATFORM/lib
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/extern/xerces/${XDAQ_PLATFORM}/lib
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/xcept/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/daq/config/lib/$XDAQ_OS/$XDAQ_PLATFORM
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BUILD_HOME/$XDAQ_PLATFORM/lib
-export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XDAQ_ROOT/$XDAQ_PLATFORM/lib
-
-${XDAQ_ROOT}/daq/d2s/firmwareloader/bin/linux/${XDAQ_PLATFORM}/cmsdaq_fwloader.exe $@
+${BUILD_HOME}/d2s/firmwareloader/bin/linux/${XDAQ_PLATFORM}/cmsdaq_fwloader.exe $@
diff --git a/d2s/firmwareloader/src/common/cmsdaq_fwloader.cc b/d2s/firmwareloader/src/common/cmsdaq_fwloader.cc
index 467c7fecc..b600a311a 100755
--- a/d2s/firmwareloader/src/common/cmsdaq_fwloader.cc
+++ b/d2s/firmwareloader/src/common/cmsdaq_fwloader.cc
@@ -1099,7 +1099,7 @@ int main(int argc, char** argv) {
 
 	
 
-	uint32_t geoslot;
+	uint32_t geoslot=0; // default will never be used
 	if (cardIndex<nKnownCards && knownCards[cardIndex].isCPCI && !noLocking) {
 	  geoslot = readGeoSlot(*dev, deviceID);
 
diff --git a/d2s/gtpe/include/d2s/gtpe/GTPeCard.hh b/d2s/gtpe/include/d2s/gtpe/GTPeCard.hh
index 6588e2c02..e23381665 100755
--- a/d2s/gtpe/include/d2s/gtpe/GTPeCard.hh
+++ b/d2s/gtpe/include/d2s/gtpe/GTPeCard.hh
@@ -54,10 +54,7 @@ namespace d2s {
     /// 
     /// @param gtpe is a reference to the HAL PCIDevice. The GTPeCard takes ownership of this device
     ///        and deletes it in its destructor
-    GTPeCard( HAL::PCIDevice* gtpe )
-      throw (HAL::HardwareAccessException, 
-	     ipcutils::exception::Exception,
-	     d2s::exception::IncompatibleFirmware);
+    GTPeCard( HAL::PCIDevice* gtpe );
 
     /// d-tor
     virtual ~GTPeCard();
@@ -65,100 +62,83 @@ namespace d2s {
     /// read the firmware revision
     ///
     /// returns firmware revision as string YYMMDDVV
-    std::string readFirmwareRevisison()
-      throw (HAL::HardwareAccessException);
+    std::string readFirmwareRevisison();
 
     /// reset the GTPe
     ///
     /// resets everything (the event, error etc. counters.
     /// partition definitions, clock mode, backpressure, ...)
-    void globalReset()
-      throw (HAL::HardwareAccessException);
+    void globalReset();
 
     /// reset the GTPe counters
     ///
     /// resets the event, error etc. counters.
-    void resetCounters()
-      throw (HAL::HardwareAccessException);
+    void resetCounters();
 
     /// toggle if SLINK is required
     ///
     /// @param requ is true if the SLINK is required (default), false to ignore the SLINK
-    void toggleSLINKRequired(bool requ)
-      throw (HAL::HardwareAccessException);
+    void toggleSLINKRequired(bool requ);
 
     /// return if SLINK is required
-    bool isSLINKRequired()
-      throw (HAL::HardwareAccessException);
+    bool isSLINKRequired();
 
 
     /// start the SLINK
     ///
     /// has to be called before staring triggers
-    void startSLINK()
-      throw (HAL::HardwareAccessException);
+    void startSLINK();
 
     /// start the SLINK
-    void stopSLINK()
-      throw (HAL::HardwareAccessException);
+    void stopSLINK();
 
     /// set the clock period (only applies in clocked mode).
     ///
     /// This clock frequency is split among the active DAQ partitions.
     ///
     /// @param n_25ns is the clock period in multiples of 25 ns
-    void setClockPeriod(uint32_t n_25ns)
-      throw (HAL::HardwareAccessException);
+    void setClockPeriod(uint32_t n_25ns);
 
     /// read back the clock period in number of 25ns periods
-    uint32_t readbackClockPeriod()
-      throw (HAL::HardwareAccessException);
+    uint32_t readbackClockPeriod();
 
 
     /// toggle between random mode and clocked mode
     ///
     /// @param clocked is true for clocked mode, false for random mode
-    void toggleClockedMode(bool clocked)
-      throw (HAL::HardwareAccessException);
+    void toggleClockedMode(bool clocked);
 
     /// is the GTPe in clocked mode?
-    bool isClockedMode()
-      throw (HAL::HardwareAccessException);
+    bool isClockedMode();
 
     /// start the trigger generation
     ///
-    void startTriggers()
-      throw (HAL::HardwareAccessException);
+    void startTriggers();
 
     /// pause the trigger generation
     ///
     /// this command can be used to stop triggers without resetting 
     /// the orbit, bx, and event counters 
-    void pauseTriggers()
-      throw (HAL::HardwareAccessException);
+    void pauseTriggers();
 
     /// resume the trigger generation
-    void resumeTriggers()
-      throw (HAL::HardwareAccessException);
+    void resumeTriggers();
 
     /// stop the trigger generation
     ///
     /// this resets the internal orbit counter, bx counter, global event counter,
     /// partition event number counters
     ///
-    void stopTriggers()
-      throw (HAL::HardwareAccessException);
+    void stopTriggers();
 
 
     /// is the GTPe running?
     ///
     /// also returns true if running, but in paused mode
-    bool isRunning()
-      throw (HAL::HardwareAccessException);
+    bool isRunning();
 
     /// is the GTPe paused?
-    bool isPaused()
-      throw (HAL::HardwareAccessException);
+    bool isPaused();
 
 
     /// set the partition definition
@@ -183,8 +163,7 @@ namespace d2s {
     /// the return value is the trigger rate in Hz that was actually after after rounding.
     double setPartitionDef(uint32_t part_group_idx, 
 			   uint32_t selected_partitions,  
-			   double triggerrate)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+			   double triggerrate);
 
     /// set the partition definition
     ///
@@ -208,53 +187,42 @@ namespace d2s {
     /// the return value is the trigger rate in Hz that was actually after after rounding.
     double setPartitionDef(uint32_t part_group_idx, 
 			   uint32_t selected_partitions,  
-			   uint32_t rate_bits)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+			   uint32_t rate_bits);
 
     /// read back partition def
-    uint32_t readbackPartitionDef(uint32_t part_group_idx)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint32_t readbackPartitionDef(uint32_t part_group_idx);
 
     /// read back rate
-    uint32_t readbackRate(uint32_t part_group_idx)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint32_t readbackRate(uint32_t part_group_idx);
 
     /// read back rate in Hz
-    double readbackRateHz(uint32_t part_group_idx)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    double readbackRateHz(uint32_t part_group_idx);
 
     /// read back selected partitions
-    uint32_t readbackSelectedPartitions(uint32_t part_group_idx)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint32_t readbackSelectedPartitions(uint32_t part_group_idx);
 
     /// read back current total rate
     ///
     /// in clocked mode this is the clocked mode frequency,
     /// in random mode this is the sum of trigger rates in the partitions
-    double readbackCurrentTotalRate()
-      throw (HAL::HardwareAccessException);
+    double readbackCurrentTotalRate();
 
     
     /// enable BC reset on LEMO 8; ATTN: aTTS outputs 0 and 1 become unusable
-    void enableBCResetLEMO(bool enable)
-      throw (HAL::HardwareAccessException);
+    void enableBCResetLEMO(bool enable);
 
     /// enable BC reset on LEMO 9; ATTN: aTTS outputs 0 and 1 become unusable
-    void enableBunchStructureLEMO(bool enable)
-      throw (HAL::HardwareAccessException);
+    void enableBunchStructureLEMO(bool enable);
 
     /// is the BCReset LEMO enabled?
-    bool isBCResetLEMOEnabled()
-      throw (HAL::HardwareAccessException);
+    bool isBCResetLEMOEnabled();
 
     /// is the Bunch structure LEMO enabled?
-    bool isBunchStructureLEMOEnabled()
-      throw (HAL::HardwareAccessException);
+    bool isBunchStructureLEMOEnabled();
 
 
     /// latch all counters - needs to be called before reading counters
-    void latchCounters()
-      throw (HAL::HardwareAccessException);
+    void latchCounters();
 
     /// read out a GTPe counter
     ///
@@ -266,59 +234,46 @@ namespace d2s {
     ///
     ///        5 ... read back of command register
     ///        6 ... read partition status
-    uint32_t readCounter(uint32_t counter_idx)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint32_t readCounter(uint32_t counter_idx);
 
     /// read a 64-bit counter
     ///
     /// 'U' and 'L' is appended to item in order to read the upper and lower part of the counter 
-    uint64_t readCounter64bit(std::string item) 
-      throw (HAL::HardwareAccessException);
+    uint64_t readCounter64bit(std::string item);
 
     ///
-    uint64_t readGlobalTimer() 
-      throw (HAL::HardwareAccessException);
+    uint64_t readGlobalTimer();
 
     ///
-    uint64_t readCounterAcceptedTriggers() 
-      throw (HAL::HardwareAccessException);
+    uint64_t readCounterAcceptedTriggers();
 
     ///
-    uint64_t readCounterGeneratedTriggers() 
-      throw (HAL::HardwareAccessException);
+    uint64_t readCounterGeneratedTriggers();
 
     ///
-    uint64_t readCounterPartitionAcceptedTriggers(uint32_t part_idx) 
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint64_t readCounterPartitionAcceptedTriggers(uint32_t part_idx);
 
     ///
-    uint64_t readLostEventsATTS(uint32_t part_idx) 
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint64_t readLostEventsATTS(uint32_t part_idx);
 
     ///
-    uint64_t readLostEventsSTTS(uint32_t det_idx) 
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint64_t readLostEventsSTTS(uint32_t det_idx);
     
     ///
-    std::string getTriggerRuleName(uint32_t det_idx) 
-      throw (d2s::exception::OutOfRange);
+    std::string getTriggerRuleName(uint32_t det_idx);
 
     ///
-    uint64_t readLostEventsTriggerRule(uint32_t det_idx) 
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    uint64_t readLostEventsTriggerRule(uint32_t det_idx);
 
     ///
-    uint64_t readLostEventsSLINK() 
-      throw (HAL::HardwareAccessException);
+    uint64_t readLostEventsSLINK();
 
     ///
-    uint64_t readLostEventsIntBuf() 
-      throw (HAL::HardwareAccessException);
+    uint64_t readLostEventsIntBuf();
 
     /// read partition status register
     ///
-    uint32_t readPartitionStatus() 
-      throw (HAL::HardwareAccessException);
+    uint32_t readPartitionStatus();
 
 
     /// latch and read a snapshot of the GTPe Status in a single operation
@@ -328,8 +283,7 @@ namespace d2s {
     ///
     /// the two methods use a common semaphore in order not to interrupt each other
     ///
-    GTPeStatus readStatusSnapshot()
-      throw (HAL::HardwareAccessException);
+    GTPeStatus readStatusSnapshot();
 
  
     /// simulate backpressure on aTTS ouputs
@@ -338,8 +292,7 @@ namespace d2s {
     /// @param backpressure is true if backpressure should be set for this 
     ///        partition group. (a TTS busy signal will be sent)
     void toggleBackPressure (uint32_t part_group_idx,
-			     bool backpressure)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+			     bool backpressure);
   
  
     /// Set the aTTS output
@@ -349,42 +302,35 @@ namespace d2s {
     /// @param state is the TTSState to simulate (if simulate is true). Valid values: IDLE, WARNING, READY, BUSY       
     void forceATTSOutput (uint32_t part_group_idx,
 			  bool force,
-			  tts::TTSState const& state = tts::TTSState::READY)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+			  tts::TTSState const& state = tts::TTSState::READY);
   
     /// read back the ATTS output test value set by forceATTSOutput()
-    tts::TTSState readbackATTSTestOutputState(uint32_t part_group_idx)
-      throw (HAL::HardwareAccessException, d2s::exception::OutOfRange);
+    tts::TTSState readbackATTSTestOutputState(uint32_t part_group_idx);
 
     /// read back the ATTS output enable mask for outputs [7..0] set by forceATTSOutput()
     ///
     /// bit = 1: use partition status; bit = 0: use test output value
-    uint32_t readbackATTSOutputEnables() 
-      throw (HAL::HardwareAccessException);
+    uint32_t readbackATTSOutputEnables();
 
     /// Set the sTTS input mask
     ///
     /// @param mask[7..0] is the mask for inputs 7..0, 0 masks out the channel, 1 considers it as input  
-    void setSTTSInputMask (uint32_t mask)
-      throw (HAL::HardwareAccessException);
+    void setSTTSInputMask (uint32_t mask);
 
     /// Set the aTTS input mask
     ///
     /// @param mask[7..0] is the mask for inputs 7..0, 0 masks out the channel, 1 considers it as input  
-    void setATTSInputMask (uint32_t mask)
-      throw (HAL::HardwareAccessException);
+    void setATTSInputMask (uint32_t mask);
 
     /// Read back the sTTS input mask
     ///
     /// the retuned mask[7..0] is the mask for inputs 7..0, 0 masks out the channel, 1 considers it as input  
-    uint32_t readbackSTTSInputMask ()
-      throw (HAL::HardwareAccessException);
+    uint32_t readbackSTTSInputMask ();
 
     /// Read back the aTTS input mask
     ///
     /// the retuned mask[7..0] is the mask for inputs 7..0, 0 masks out the channel, 1 considers it as input  
-    uint32_t readbackATTSInputMask ()
-      throw (HAL::HardwareAccessException);
+    uint32_t readbackATTSInputMask ();
 
 
     /// get a referene to the HAL::PCIDevice
@@ -395,98 +341,74 @@ namespace d2s {
     ///
     /// throws a d2s::exception::Timeout exception if the operation timed out
     ///
-    void lock()
-      throw (ipcutils::exception::Exception,
-	     d2s::exception::Timeout);
+    void lock();
 
     /// un-lock the GTPe master semaphore.
     /// The master semaphore protects GTPe hardware access and the semaphores used for locking DAQ and Det partitions
-    void unlock()
-      throw (ipcutils::exception::Exception);
+    void unlock();
 
     /// lock a DAQ Partition
     ///
     /// @param i_part is the DAQ partition index (0-7)
-    bool lockDAQPartition( uint32_t i_part )
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    bool lockDAQPartition( uint32_t i_part );
 
 
     /// un-lock a DAQ Partition
     ///
     /// @param i_part is the DAQ partition index (0-7)
-    void unlockDAQPartition ( uint32_t i_part )
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    void unlockDAQPartition ( uint32_t i_part );
 
 
     /// is a DAQ Partition lcoked?
     ///
     /// @param i_part is the DAQ partition index (0-7)
-    bool isDAQPartitionLocked( uint32_t i_part )
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    bool isDAQPartitionLocked( uint32_t i_part );
 
 
     /// what PID owns the DAQ Partition lock?
     ///
     /// @param i_part is the DAQ partition index (0-7)
-    uint32_t getDAQPartitionLockOwnerPID( uint32_t i_part)
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    uint32_t getDAQPartitionLockOwnerPID( uint32_t i_part);
 
 
     /// lock a detector partition
     ///
     /// @param i_part is the detector partition index (0-7)
-    bool lockDetPartition( uint32_t i_det )
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    bool lockDetPartition( uint32_t i_det );
 
 
     /// un-lock a detector partition
     ///
     /// @param i_part is the detector partition index (0-7)
-    void unlockDetPartition ( uint32_t i_det )
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    void unlockDetPartition ( uint32_t i_det );
 
 
     /// is a detector partition locked?
     ///
     /// @param i_part is the detector partition index (0-7)
-    bool isDetPartitionLocked( uint32_t i_det )
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    bool isDetPartitionLocked( uint32_t i_det );
 
 
     /// what PID owns the detector partition lock
     ///
     /// @param i_part is the detector partition index (0-7)
-    uint32_t getDetPartitionLockOwnerPID( uint32_t i_det)
-      throw (ipcutils::exception::Exception,
-	     ipcutils::exception::OutOfRange);
+    uint32_t getDetPartitionLockOwnerPID( uint32_t i_det);
 
     /// set the run number for a DAQ partition
     ///
     /// @param i_part is the DAQ partition index (0-7)
     /// @param runNumber is the 32-bit run number
-    void setPartitionRunNumber(uint32_t i_part, uint32_t runNumber)
-      throw (HAL::HardwareAccessException,
-	     d2s::exception::OutOfRange);
+    void setPartitionRunNumber(uint32_t i_part, uint32_t runNumber);
 
     /// read back the partition run number
     ///
     /// @param i_part is the DAQ partition index (0-7)
-    uint32_t readbackPartitionRunNumber(uint32_t i_part)
-      throw (HAL::HardwareAccessException,
-	     d2s::exception::OutOfRange);
+    uint32_t readbackPartitionRunNumber(uint32_t i_part);
 
     /// send resync signal to certain detector partitions
     ///
     /// @param detPartitionMask gives the detector partitions to resync (lower 8 bits)
-    void resyncDetPartitions (uint32_t detPartitionMask)
-      throw (HAL::HardwareAccessException);
+    void resyncDetPartitions (uint32_t detPartitionMask);
 
   private: 
     std::string BCDtoString(uint32_t num, uint32_t ndigit=2);
diff --git a/d2s/gtpe/include/d2s/gtpe/GTPeCrate.hh b/d2s/gtpe/include/d2s/gtpe/GTPeCrate.hh
index 76c5afb9f..77409fe02 100755
--- a/d2s/gtpe/include/d2s/gtpe/GTPeCrate.hh
+++ b/d2s/gtpe/include/d2s/gtpe/GTPeCrate.hh
@@ -34,16 +34,14 @@ namespace d2s {
     /// read the address table and determines the PCI-Devices 
     ///
     /// @param dummy: if true the dummy bus adapter will be used
-    GTPeCrate(bool dummy=false)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    GTPeCrate(bool dummy=false);
 
     /// d-tor
     virtual ~GTPeCrate();
   
     /// return the GTPeCard
     ///
-    GTPeCard& getGTPe()
-      throw (xcept::Exception);
+    GTPeCard& getGTPe();
   
   private:
     /// clean up all dynamically created objects belonging to GTPeCrate.
diff --git a/d2s/gtpe/include/d2s/gtpe/GTPeStatus.hh b/d2s/gtpe/include/d2s/gtpe/GTPeStatus.hh
index d460336ac..141aed23a 100755
--- a/d2s/gtpe/include/d2s/gtpe/GTPeStatus.hh
+++ b/d2s/gtpe/include/d2s/gtpe/GTPeStatus.hh
@@ -38,14 +38,12 @@ namespace d2s {
     /// get the sTTS Input state for Det partition 
     ///
     /// @param part_idx is the detector partition index 0..8
-    tts::TTSState getDetPartitionInputState(uint32_t part_idx)
-      throw (xcept::Exception);
+    tts::TTSState getDetPartitionInputState(uint32_t part_idx);
     
     /// get the aTTS Input state for DAQ partition 
     ///
     /// @param part_idx is the DAQ partition index 0..8
-    tts::TTSState getDAQPartitionInputState(uint32_t part_idx)
-      throw (xcept::Exception);
+    tts::TTSState getDAQPartitionInputState(uint32_t part_idx);
 
     /// get the current TCS state for a trigger partition 
     ///
@@ -53,12 +51,10 @@ namespace d2s {
     /// is controlled by software
     ///
     /// @param part_idx is the Trigger partition index 0..8
-    tts::TTSState getTCSPartitionState(uint32_t part_idx)
-      throw (xcept::Exception);
+    tts::TTSState getTCSPartitionState(uint32_t part_idx);
 
     /// is the TCS Partition Active ?
-    bool isTCSPartitionActive(uint32_t part_idx)
-      throw (xcept::Exception);
+    bool isTCSPartitionActive(uint32_t part_idx);
 
     /// is the SLINK Down
     bool isLinkDown();
diff --git a/d2s/gtpe/src/common/GTPeCard.cc b/d2s/gtpe/src/common/GTPeCard.cc
index ff3794469..859e60dab 100755
--- a/d2s/gtpe/src/common/GTPeCard.cc
+++ b/d2s/gtpe/src/common/GTPeCard.cc
@@ -31,10 +31,7 @@ static const char* trigger_rule_names[] = { "Pixel(2ebx+1eo/s)", "Tracker(2ebx)"
 
 
 
-d2s::GTPeCard::GTPeCard( HAL::PCIDevice* gtpe )
-  throw (HAL::HardwareAccessException, 
-	 ipcutils::exception::Exception,
-	 d2s::exception::IncompatibleFirmware) 
+d2s::GTPeCard::GTPeCard( HAL::PCIDevice* gtpe ) 
   : _gtpe (gtpe), 
     _latch_semaphore(toolbox::BSem::FULL),
     _semaphorearray_sema(toolbox::BSem::FULL),
@@ -596,9 +593,7 @@ uint32_t d2s::GTPeCard::readbackATTSInputMask ()
 
 
 
-void d2s::GTPeCard::lock()
-  throw (ipcutils::exception::Exception,
-	 d2s::exception::Timeout) {
+void d2s::GTPeCard::lock() {
 
   _semaphorearray_sema.take();                  // first synchronize with other threads
   uint32_t timeout_sec = 2;
@@ -626,78 +621,60 @@ void d2s::GTPeCard::unlock()
 
 
 
-bool d2s::GTPeCard::lockDAQPartition( uint32_t i_part )
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+bool d2s::GTPeCard::lockDAQPartition( uint32_t i_part ) {
 
   return _sa.takeIfUnlocked(1 + i_part);
 }
 
 
 
-void d2s::GTPeCard::unlockDAQPartition ( uint32_t i_part )
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+void d2s::GTPeCard::unlockDAQPartition ( uint32_t i_part ) {
 
   _sa.give(1 + i_part);
 }
 
 
 
-bool d2s::GTPeCard::isDAQPartitionLocked( uint32_t i_part )
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+bool d2s::GTPeCard::isDAQPartitionLocked( uint32_t i_part ) {
 
   return _sa.isLocked(1 + i_part);
 }
 
 
 
-uint32_t d2s::GTPeCard::getDAQPartitionLockOwnerPID( uint32_t i_part)
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+uint32_t d2s::GTPeCard::getDAQPartitionLockOwnerPID( uint32_t i_part) {
 
   return _sa.getPID(1 + i_part);
 }
 
 
 
-bool d2s::GTPeCard::lockDetPartition( uint32_t i_det )
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+bool d2s::GTPeCard::lockDetPartition( uint32_t i_det ) {
 
   return _sa.takeIfUnlocked(9 + i_det);
 }
 
 
 
-void d2s::GTPeCard::unlockDetPartition ( uint32_t i_det )
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+void d2s::GTPeCard::unlockDetPartition ( uint32_t i_det ) {
 
   return _sa.give(9 + i_det);
 }
 
 
-bool d2s::GTPeCard::isDetPartitionLocked( uint32_t i_det )
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+bool d2s::GTPeCard::isDetPartitionLocked( uint32_t i_det ) {
 
   return _sa.isLocked(9 + i_det);
 }
 
 
 
-uint32_t d2s::GTPeCard::getDetPartitionLockOwnerPID( uint32_t i_det)
-  throw (ipcutils::exception::Exception,
-	 ipcutils::exception::OutOfRange) {
+uint32_t d2s::GTPeCard::getDetPartitionLockOwnerPID( uint32_t i_det) {
 
   return _sa.getPID(9 + i_det);
 }
 
-void d2s::GTPeCard::setPartitionRunNumber(uint32_t i_part, uint32_t runNumber)
-  throw (HAL::HardwareAccessException,
-	 d2s::exception::OutOfRange) {
+void d2s::GTPeCard::setPartitionRunNumber(uint32_t i_part, uint32_t runNumber) {
 
   if (i_part > 7) 
     XCEPT_RAISE(d2s::exception::OutOfRange, "partition index out of range.");
@@ -709,9 +686,7 @@ void d2s::GTPeCard::setPartitionRunNumber(uint32_t i_part, uint32_t runNumber)
 
 }
 
-uint32_t d2s::GTPeCard::readbackPartitionRunNumber(uint32_t i_part)
-  throw (HAL::HardwareAccessException,
-	 d2s::exception::OutOfRange) {
+uint32_t d2s::GTPeCard::readbackPartitionRunNumber(uint32_t i_part) {
 
   if (i_part > 7) 
     XCEPT_RAISE(d2s::exception::OutOfRange, "partition index out of range.");
diff --git a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeController.hh b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeController.hh
index 078932299..c2a96a958 100755
--- a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeController.hh
+++ b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeController.hh
@@ -52,8 +52,7 @@ namespace d2s {
   public:
     XDAQ_INSTANTIATOR();
 	
-    GTPeController(xdaq::ApplicationStub * s) 
-      throw (xdaq::exception::Exception);
+    GTPeController(xdaq::ApplicationStub * s);
     virtual ~GTPeController();
 	
 
@@ -62,59 +61,49 @@ namespace d2s {
     void cleanup();
 
     /// callback function to proccess a SOAP message to change to a different state
-    xoap::MessageReference changeStateCommandHandler (xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    xoap::MessageReference changeStateCommandHandler (xoap::MessageReference msg);
 
     /// callback for state machine configure action
     ///
     /// resets and configures the GTPe using the current exported parameters
-    void ConfigureAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void ConfigureAction(toolbox::Event::Reference e);
 
     /// callback for state machine enable action
     ///
     /// enables the SLINK and Triggers, starts monitoring and workloop
-    void EnableAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void EnableAction(toolbox::Event::Reference e);
 
     /// callback for state machine stop action
     ///
     /// Stops the SLINK and trigger generation, counter monitor and workloop
-    void StopAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void StopAction(toolbox::Event::Reference e);
 
     /// callback for state machine pause action
     ///
     /// pauses the GTPe
-    void PauseAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void PauseAction(toolbox::Event::Reference e);
 
     /// callback for state machine resume action
     ///
     /// resumes the GTPe
-    void ResumeAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void ResumeAction(toolbox::Event::Reference e);
 
     /// callback for state machine halt action
     ///
     /// Stops the SLINK and trigger generation, counter monitor and workloop
-    void HaltAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void HaltAction(toolbox::Event::Reference e);
 
     /// callback for state machine transition to failed state
     ///
     /// this function logs the exception to the logger
-    void transitionToFailed(toolbox::Event::Reference e ) 
-      throw (toolbox::fsm::exception::Exception);
+    void transitionToFailed(toolbox::Event::Reference e );
 
     /// callback when a new state is entered
     /// 
-    void stateChanged(toolbox::fsm::FiniteStateMachine & fsm )
-      throw (toolbox::fsm::exception::Exception);
+    void stateChanged(toolbox::fsm::FiniteStateMachine & fsm );
 
     /// display the default web page
-    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out ) 
-      throw (xgi::exception::Exception);
+    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out );
 
     /// action to be called in workloop
     bool autoUpdateAction(toolbox::task::WorkLoop* wl);
diff --git a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeCounterMonitor.hh b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeCounterMonitor.hh
index 382dae5f8..186e49955 100755
--- a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeCounterMonitor.hh
+++ b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeCounterMonitor.hh
@@ -51,8 +51,7 @@ namespace d2s {
     /// stop the GTPeCounterMonitor
     ///
     /// should be called after stopping the GTPe but before resetting the counters
-    void stop()
-      throw (HAL::HardwareAccessException);
+    void stop();
 
     /// update all the counters
     ///
@@ -60,20 +59,17 @@ namespace d2s {
     /// At the maximum rate of 123 kHz, the 32-bit counter overrun after about 9 1/2 hours.
     /// For 8 partitions at 123 kHz => 1 hour;
     ///
-    void update()
-      throw (HAL::HardwareAccessException);
+    void update();
 
     /// read the counters
     ///
     /// calls update before
-    void readCounters(std::vector<uint64_t>& counters)
-      throw (HAL::HardwareAccessException);
+    void readCounters(std::vector<uint64_t>& counters);
 
   private:
     
     /// do the real update
-    void do_update()
-      throw (HAL::HardwareAccessException);
+    void do_update();
 
     /// read the time in seconds
     uint32_t getTime();
diff --git a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeSOAPUtility.hh b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeSOAPUtility.hh
index f66df04d7..96ed42d49 100755
--- a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeSOAPUtility.hh
+++ b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeSOAPUtility.hh
@@ -28,16 +28,14 @@ namespace d2s {
     /// The command is the first element tag in the SOAP Body
     ///
     /// returns the command std::string
-    static std::string extractSOAPCommand(xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    static std::string extractSOAPCommand(xoap::MessageReference msg);
 
     /// creates a SOAP response
     ///
     /// @param response is the the name of the response element
     /// @param state is the state passed as an sttribute in the in the response elements state child element
     static xoap::MessageReference createSOAPResponse(std::string const& response, 
-						     std::string const& state)
-      throw (xoap::exception::Exception);
+						     std::string const& state);
   };
 
 }
diff --git a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeWebInterface.hh b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeWebInterface.hh
index f949745c2..52c15f051 100755
--- a/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeWebInterface.hh
+++ b/d2s/gtpecontroller/include/d2s/gtpecontroller/GTPeWebInterface.hh
@@ -60,8 +60,7 @@ namespace d2s {
     ~GTPeWebInterface();
 
     /// display the default web page
-    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out, std::string const& statename ) 
-      throw (xgi::exception::Exception);
+    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out, std::string const& statename );
 
 
   private:
diff --git a/d2s/gtpecontroller/src/common/GTPeController.cc b/d2s/gtpecontroller/src/common/GTPeController.cc
index cac2b1bc1..bb4260a0c 100755
--- a/d2s/gtpecontroller/src/common/GTPeController.cc
+++ b/d2s/gtpecontroller/src/common/GTPeController.cc
@@ -8,8 +8,6 @@
 *
 *
 **/
-#include "log4cplus/helpers/sleep.h"
-
 #include "d2s/gtpecontroller/GTPeController.hh"
 
 // for web callback binding and HTML formatting
@@ -39,6 +37,8 @@
 
 // XDAQ exception handling
 #include "xcept/Exception.h"
+#include <chrono>
+#include <thread>
 
 XDAQ_INSTANTIATOR_IMPL(d2s::GTPeController);
 
@@ -235,8 +235,7 @@ xoap::MessageReference d2s::GTPeController::changeStateCommandHandler (xoap::Mes
 
 
 
-void d2s::GTPeController::ConfigureAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::GTPeController::ConfigureAction(toolbox::Event::Reference e) {
 
   LOG4CPLUS_INFO(getApplicationLogger(), "configuring GTPe ...");
 
@@ -405,8 +404,7 @@ void d2s::GTPeController::ConfigureAction(toolbox::Event::Reference e)
 }
 
 // here we reset some counters
-void d2s::GTPeController::EnableAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::GTPeController::EnableAction(toolbox::Event::Reference e) {
 
   try {
     _gtpecrate->getGTPe().lock();
@@ -414,7 +412,7 @@ void d2s::GTPeController::EnableAction(toolbox::Event::Reference e)
     if ( ! _gtpecrate->getGTPe().isRunning() ) {
       LOG4CPLUS_INFO(getApplicationLogger(), "Enable: GTPe is not yet running. Starting SLINK and Triggers.");
       _gtpecrate->getGTPe().startSLINK();
-      log4cplus::helpers::sleepmillis(1);    
+      std::this_thread::sleep_for(std::chrono::milliseconds(1));
       _gtpecrate->getGTPe().startTriggers();
     }
 
@@ -440,8 +438,7 @@ void d2s::GTPeController::EnableAction(toolbox::Event::Reference e)
 
 }
 
-void d2s::GTPeController::StopAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::GTPeController::StopAction(toolbox::Event::Reference e) {
 
   try {
     // stop the workloop
@@ -459,7 +456,7 @@ void d2s::GTPeController::StopAction(toolbox::Event::Reference e)
     if (last) {
       LOG4CPLUS_INFO(getApplicationLogger(), "No other DAQ partitions are using the GTPe. Stopping also the triggers and SLINK.");
       _gtpecrate->getGTPe().stopTriggers();
-      log4cplus::helpers::sleep(1);
+      std::this_thread::sleep_for(std::chrono::seconds(1));
       _gtpecrate->getGTPe().stopSLINK();
     }
 
@@ -483,8 +480,7 @@ void d2s::GTPeController::StopAction(toolbox::Event::Reference e)
 }
 
 
-void d2s::GTPeController::PauseAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::GTPeController::PauseAction(toolbox::Event::Reference e) {
 
 
   try {
@@ -509,8 +505,7 @@ void d2s::GTPeController::PauseAction(toolbox::Event::Reference e)
 
 }
 
-void d2s::GTPeController::ResumeAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::GTPeController::ResumeAction(toolbox::Event::Reference e) {
 
   try {
     _gtpecrate->getGTPe().lock();
@@ -533,8 +528,7 @@ void d2s::GTPeController::ResumeAction(toolbox::Event::Reference e)
 
 }
 
-void d2s::GTPeController::HaltAction(toolbox::Event::Reference e) 
-  throw(toolbox::fsm::exception::Exception) {
+void d2s::GTPeController::HaltAction(toolbox::Event::Reference e) {
 
   try {
     // we may get here from basically any state
@@ -556,7 +550,7 @@ void d2s::GTPeController::HaltAction(toolbox::Event::Reference e)
     if (last) {
       LOG4CPLUS_INFO(getApplicationLogger(), "No other DAQ partitions are using the GTPe. Stopping also the triggers and SLINK.");
       _gtpecrate->getGTPe().stopTriggers();
-      log4cplus::helpers::sleep(1);
+      std::this_thread::sleep_for(std::chrono::seconds(1));
       _gtpecrate->getGTPe().stopSLINK();
     }
 
@@ -637,8 +631,8 @@ bool d2s::GTPeController::autoUpdateAction(toolbox::task::WorkLoop* wl) {
       _gtpecrate->getGTPe().unlock();
     }
   }
-
-  log4cplus::helpers::sleepmillis(100);    
+  std::this_thread::sleep_for(std::chrono::milliseconds(100));
+  
 
   // instead of sleeping for 1 hour, we sleep 30000 times for 100 ms. 
   // the result should be slightly less than 1 hour of sleeping
diff --git a/d2s/gtpecontroller/src/common/GTPeWebInterface.cc b/d2s/gtpecontroller/src/common/GTPeWebInterface.cc
index 4dce35d60..5c65f03aa 100755
--- a/d2s/gtpecontroller/src/common/GTPeWebInterface.cc
+++ b/d2s/gtpecontroller/src/common/GTPeWebInterface.cc
@@ -10,9 +10,6 @@
 **/
 #include "d2s/gtpecontroller/GTPeWebInterface.hh"
 
-#include "log4cplus/helpers/sleep.h"
-
-// for web callback binding and HTML formatting
 #include "xgi/Method.h"
 #include "xgi/Utils.h"
 #include "cgicc/HTMLClasses.h"
@@ -36,6 +33,8 @@
 #include <stdint.h>
 #include <time.h>
 #include <fstream>
+#include <chrono>
+#include <thread>
 
 d2s::GTPeWebInterface::GTPeWebInterface(xdaq::Application* owner,
 					d2s::GTPeParameters& config,
@@ -83,7 +82,8 @@ void d2s::GTPeWebInterface::displayDefaultWebPage(xgi::Input * in, xgi::Output *
       if (daqPartIdx == _config.daqPartitionId.value_) {
 	uint32_t rateBitsBeforePause = _gtpecrate->getGTPe().readbackRate( _config.daqPartitionId.value_ );
 	_gtpecrate->getGTPe().setPartitionDef( _config.daqPartitionId.value_, 0, 0.);
-	log4cplus::helpers::sleepmillis(1000);    
+	
+	std::this_thread::sleep_for(std::chrono::milliseconds(100));
 	_gtpecrate->getGTPe().resyncDetPartitions( _config.detPartitionEnableMask.value_ );
 	_gtpecrate->getGTPe().setPartitionDef(  _config.daqPartitionId.value_, _config.detPartitionEnableMask, rateBitsBeforePause);
 	++_resyncCount;
diff --git a/d2s/utils/include/d2s/utils/HardwareDebugger.hh b/d2s/utils/include/d2s/utils/HardwareDebugger.hh
index 63ca909a7..a2b6ad3c4 100644
--- a/d2s/utils/include/d2s/utils/HardwareDebugger.hh
+++ b/d2s/utils/include/d2s/utils/HardwareDebugger.hh
@@ -18,11 +18,9 @@ namespace utils
         
         HardwareDebugger( log4cplus::Logger logger, std::vector<HAL::HardwareDeviceInterface  *> devices); 
 
-        xoap::MessageReference readItem( xoap::MessageReference msg ) 
-            throw( xoap::exception::Exception);
+        xoap::MessageReference readItem( xoap::MessageReference msg );
 
-        xoap::MessageReference writeItem( xoap::MessageReference msg ) 
-            throw( xoap::exception::Exception);
+        xoap::MessageReference writeItem( xoap::MessageReference msg );
 
         std::list< utils::HardwareDebugItem > getSlinkExpressRegisters( uint32_t linkNo );
 
diff --git a/d2s/utils/include/d2s/utils/version.h b/d2s/utils/include/d2s/utils/version.h
index f3d61aec6..16f5c357e 100755
--- a/d2s/utils/include/d2s/utils/version.h
+++ b/d2s/utils/include/d2s/utils/version.h
@@ -40,7 +40,7 @@ namespace d2sutils
 	const std::string summary = "Contains useful utilities to be shared by hardware controller applications such as ferol, amc13controller, ferol40.";
 	const std::string link = "http://xdaq.web.cern.ch";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/d2s/utils/src/common/HardwareDebugger.cc b/d2s/utils/src/common/HardwareDebugger.cc
index 4bc87b528..0276a68e3 100644
--- a/d2s/utils/src/common/HardwareDebugger.cc
+++ b/d2s/utils/src/common/HardwareDebugger.cc
@@ -231,7 +231,6 @@ utils::HardwareDebugger::getPCIRegisters( HAL::HardwareDeviceInterface *device )
 // where deviceType is frl amc13 or bridge
 
 xoap::MessageReference utils::HardwareDebugger::readItem( xoap::MessageReference msg ) 
-    throw( xoap::exception::Exception) 
 {
    std::cout << "readItem()" << std::endl;  
     uint64_t result = 0;
@@ -331,7 +330,6 @@ xoap::MessageReference utils::HardwareDebugger::readItem( xoap::MessageReference
 
 
 xoap::MessageReference utils::HardwareDebugger::writeItem( xoap::MessageReference msg ) 
-    throw( xoap::exception::Exception) 
 {
     std::cout << "writeItem()" << std::endl; 
     uint64_t data = 0;
diff --git a/d2s/utils/src/common/version.cc b/d2s/utils/src/common/version.cc
index dc029e4d7..e75201029 100755
--- a/d2s/utils/src/common/version.cc
+++ b/d2s/utils/src/common/version.cc
@@ -20,7 +20,7 @@
 
 GETPACKAGEINFO(d2sutils)
 
-void d2sutils::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void d2sutils::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 	CHECKDEPENDENCY(xcept);  
diff --git a/evb/include/evb/readoutunit/PipeHandler.h b/evb/include/evb/readoutunit/PipeHandler.h
index 764a530ec..8f80c0aa4 100644
--- a/evb/include/evb/readoutunit/PipeHandler.h
+++ b/evb/include/evb/readoutunit/PipeHandler.h
@@ -215,16 +215,24 @@ bool evb::readoutunit::PipeHandler<ReadoutUnit,Configuration>::processPipe(toolb
 
       if ( inputPipe_->dequeue(&event) )
       {
-        SocketBufferPtr socketBuffer( new SocketBuffer(event.ref,releaseFunction_) );
-        ++outstandingBuffers_;
         workDone = true;
 
-        if ( ! readoutUnit_->getConfiguration()->dropAtSocket )
+        if ( readoutUnit_->getConfiguration()->dropAtSocket )
         {
-          boost::mutex::scoped_lock sl(socketStreamsMutex_);
-          const typename SocketStreams::iterator pos = socketStreams_.find(event.sid);
-          if ( pos != socketStreams_.end() )
-            pos->second->addBuffer(socketBuffer);
+          readoutUnit_->addSocketBufferToPerf(event.ref->getDataSize());
+          inputPipe_->grantBuffer(event.ref);
+        }
+        else
+        {
+          SocketBufferPtr socketBuffer( new SocketBuffer(event.ref,releaseFunction_) );
+          ++outstandingBuffers_;
+
+          {
+            boost::mutex::scoped_lock sl(socketStreamsMutex_);
+            const typename SocketStreams::iterator pos = socketStreams_.find(event.sid);
+            if ( pos != socketStreams_.end() )
+              pos->second->addBuffer(socketBuffer);
+          }
         }
       }
 
diff --git a/evb/include/evb/readoutunit/ReadoutUnit.h b/evb/include/evb/readoutunit/ReadoutUnit.h
index 02c453b70..e19ac48c0 100644
--- a/evb/include/evb/readoutunit/ReadoutUnit.h
+++ b/evb/include/evb/readoutunit/ReadoutUnit.h
@@ -62,6 +62,7 @@ namespace evb {
       uint32_t getEventNumberToStop() const
       { return stopLocalInputAtEvent_.value_; }
 
+      void addSocketBufferToPerf(const uint32_t bufferSize);
 
     protected:
 
@@ -90,6 +91,19 @@ namespace evb {
       void writeNextFragmentsToFile(xgi::Input*, xgi::Output*) ;
       void displayDipStatusTable(xgi::Input*, xgi::Output*);
 
+      struct SocketMonitor
+      {
+        uint32_t rate;
+        uint32_t size;
+        PerformanceMonitor perf;
+
+        SocketMonitor() { reset(); }
+
+        void reset() { rate=0;size=0; }
+      };
+      SocketMonitor socketMonitor_;
+      mutable boost::mutex socketMonitorMutex_;
+
       xdata::UnsignedInteger32 eventsInRU_;
       xdata::UnsignedInteger32 eventRate_;
       xdata::UnsignedInteger32 superFragmentSize_;
@@ -166,6 +180,17 @@ void evb::readoutunit::ReadoutUnit<Unit,Configuration,StateMachine>::do_updateMo
   eventsInRU_ = eventCount>fragmentCount ? eventCount-fragmentCount : 0;
 
   this->stateMachine_->updateMonitoringItems();
+
+  {
+    boost::mutex::scoped_lock sl(socketMonitorMutex_);
+
+    const double deltaT = socketMonitor_.perf.deltaT();
+    socketMonitor_.rate = socketMonitor_.perf.logicalRate(deltaT);
+    if ( socketMonitor_.rate > 0 )
+      socketMonitor_.size = socketMonitor_.perf.size();
+
+    socketMonitor_.perf.reset();
+  }
 }
 
 
@@ -186,16 +211,33 @@ void evb::readoutunit::ReadoutUnit<Unit,Configuration,StateMachine>::do_handleIt
 template<class Unit,class Configuration,class StateMachine>
 void evb::readoutunit::ReadoutUnit<Unit,Configuration,StateMachine>::do_handleItemRetrieveEvent(const std::string& item)
 {
-  if (item == "eventRate")
-    eventRate_ = input_->getEventRate();
-  else if (item == "lastEventNumber")
+  if (item == "lastEventNumber")
     lastEventNumber_ = input_->getLastEventNumber();
   else if (item == "eventCount")
     eventCount_ = input_->getEventCount();
   else if (item == "nbEventsBuilt")
     nbEventsBuilt_ = buProxy_->getNbEventsBuilt();
-  else if (item == "superFragmentSize")
-    superFragmentSize_ = input_->getSuperFragmentSize();
+  else {
+    if (this->configuration_->dropAtSocket)
+    {
+      if (item == "eventRate")
+      {
+        boost::mutex::scoped_lock sl(socketMonitorMutex_);
+        eventRate_ = socketMonitor_.rate;
+      }
+      else if (item == "superFragmentSize")
+      {
+        boost::mutex::scoped_lock sl(socketMonitorMutex_);
+        superFragmentSize_ = socketMonitor_.size;
+      }
+    }
+    else {
+      if (item == "eventRate")
+        eventRate_ = input_->getEventRate();
+      else if (item == "superFragmentSize")
+        superFragmentSize_ = input_->getSuperFragmentSize();
+    }
+  }
 }
 
 
@@ -358,11 +400,22 @@ void evb::readoutunit::ReadoutUnit<Unit,Configuration,StateMachine>::getLatestLu
   xgi::Input  *in,
   xgi::Output *out
 )
-
 {
   *out << buProxy_->getLatestLumiSection();
 }
 
+
+template<class Unit,class Configuration,class StateMachine>
+void evb::readoutunit::ReadoutUnit<Unit,Configuration,StateMachine>::addSocketBufferToPerf(const uint32_t bufferSize)
+{
+  boost::mutex::scoped_lock sl(socketMonitorMutex_);
+
+  socketMonitor_.perf.logicalCount++;
+  socketMonitor_.perf.sumOfSizes += bufferSize;
+  socketMonitor_.perf.sumOfSquares += bufferSize*bufferSize;
+}
+
+
 #endif // _evb_readoutunit_ReadoutUnit_h_
 
 
diff --git a/evb/include/evb/version.h b/evb/include/evb/version.h
index b3f6ea6e4..21e1eca29 100644
--- a/evb/include/evb/version.h
+++ b/evb/include/evb/version.h
@@ -4,7 +4,7 @@
 #include "config/PackageInfo.h"
 
 #define EVB_VERSION_MAJOR 6
-#define EVB_VERSION_MINOR 0
+#define EVB_VERSION_MINOR 1
 #define EVB_VERSION_PATCH 0
 #undef EVB_PREVIOUS_VERSIONS
 
diff --git a/evb/test/cases/daq3valSymbolMap.py b/evb/test/cases/daq3valSymbolMap.py
index acc7d5f5b..13d3c8ea8 100644
--- a/evb/test/cases/daq3valSymbolMap.py
+++ b/evb/test/cases/daq3valSymbolMap.py
@@ -29,19 +29,26 @@ hosts = [
     "d3vrubu-c2e33-08-01",
 ]
 
-# add RUs and BUs
+# add RUs, BUs, and RUBUs
 ruIndex = 0
 buIndex = 0
+rubuIndex = 0
 
 for host in hosts:
 
 #    if host in ("d3vrubu-c2e34-18-01"):
 #    if host in ("d3vrubu-c2e34-20-01"):
-    if host in (""):
-        data['BU%d_SOAP_HOST_NAME' % buIndex] = host + ".cms"
-        data['BU%d_I2O_HOST_NAME' % buIndex] = host + dataNetwork
-        buIndex += 1
-    else:
-        data['RU%d_SOAP_HOST_NAME' % ruIndex] = host + ".cms"
-        data['RU%d_I2O_HOST_NAME' % ruIndex] = host + dataNetwork
-        ruIndex += 1
+#    if host not in ("d3vrubu-c2e34-18-01"): # EVM without BU
+#    if host not in (""): # run a BU on the EVM host
+#    if ruIndex > 7:
+    data['BU%d_SOAP_HOST_NAME' % buIndex] = host + ".cms"
+    data['BU%d_I2O_HOST_NAME' % buIndex] = host + dataNetwork
+    buIndex += 1
+#    else:
+    data['RU%d_SOAP_HOST_NAME' % ruIndex] = host + ".cms"
+    data['RU%d_I2O_HOST_NAME' % ruIndex] = host + dataNetwork
+    ruIndex += 1
+
+    data['RUBU%d_SOAP_HOST_NAME' % rubuIndex] = host + ".cms"
+    data['RUBU%d_I2O_HOST_NAME' % rubuIndex] = host + dataNetwork
+    rubuIndex += 1
diff --git a/evb/test/scripts/Application.py b/evb/test/scripts/Application.py
index 915057c84..eb36f3f34 100644
--- a/evb/test/scripts/Application.py
+++ b/evb/test/scripts/Application.py
@@ -163,6 +163,12 @@ class Application:
             context.append(copy.deepcopy(endpoint))
             endpoint.set('port',self.params['frlPort2'])
             endpoint.set('network','ferolb')
+            context.append(copy.deepcopy(endpoint))
+            endpoint.set('port',self.params['frlPort3'])
+            endpoint.set('network','ferolc')
+            context.append(copy.deepcopy(endpoint))
+            endpoint.set('port',self.params['frlPort4'])
+            endpoint.set('network','ferold')
             context.append(endpoint)
         except KeyError:
             pass
diff --git a/evb/test/scripts/Configuration.py b/evb/test/scripts/Configuration.py
index aa8749b7b..c3743e576 100644
--- a/evb/test/scripts/Configuration.py
+++ b/evb/test/scripts/Configuration.py
@@ -138,8 +138,8 @@ class Configuration():
 
 class ConfigFromFile(Configuration):
 
-    def __init__(self,symbolMap,configFile,fixPorts,useNuma,generateAtRU,dropAtRU,dropAtSocket,ferolMode):
-        self.frlPorts = ['60500','60600']
+    def __init__(self,symbolMap,configFile,fixPorts,useNuma,generateAtRU,dropAtRU,dropAtSocket,ferolMode,ferolsOnly):
+        self.frlPorts = ['60500','60600','60700','60800']
         self.fedId2Port = {}
         Configuration.__init__(self,symbolMap,useNuma)
 
@@ -180,6 +180,8 @@ class ConfigFromFile(Configuration):
                         portNb += 1
 
             for application in c.findall(QN(self.xcns,'Application').text): ## all 'Application's of this context
+                if ferolsOnly and not application.attrib['class'].startswith(('ferol::','ferol40::')):
+                    continue
                 if generateAtRU and application.attrib['class'] == "pt::blit::Application":
                     continue
                 properties = self.getProperties(application)
@@ -190,6 +192,8 @@ class ConfigFromFile(Configuration):
                     app.params['frlHostname'] = context.hostinfo['frlHostname']
                     app.params['frlPort'] = self.frlPorts[0]
                     app.params['frlPort2'] = self.frlPorts[1]
+                    app.params['frlPort3'] = self.frlPorts[2]
+                    app.params['frlPort4'] = self.frlPorts[3]
                     app.params['maxbulksize'] = maxbulksize
                 elif app.params['class'] == 'pt::ibv::Application':
                     app.params['protocol'] = 'ibv'
@@ -360,7 +364,7 @@ class ConfigFromFile(Configuration):
 if __name__ == "__main__":
     symbolMap = SymbolMap.SymbolMap(os.environ["EVB_TESTER_HOME"]+"/cdaq/20170131/canon_1str_4x4/symbolMap.txt")
     config = ConfigFromFile(symbolMap,os.environ["EVB_TESTER_HOME"]+"/cdaq/20170131/canon_1str_4x4/canon_1str_4x4.xml",
-                                fixPorts=False,useNuma=True,generateAtRU=False,dropAtRU=False,dropAtSocket=False,ferolMode=True)
+                                fixPorts=False,useNuma=True,generateAtRU=False,dropAtRU=False,dropAtSocket=False,ferolMode=True,ferolsOnly=False)
     #print(config.contexts)
     for key in config.contexts.keys():
         config.getConfigCmd(key)
diff --git a/evb/test/scripts/Context.py b/evb/test/scripts/Context.py
index 875d23198..52637283d 100644
--- a/evb/test/scripts/Context.py
+++ b/evb/test/scripts/Context.py
@@ -247,27 +247,33 @@ class RU(Context):
         # extracted from XML policy with
         # egrep -o '[[:alnum:]]+=".*"' scripts/tmp.txt |sed -re 's/([[:alnum:]]+)=/"\1":/g'|tr "\"" "'"|tr " " ","|sed -re 's/(.*)/{\1},/'
         policyElements = [
+            {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/dummySuperFragment/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_0/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][3],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_1/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_2/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][10],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_3/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][11],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_4/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][14],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_5/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][0],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloops(.*)/polling','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][0],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/buPoster/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][4],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:fifo/PeerTransport/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][4],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:tcpla-ia(.+)/'+str(self.hostinfo['i2oHostname'])+':btcp/(.*)','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][10],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::[EVM,RU](.+)/monitoring/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][12],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloopr(.*)/polling','type':'thread'},
             {'cpunodes':numaInfo['ethCPU'],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::acceptor(.*)/waiting','type':'thread'},
             {'cpunodes':numaInfo['ethCPU'],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::eventworkloop/polling','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][1],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloopr(.*)/polling','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][3],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloops(.*)/polling','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][8],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_2/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][12],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_3/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][13],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_4/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][10],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_5/waiting','type':'thread'},
-            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-receiver(.+*):ibvla','type':'alloc'},
-            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-sender(.*):ibvla','type':'alloc'},
-            {'cpunodes':numaInfo['ibvCPU'],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/monitoring/waiting','type':'thread'},
+            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-receiver(.*):ibvla','type':'alloc'},
+            {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-sender(.*):ibvla','type':'alloc'},
+            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:pt::ibv::(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fragmentRequestFIFO(.+)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:fragmentFIFO_FED(.+)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:frameFIFO_BU(.+)','type':'alloc'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:tcpla-ia(.+)/'+str(self.hostinfo['i2oHostname'])+':btcp/(.*)','type':'thread'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-blit-socket(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:pt-blit-inputpipe-rlist(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:socketBufferFIFO(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:grantFIFO(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:tcpla-(.*)/'+str(self.hostinfo['i2oHostname'])+'(.*)','type':'alloc'},
-            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:pt::ibv::(.*)','type':'alloc'}
+            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fifo-PeerTransport:alloc','type':'alloc'}
         ]
         try:
             policyElements.extend([
@@ -280,27 +286,18 @@ class RU(Context):
             pass
 
         if RU.instance == 0: #EVM
-            workerCores = (1,3,6,9,11,12,14,15)
+            socketThreads = (1,4)
             policyElements.extend([
-                {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_0/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][4],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_1/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][5],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/processRequests/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/buPoster/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/dummySuperFragment/waiting','type':'thread'},
+                {'affinity':numaInfo[numaInfo['ibvCPU']][4],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/processRequests/waiting','type':'thread'},
                 {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:readoutMsgFIFO(.+)','type':'alloc'}
                 ])
         else: #RU
-            workerCores = (0,1,3,6,7,9,11,14,15)
-            policyElements.extend([
-                {'affinity':numaInfo[numaInfo['ibvCPU']][4],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_0/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][5],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_1/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/buPoster/waiting','type':'thread'},
-                {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/dummySuperFragment/waiting','type':'thread'}
-                ])
+            socketThreads = (1,4,8,9,15)
         policyElements.extend([
-                {'affinity':','.join([numaInfo[numaInfo['ibvCPU']][i] for i in workerCores]),'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/parseSocketBuffers_(.*)/waiting','type':'thread'},
-                {'affinity':','.join([numaInfo[numaInfo['ibvCPU']][i] for i in workerCores]),'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/generating_(.*)/waiting','type':'thread'}
-                ])
+            {'affinity':','.join([numaInfo[numaInfo['ibvCPU']][i] for i in socketThreads]),'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/parseSocketBuffers_(.*)/waiting','type':'thread'},
+            {'affinity':','.join([numaInfo[numaInfo['ibvCPU']][i] for i in socketThreads]),'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/generating_(.*)/waiting','type':'thread'},
+            ])
+
         return policyElements
 
 
@@ -327,31 +324,31 @@ class BU(Context):
         #print self.hostinfo['soapHostname'],numaInfo
 
         policyElements = [
+            {'affinity':numaInfo[numaInfo['ethCPU']][0],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloops(.*)/polling','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][1],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_0/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_1/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][3],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_2/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][4],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_3/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][5],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_4/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][6],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_5/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][7],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_6/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][8],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_7/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][9],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_8/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][10],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_9 /waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][15],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/requestFragments/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][14],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/fileMover/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][13],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/lumiAccounting/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][11],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/resourceMonitor/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ethCPU']][12],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/monitoring/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][4],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::BU(.+)/monitoring/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][4],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:fifo/PeerTransport/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][5],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_3/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][6],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_4/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_5/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][8],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_6/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][9],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_7/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][11],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/requestFragments/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][13],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/fileMover/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][14],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/resourceMonitor/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][15],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/lumiAccounting/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][6],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloopr(.*)/polling','type':'thread'},
+            {'cpunodes':numaInfo['ethCPU'],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::acceptor(.*)/waiting','type':'thread'},
+            {'cpunodes':numaInfo['ethCPU'],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::eventworkloop/polling','type':'thread'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:superFragmentFIFO(.+)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fileStatisticsFIFO_stream(.+):alloc','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:resourceFIFO:alloc','type':'alloc'},
-            {'cpunodes':numaInfo['ethCPU'],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::acceptor-(.+)/waiting','type':'thread'},
-            {'cpunodes':numaInfo['ethCPU'],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::eventworkloop/polling','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][5],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloops(.*)/polling','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][6],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloopr(.*)/polling','type':'thread'},
-            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv(.*):ibvla','type':'alloc'},
+            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-receiver(.*):ibvla','type':'alloc'},
+            {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-sender(.*):ibvla','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:pt::ibv::(.*)','type':'alloc'},
-            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:undefined','type':'alloc'}
+            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fifo-PeerTransport:alloc','type':'alloc'}
             ]
         return policyElements
 
@@ -363,7 +360,7 @@ class RUBU(RU):
             role = 'EVM'
         else:
             role = 'RUBU'
-        Context.__init__(self,role,symbolMap.getHostInfo('RU'+str(RU.instance)))
+        Context.__init__(self,role,symbolMap.getHostInfo('RUBU'+str(RU.instance)))
         self.addPeerTransport()
         self.addRuApplication(ruProperties)
         self.addBuApplication(buProperties)
@@ -384,24 +381,25 @@ class RUBU(RU):
             {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/dummySuperFragment/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ibvCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_0/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ibvCPU']][3],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_1/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][5],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloops(.*)/polling','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][6],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloopr(.*)/polling','type':'thread'},
             {'affinity':numaInfo[numaInfo['ibvCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_2/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ibvCPU']][10],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_3/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ibvCPU']][11],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_4/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ibvCPU']][13],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:fifo/PeerTransport/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ibvCPU']][14],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Responder_5/waiting','type':'thread'},
-            {'affinity':numaInfo[numaInfo['ibvCPU']][14],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:fifo/PeerTransport/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][0],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloops(.*)/polling','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][0],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/buPoster/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][1],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_0/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][2],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_1/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][3],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_2/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][4],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:tcpla-ia(.+)/'+str(self.hostinfo['i2oHostname'])+':btcp/(.*)','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][5],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_3/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][6],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_4/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][7],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_5/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][8],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_6/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][9],'memnode':numaInfo['ibvCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/Builder_7/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][10],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::[EVM,RU](.+)/monitoring/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][11],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/requestFragments/waiting','type':'thread'},
+            {'affinity':numaInfo[numaInfo['ethCPU']][12],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::BU(.+)/monitoring/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][12],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:pt::ibv::completionworkloopr(.*)/polling','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][13],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/fileMover/waiting','type':'thread'},
             {'affinity':numaInfo[numaInfo['ethCPU']][14],'memnode':numaInfo['ethCPU'],'mempolicy':'onnode','package':'numa','pattern':'urn:toolbox-task-workloop:evb::(.+)/resourceMonitor/waiting','type':'thread'},
@@ -411,7 +409,7 @@ class RUBU(RU):
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:superFragmentFIFO(.+)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fileStatisticsFIFO_stream(.+):alloc','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:resourceFIFO:alloc','type':'alloc'},
-            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-receiver(.+*):ibvla','type':'alloc'},
+            {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-receiver(.*):ibvla','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:toolbox-mem-allocator-ibv-sender(.*):ibvla','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:pt::ibv::(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fragmentRequestFIFO(.+)','type':'alloc'},
@@ -421,6 +419,7 @@ class RUBU(RU):
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:pt-blit-inputpipe-rlist(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:socketBufferFIFO(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:grantFIFO(.*)','type':'alloc'},
+            {'mempolicy':'onnode','node':numaInfo['ibvCPU'],'package':'numa','pattern':'urn:tcpla-(.*)/'+str(self.hostinfo['i2oHostname'])+'(.*)','type':'alloc'},
             {'mempolicy':'onnode','node':numaInfo['ethCPU'],'package':'numa','pattern':'urn:fifo-PeerTransport:alloc','type':'alloc'}
             ]
 
diff --git a/evb/test/scripts/TestCase.py b/evb/test/scripts/TestCase.py
index 2b9691245..c49cf5bc5 100644
--- a/evb/test/scripts/TestCase.py
+++ b/evb/test/scripts/TestCase.py
@@ -45,24 +45,25 @@ class FileException(Exception):
 import xmlrpclib
 
 def startXDAQ(context,testname,logLevel):
-    ret = "Starting XDAQ on "+context.hostinfo['soapHostname']+":"+str(context.hostinfo['launcherPort'])+"\n"
-
-    server = xmlrpclib.ServerProxy("http://%s:%s" % (context.hostinfo['soapHostname'],context.hostinfo['launcherPort']))
-
-    if logLevel is not None:
-        server.setLogLevel(context.hostinfo['soapPort'],logLevel)
-
-    ret += server.startXDAQ(context.hostinfo['soapPort'],testname)
-    return ret
+    try:
+        ret = "Starting XDAQ on "+context.hostinfo['soapHostname']+":"+str(context.hostinfo['launcherPort'])+"\n"
+        server = xmlrpclib.ServerProxy("http://%s:%s" % (context.hostinfo['soapHostname'],context.hostinfo['launcherPort']))
+        if logLevel is not None:
+            server.setLogLevel(context.hostinfo['soapPort'],logLevel)
+        ret += server.startXDAQ(context.hostinfo['soapPort'],testname)
+        return ret
+    except Exception as e:
+        raise LauncherException("Failed to start XDAQ on "+context.hostinfo['soapHostname']+":"+str(context.hostinfo['launcherPort'])+": "+str(e))
 
 
 def stopXDAQ(context):
-    ret = "Stopping XDAQ on "+context.hostinfo['soapHostname']+":"+str(context.hostinfo['launcherPort'])+"\n"
-
-    server = xmlrpclib.ServerProxy("http://%s:%s" % (context.hostinfo['soapHostname'],context.hostinfo['launcherPort']))
-
-    ret += server.stopXDAQ(context.hostinfo['soapPort'])
-    return ret
+    try:
+        ret = "Stopping XDAQ on "+context.hostinfo['soapHostname']+":"+str(context.hostinfo['launcherPort'])+"\n"
+        server = xmlrpclib.ServerProxy("http://%s:%s" % (context.hostinfo['soapHostname'],context.hostinfo['launcherPort']))
+        ret += server.stopXDAQ(context.hostinfo['soapPort'])
+        return ret
+    except Exception as e:
+        raise LauncherException("Failed to stop XDAQ on "+context.hostinfo['soapHostname']+":"+str(context.hostinfo['launcherPort'])+": "+str(e))
 
 
 def sendCmdToExecutive(context,configCmd):
@@ -701,7 +702,7 @@ class TestCase:
 
 
     def calculateFedSize(self,fedId,fragSize,fragSizeRMS):
-        if fedId == self._config.evmFedId:
+        if hasattr(self._config,'evmFedId') and fedId == self._config.evmFedId:
             return 1024,0
         else:
             return int(fragSize),int(fragSizeRMS)
@@ -754,7 +755,7 @@ class TestCase:
                                 messengers.setParam('ferolSources','Array',sources,**application)
 
 
-    def start(self):
+    def start(self,args):
         """
         configures and enables (starts) the event builder
         """
@@ -762,7 +763,8 @@ class TestCase:
         runNumber=time.strftime("%s",time.localtime())
         self.configureEvB(maxTries=30)
         self.enableEvB(maxTries=30,runNumber=runNumber)
-        self.checkRate()
+        if 'ferolsOnly' in args and not args['ferolsOnly']:
+            self.checkRate()
 
 
     def prepare(self,testname,maxTries=10):
@@ -817,7 +819,7 @@ class TestCase:
         self.setFragmentSizes(fragSize,fragSizeRMS)
 
         # start running
-        self.start()
+        self.start(args)
 
         if args['nbMeasurements'] == 0:
             dataPoints.append( self.getDataPoint() )
diff --git a/evb/test/scripts/TestRunner.py b/evb/test/scripts/TestRunner.py
index b90770e22..11560a2ed 100644
--- a/evb/test/scripts/TestRunner.py
+++ b/evb/test/scripts/TestRunner.py
@@ -47,6 +47,7 @@ class TestRunner:
             print("Does the environment variable EVB_TESTER_HOME point to the correct directory ?")
             sys.exit(2)
 
+        self._symbolMap = None
         self.defaultFedSize = 2048.
 
 
@@ -74,7 +75,7 @@ class TestRunner:
 
 
     def getFedSizes(self):
-        allSizes = [256,512,768,1024,1149,1280,1408,1536,1664,1856,2048,2560,4096,8192,12288]
+        allSizes = [256,512,768,1024,1149,1280,1408,1536,1664,1856,2048,2560,2992,3418,4096,6144,8192,12288]
         shortSizes = [256,512,768,1024,1280,1536,2048,2560,4096,8192,12288]
         if self.args['relsizes']:
             return [ int(r * self.defaultFedSize) for r in self.args['relsizes'] ]
diff --git a/evb/test/scripts/createConfig.py b/evb/test/scripts/createConfig.py
index 9ebba4329..2a742545e 100755
--- a/evb/test/scripts/createConfig.py
+++ b/evb/test/scripts/createConfig.py
@@ -38,12 +38,15 @@ class CreateConfig:
                    '-jar','/nfshome0/rcms/centralRcmsServices/staticContent/daq2_configurator/pro/lib/configurator.jar',
                    '--properties',self.args['properties'],
                    '--batch',
-                   '--buildDPSet',
-                   '--fbSet',self.args['fbset'],
                    '--nBU',self.args['nBU'],
                    '--makeConfig',
                    '--swt',self.args['swt'],
                    '--saveXML',configFile]
+        if self.args['dpSet']:
+            javaCmd.extend(['--dpSet',self.args['dpSet']])
+        else:
+            javaCmd.extend(['--buildDPSet',
+                            '--fbSet',self.args['fbSet']])
         if self.args['daqval']:
             javaCmd.extend(['--mainRCMSHost','cmsrc-daqvaldev.cms',
                             '--routingOptimizer','EVB2_OPTIMIZER',
@@ -225,11 +228,12 @@ class CreateConfig:
 if __name__ == "__main__":
     from argparse import ArgumentParser
     parser = ArgumentParser()
-    parser.add_argument("fbset",help="Fed-builder set to use")
+    parser.add_argument("fbSet",help="Fed-builder set to use")
     parser.add_argument("swt",help="Software template to use")
     parser.add_argument("nBU",help="Number of BUs")
     parser.add_argument("output",help="Path to output directory")
     parser.add_argument("-p","--properties",default=os.environ['HOME']+'/CONFIGURATOR.properties',help="use properties file [default: %(default)s]")
+    parser.add_argument("--dpSet",help="Use pre-defined DPset instead of FBset")
     parser.add_argument("-b","--useBlacklist",action='store_true',help="use latest blacklist")
     parser.add_argument("--ferolMode",action='store_true',help="generate data on FEROL instead of FRL")
     parser.add_argument("-l","--hostList",help="only use RUs and BUs from the given file")
diff --git a/evb/test/scripts/createDaq2valConfigs.sh b/evb/test/scripts/createDaq2valConfigs.sh
index 3e1734a43..d07e97d4e 100755
--- a/evb/test/scripts/createDaq2valConfigs.sh
+++ b/evb/test/scripts/createDaq2valConfigs.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
 
-#swt=/DAQ2_Official/StandAlone/StandAlone_40g_infini_dropAtBU
-swt=/Test/Remi/StandAlone/StandAlone_40g_infini_dropAtBU
-hwcfg=/daq2val/eq_160316_emu
-dir=../daq2val/20170316
+swt=/DAQ2_Official/StandAlone/StandAlone_40g_infini_dropAtBU
+#swt=/Test/Remi/StandAlone/StandAlone_40g_infini_dropAtBU
+hwcfg=/daq2val/eq_180831
+dir=../daq2val/20190129
 mkdir -p $dir
 
 (
@@ -14,12 +14,19 @@ BU_CALC_CRC32C false
 EOF
 ) > /tmp/$$.txt
 
-for setting in '4s4f' '8s8f' '12s12f' '16s16f' '24s24f' '4s2f' '8s4f' '12s6f' '16s8f' '24s12f' ; do
-#for setting in '16s16f' ; do
-    #./createConfig.py $hwcfg/1fb_$setting $swt 2 $dir/${setting}x1x2_noChksums -s /tmp/$$.txt --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties
-    ./createConfig.py $hwcfg/1fb_$setting $swt 2 $dir/${setting}x1x2 --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties
+(
+cat <<EOF
+EVM_CREATE_FED1022 false
+EOF
+) > /tmp/fed1022_$$.txt
+
+for setting in '4s4f' '8s8f' '12s12f' '16s16f' '4s2f' '8s4f' '12s6f' '16s8f' ; do
+#for setting in '4s4f' '8s8f' '12s12f' '16s16f' ; do
+#for setting in '4s4f' ; do
+#    ./createConfig.py $hwcfg/1fb_$setting $swt 2 $dir/${setting}x1x2_noChksums -s /tmp/$$.txt --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties
+    ./createConfig.py $hwcfg/1fb_$setting $swt 2 $dir/${setting}x1x2 --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties --hostList ../daq2val/host.lst -s /tmp/fed1022_$$.txt
 done
 
 #./createConfig.py $hwcfg/3fb_8s8f $swt 2 $dir/3x8s8f_noChksums -s /tmp/$$.txt --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties
 
-rm -f /tmp/$$.txt
+rm -f /tmp/$$.txt /tmp/fed1022_$$.txt
diff --git a/evb/test/scripts/createDaq3valConfigs.sh b/evb/test/scripts/createDaq3valConfigs.sh
new file mode 100755
index 000000000..a512e5b24
--- /dev/null
+++ b/evb/test/scripts/createDaq3valConfigs.sh
@@ -0,0 +1,28 @@
+#!/bin/sh
+
+#swt=/DAQ3_Official/StandAlone/StandAlone_40g_infini_dropAtBU
+swt=/Test/Remi/StandAlone/StandAlone_40g_infini_dropAtBU
+hwcfg=/daq3val/eq_190213
+dir=../daq3val/20190301
+mkdir -p $dir
+
+(
+cat <<'EOF'
+RUEVM_CHECK_CRC 0
+BU_CHECK_CRC 0
+EVM_CREATE_FED1022 false
+EOF
+) > /tmp/$$.txt
+
+(
+cat <<EOF
+EVM_CREATE_FED1022 false
+EOF
+) > /tmp/fed1022_$$.txt
+
+for nbFEDs in '10' '12' '15' ; do
+#for nbFEDs in '8' ; do
+    fbSet=$hwcfg/evb/fb_1x${nbFEDs}
+    ./createConfig.py $fbSet $swt 2 $dir/${nbFEDs}x1x2 -s /tmp/fed1022_$$.txt --dpSet ${fbSet}/dp_1x2 --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties
+    #./createConfig.py $fbSet $swt 2 $dir/${nbFEDs}x1x2_noChksums -s /tmp/$$.txt --dpSet ${fbSet}/dp_1x2 --daqval -p $HOME/configurator/CONFIGURATOR_DAQ2VAL.properties
+done
diff --git a/evb/test/scripts/optim/WorkLoopData.py b/evb/test/scripts/optim/WorkLoopData.py
index 93ee45afb..e683afb0c 100644
--- a/evb/test/scripts/optim/WorkLoopData.py
+++ b/evb/test/scripts/optim/WorkLoopData.py
@@ -68,16 +68,15 @@ def canonicalizeWorkLoopNames(workLoopNames):
             'tcpla-psp/(\S+:)\d+/polling',                # found on RU; remove host name but keep the port number
 
             # 60-70% CPU:
-            'evb::RU(_\d+)/parseSocketBuffers_(\d+)/waiting',  # found on RU
-            'evb::RU(_\d+)/Responder_\d+/waiting',           # found on RU
-            'evb::RU(_\d+)/parseSocketBuffers_\d+/waiting',  # found on RU
+            'evb::(?:EVM|RU)(_\d+)/parseSocketBuffers_(\d+)/waiting',  # found on RU
+            'evb::(?:EVM|RU)(_\d+)/Responder_\d+/waiting',           # found on RU
 
             'evb::BU(_\d+)/Builder_\d+/waiting',             # found on BU
 
             # < 10% CPU usage
             'fifo/PeerTransport/waiting',                    # found on BU and RU
-            'evb::RU(_\d+)/buPoster/waiting',                # found on RU
-            'evb::RU(_\d+)/Pipe(_\S+):\d+/waiting',          # found on RU; remove host name but keep port number
+            'evb::(?:EVM|RU)(_\d+)/buPoster/waiting',                # found on RU
+            'evb::(?:EVM|RU)(_\d+)/Pipe(_\S+):\d+/waiting',          # found on RU; remove host name but keep port number
 
             'evb::BU(_\d+)/requestFragments/waiting',        # found on BU
             'evb::BU(_\d+)/lumiAccounting/waiting',          # found on BU
@@ -87,15 +86,20 @@ def canonicalizeWorkLoopNames(workLoopNames):
             # this thread appears when generating on the RU
             # and should be seen as a replacement
             # for the parseSocketBuffers threads
-            'evb::RU(_\d+)/generating_(\d+)/waiting',
+            'evb::(?:EVM|RU)(_\d+)/generating_(\d+)/waiting',
 
             #idling threads for pt::ibv
             'pt::ibv::acceptor(-\d+)/waiting',
             'pt::ibv::eventworkloop/polling',
 
+            #pt::blit
+            'tcpla-psp-receiver-dispatcher(.*)/\d+/waiting',
+            'tcpla-ia-acceptor-dispatcher(.*)/waiting',
+            'tcpla-ia-connector-dispatcher(.*)/waiting',
+            'tcpla-ia-sender-dispatcher(.*)/waiting',
+            'tcpla-ia-workloop(.*)/polling',
+
             # EVM threads
-            'evb::EVM(_\d+)/Responder_(\d+)/waiting',
-            'evb::EVM(_\d+)/generating_(\d+)/waiting',
             'evb::EVM(_\d+)/buPoster/waiting',
             'evb::EVM(_\d+)/processRequests/waiting',
 
diff --git a/evb/test/scripts/optim/printSolutions.py b/evb/test/scripts/optim/printSolutions.py
index ae989d476..e37e0c183 100755
--- a/evb/test/scripts/optim/printSolutions.py
+++ b/evb/test/scripts/optim/printSolutions.py
@@ -8,11 +8,18 @@ def printSolutions(fname):
 
     import pandas as pd
 
+    # NUMA nodes to location for d3vrubu-c2e34-18-01
+    numaNodes = {}
+    for node in (0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62):
+        numaNodes[node] = 'IB_'+str(int(node/2))
+    for node in (1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63):
+        numaNodes[node] = 'ETH_'+str(int((node-1)/2))
+
     data = pd.read_csv(fname, parse_dates = ['book_time'])
 
     # top n points
     # nlargest need pandas >= 0.17.0
-    nlargest = 20
+    nlargest = 10
     # tmp = data.nlargest(nlargest, 'rate').reset_index()
     tmp = data.sort_values('rate', ascending = False).reset_index()
 
@@ -42,18 +49,19 @@ def printSolutions(fname):
 
     print( "top %d distinct solutions" % nlargest )
 
-    print( "%-50s:" % "solution rank", " ".join(["%5d" % (index + 1) for index in range(nlargest) ]) )
+    print( "%-50s:" % "solution rank", "   ".join(["%6d" % (index + 1) for index in range(nlargest) ]) )
 
-    print( "%-50s:" % "avg. rate [kHz]", " ".join([ "%5.1f" % np.mean(performances[key]) for key in sorted_keys[:nlargest] ]) )
-    print( "%-50s:" % "min. rate [kHz]", " ".join([ "%5.1f" % np.min(performances[key]) for key in sorted_keys[:nlargest] ]) )
-    print( "%-50s:" % "max. rate [kHz]", " ".join([ "%5.1f" % np.max(performances[key]) for key in sorted_keys[:nlargest] ]) )
-    print( "%-50s:" % "number of measurements", " ".join([ "%5d" % len(performances[key]) for key in sorted_keys[:nlargest] ]) )
+    print( "%-50s:" % "avg. rate [kHz]", "   ".join([ "%6.1f" % np.mean(performances[key]) for key in sorted_keys[:nlargest] ]) )
+    print( "%-50s:" % "min. rate [kHz]", "   ".join([ "%6.1f" % np.min(performances[key]) for key in sorted_keys[:nlargest] ]) )
+    print( "%-50s:" % "max. rate [kHz]", "   ".join([ "%6.1f" % np.max(performances[key]) for key in sorted_keys[:nlargest] ]) )
+    print( "%-50s:" % "number of measurements", "   ".join([ "%6d" % len(performances[key]) for key in sorted_keys[:nlargest] ]) )
 
     print()
     print( "%-50s core assignment" % "" )
 
     for param_index,param in enumerate(parameters):
-        print( "%-50s:" % param, " ".join(["%5d" % key[param_index] for key in sorted_keys[:nlargest] ]) )
+        #print( "%-50s:" % param, " ".join(["%-8s" % numaNodes[key[param_index]] for key in sorted_keys[:nlargest] ]) )
+        print( "%-50s:" % param, " ".join(["%-8s" % key[param_index] for key in sorted_keys[:nlargest] ]) )
 
     print()
 
diff --git a/evb/test/scripts/runBenchmarks.py b/evb/test/scripts/runBenchmarks.py
index b124bd2f8..b3d7dd06f 100755
--- a/evb/test/scripts/runBenchmarks.py
+++ b/evb/test/scripts/runBenchmarks.py
@@ -124,7 +124,7 @@ class RunBenchmarks(TestRunner):
             ]
         buConfig = [
             ('lumiSectionTimeout','unsignedInt','0'),
-            ('maxEvtsUnderConstruction','unsignedInt','320'),
+            ('maxEvtsUnderConstruction','unsignedInt','640'),
             ('eventsPerRequest','unsignedInt','8'),
             ('superFragmentFIFOCapacity','unsignedInt','12800'),
             ('numberOfBuilders','unsignedInt','8')
diff --git a/evb/test/scripts/runScans.py b/evb/test/scripts/runScans.py
index 1c1381024..43598d599 100755
--- a/evb/test/scripts/runScans.py
+++ b/evb/test/scripts/runScans.py
@@ -31,6 +31,7 @@ class RunScans(TestRunner):
         parser.add_argument("--dropAtRU",action='store_true',help="drop data at the RU")
         parser.add_argument("--dropAtSocket",action='store_true',help="drop data at pt::blit socket callback")
         parser.add_argument("--ferolMode",action='store_true',help="generate data on FEROL instead of FRL")
+        parser.add_argument("--ferolsOnly",action='store_true',help="only start the FEROLs, no EvB applications")
         parser.add_argument("--scaleFedSizesFromFile",help="scale the FED fragment sizes relative to the sizes in the given file")
         parser.add_argument("--calculateFedSizesFromFile",help="calculate the FED fragment sizes using the parameters in the given file")
 
@@ -112,7 +113,8 @@ class RunScans(TestRunner):
             #----------
 
             config = ConfigFromFile(symbolMap,configFile,self.args['fixPorts'],self.args['numa'],
-                                    self.args['generateAtRU'],self.args['dropAtRU'],self.args['dropAtSocket'],ferolMode)
+                                    self.args['generateAtRU'],self.args['dropAtRU'],self.args['dropAtSocket'],
+                                    ferolMode,self.args['ferolsOnly'])
 
             entry['config'] = config
 
diff --git a/evb/test/setenv.sh b/evb/test/setenv.sh
index 61766b6f2..70152aa99 100644
--- a/evb/test/setenv.sh
+++ b/evb/test/setenv.sh
@@ -11,7 +11,7 @@ export XDAQ_EVB=${HOME}/daq/worksuite/${XDAQ_PLATFORM}
 export LD_LIBRARY_PATH=${XDAQ_EVB}/lib:${LD_LIBRARY_PATH}
 
 # EvB tester suite
-export EVB_TESTER_HOME=${HOME}/daq/worksuite/evb/test
+export EVB_TESTER_HOME=${HOME}/daq/baseline14/daq/evb/test
 export EVB_SYMBOL_MAP=standaloneSymbolMap.txt
 export PATH=${PATH}:${EVB_TESTER_HOME}/scripts
 export PYTHONPATH=${EVB_TESTER_HOME}/scripts:${PYTHONPATH}
diff --git a/gevb2g/src/common/EVM.cc b/gevb2g/src/common/EVM.cc
index 27839abd0..048572f65 100755
--- a/gevb2g/src/common/EVM.cc
+++ b/gevb2g/src/common/EVM.cc
@@ -204,7 +204,7 @@ void gevb2g::EVM::Available (toolbox::mem::Reference * ref)
 		{
 			resourceQueue_->push_back(descriptor);
 		}
-		catch (xdaq::exception::Exception e)
+		catch (const xdaq::exception::Exception & e)
 		{
 			LOG4CPLUS_ERROR(this->getApplicationLogger(), e.what());
 			LOG4CPLUS_FATAL(this->getApplicationLogger(), "EVM resource queue full. Size " << resourceQueueSize_ << ", resources to push " << resources << ", pushed " << i);
diff --git a/gevb2g/src/common/RU.cc b/gevb2g/src/common/RU.cc
index dc0ddb1fb..92b9fd71e 100755
--- a/gevb2g/src/common/RU.cc
+++ b/gevb2g/src/common/RU.cc
@@ -260,7 +260,7 @@ void gevb2g::RU::dataFragmentAvailable (toolbox::mem::Reference * ref)
 		mutex_->give();
 
 	}
-	catch (toolbox::exception::Exception te)
+	catch (const toolbox::exception::Exception & te)
 	{
 		mutex_->give();
 		ref->release();
diff --git a/hal/busAdapter/dummy/include/hal/PCIDummyBusAdapter.hh b/hal/busAdapter/dummy/include/hal/PCIDummyBusAdapter.hh
index 8b0baf729..00943c9c9 100755
--- a/hal/busAdapter/dummy/include/hal/PCIDummyBusAdapter.hh
+++ b/hal/busAdapter/dummy/include/hal/PCIDummyBusAdapter.hh
@@ -9,186 +9,202 @@
 
 namespace HAL {
 
-/**
-*
-*
-*     @short A dummy PCIBusAdapter in order to work without hardware.
-*            
-*            This  BusAdapter  merely  serves  to  let  you  test  you 
-*            software  without actually  having hardware  connected to 
-*            your  computer.  All actions  which  in  real life  would 
-*            result in  read or write  operations will be  reported on 
-*            the standard output.
-*
-*       @see BusAdapterInterface
-*    @author Christoph Schwick
-* $Revision: 1.1 $
-*     $Date: 2007/03/06 09:54:25 $
-*
-*
-**/
-
-class PCIDummyBusAdapter : public PCIBusAdapterInterface {
-
-public:
-
-  /**
-   * This enumerator is used in the constructor. It switches 
-   * the versbose behaviour of the BusAdapter on or off. Note
-   * that the enumerator is a member of the class PCIDummyBusAdapter.
-   * So it must be used. This means that a Scope identifier is
-   * needed when calling the constructor of the class. A valid 
-   * example would be:
-   * <pre>
-   * PCIDummyBusAdapter myBa( PCIDummyBusAdapter::VERBOSE_ON,
-   *                          PCIDummyBusAdapter::MEMORY_MAP_OFF );
-   * </pre>
-   * The enumerators have been put into the class in order not
-   * to contaminate the global namesapce with objects merely used 
-   * for debugging purposes.
-   */
-  enum VerboseMode { VERBOSE_OFF, VERBOSE_ON };
-
-  /**
-   * This enumerator is used in the constructor. It switches 
-   * the memory-mapping behaviour of the BusAdapter on or off. 
-   * If switched on every address-space  corresponding to a 
-   * specific BAR or to the configuration space is mapped into
-   * the local memory of the host. It is then used to perform
-   * read and write operations into the mapped memory. This 
-   * allows to play in a more realistic way with the device.
-   * See VerboseMode comments for a note on how to use this 
-   * enumerator.
-   */
-  enum MemoryMode  { MEMORY_MAP_OFF, MEMORY_MAP_ON };
-
-  /**
-   * The constructor takes two arguments:
-   * @param verbose allows you to monitor all data transfers: If 
-   *        set to true every action is reported on the standard
-   *        output.
-   * @param memoryMode allows you to create memory regions which
-   *        fake the hardware device. For every openDevice call
-   *        a memory region is created into which or from which 
-   *        data is transfered. With this you can write and read
-   *        back data from you dummy-device. The size of the 
-   *        mapped region depend on the PCIAddressTable given
-   *        to the openDevice call. 
-   */
-  PCIDummyBusAdapter( enum VerboseMode verbose    = VERBOSE_ON,
-                      enum MemoryMode  memoryMode = MEMORY_MAP_ON,
-		      std::ostream& os = std::cout );
-
-  /**
-   * There is nothing to do in the desctructor.
-   */
-  virtual ~PCIDummyBusAdapter();
-
-
   /**
-   * If the PCIDummyBusAdapter was created with the memoryMode
-   * option set to true, the call scans the PCIAddressTable in
-   * order to find out how much memory has to be reserved for 
-   * the dummy Hardware device. The pointers to this memory is 
-   * then contained in the deviceIdentifier. For each BAR used
-   * in the pciAddressTable a separate memory region is created.
-   * Similarly if there are items of the configuration space in
-   * the pciAddressTable, a separate memory region is created. 
-   */
-  void findDeviceByVendor( uint32_t vendorID, 
-			   uint32_t deviceID,
-			   uint32_t index,
-			   const PCIAddressTable& pciAddressTable,
-			   PCIDeviceIdentifier** deviceIdentifierPtr,
-			   std::vector<uint32_t>& barRegisters,
-			   bool swapFlag = false ) 
-    throw();
-
-  void findDeviceByVendor( uint32_t vendorID, 
-			   uint32_t deviceID,
-			   uint32_t index,
-			   const PCIAddressTable& pciAddressTable,
-			   PCIDeviceIdentifier** deviceIdentifierPtr,
-			   std::vector<uint64_t>& barRegisters,
-			   bool swapFlag = false ) 
-    throw();
-
-  void findDeviceByBus( uint32_t busID, 
-			uint32_t slotID,
-			uint32_t functionID,
-			const PCIAddressTable& pciAddressTable,
-			PCIDeviceIdentifier** deviceIdentifierPtr,
-			std::vector<uint32_t>& barRegisters,
-			bool swapFlag = false )
-    throw();
-
-  void findDeviceByBus( uint32_t busID, 
-			uint32_t slotID,
-			uint32_t functionID,
-			const PCIAddressTable& pciAddressTable,
-			PCIDeviceIdentifier** deviceIdentifierPtr,
-			std::vector<uint64_t>& barRegisters,
-			bool swapFlag = false )
-    throw();
-
-
-  /**
-   * Here the memory regions which might have beeen reserved
-   * in the openDevice call, are deleted.
-   */
-  void closeDevice( PCIDeviceIdentifier* deviceIdentifier )
-    throw();
+   *
+   *
+   *     @short A dummy PCIBusAdapter in order to work without hardware.
+   *            
+   *            This  BusAdapter  merely  serves  to  let  you  test  you 
+   *            software  without actually  having hardware  connected to 
+   *            your  computer.  All actions  which  in  real life  would 
+   *            result in  read or write  operations will be  reported on 
+   *            the standard output.
+   *
+   *       @see BusAdapterInterface
+   *    @author Christoph Schwick
+   * $Revision: 1.1 $
+   *     $Date: 2007/03/06 09:54:25 $
+   *
+   *
+   **/
+
+  class PCIDummyBusAdapter : public PCIBusAdapterInterface {
+
+  public:
+
+    /**
+     * This enumerator is used in the constructor. It switches 
+     * the versbose behaviour of the BusAdapter on or off. Note
+     * that the enumerator is a member of the class PCIDummyBusAdapter.
+     * So it must be used. This means that a Scope identifier is
+     * needed when calling the constructor of the class. A valid 
+     * example would be:
+     * <pre>
+     * PCIDummyBusAdapter myBa( PCIDummyBusAdapter::VERBOSE_ON,
+     *                          PCIDummyBusAdapter::MEMORY_MAP_OFF );
+     * </pre>
+     * The enumerators have been put into the class in order not
+     * to contaminate the global namesapce with objects merely used 
+     * for debugging purposes.
+     */
+    enum VerboseMode { VERBOSE_OFF, VERBOSE_ON };
+
+    /**
+     * This enumerator is used in the constructor. It switches 
+     * the memory-mapping behaviour of the BusAdapter on or off. 
+     * If switched on every address-space  corresponding to a 
+     * specific BAR or to the configuration space is mapped into
+     * the local memory of the host. It is then used to perform
+     * read and write operations into the mapped memory. This 
+     * allows to play in a more realistic way with the device.
+     * See VerboseMode comments for a note on how to use this 
+     * enumerator.
+     */
+    enum MemoryMode  { MEMORY_MAP_OFF, MEMORY_MAP_ON };
+
+    /**
+     * The constructor takes two arguments:
+     * @param verbose allows you to monitor all data transfers: If 
+     *        set to true every action is reported on the standard
+     *        output.
+     * @param memoryMode allows you to create memory regions which
+     *        fake the hardware device. For every openDevice call
+     *        a memory region is created into which or from which 
+     *        data is transfered. With this you can write and read
+     *        back data from you dummy-device. The size of the 
+     *        mapped region depend on the PCIAddressTable given
+     *        to the openDevice call. 
+     */
+    PCIDummyBusAdapter( enum VerboseMode verbose    = VERBOSE_ON,
+                        enum MemoryMode  memoryMode = MEMORY_MAP_ON,
+                        std::ostream& os = std::cout );
+
+    /**
+     * There is nothing to do in the desctructor.
+     */
+    virtual ~PCIDummyBusAdapter();
+
+
+    /**
+     * If the PCIDummyBusAdapter was created with the memoryMode
+     * option set to true, the call scans the PCIAddressTable in
+     * order to find out how much memory has to be reserved for 
+     * the dummy Hardware device. The pointers to this memory is 
+     * then contained in the deviceIdentifier. For each BAR used
+     * in the pciAddressTable a separate memory region is created.
+     * Similarly if there are items of the configuration space in
+     * the pciAddressTable, a separate memory region is created. 
+     */
+    void findDeviceByVendor( uint32_t vendorID, 
+                             uint32_t deviceID,
+                             uint32_t index,
+                             const PCIAddressTable& pciAddressTable,
+                             PCIDeviceIdentifier** deviceIdentifierPtr,
+                             std::vector<uint32_t>& barRegisters,
+                             bool swapFlag = false );
+
+    void findDeviceByVendor( uint32_t vendorID, 
+                             uint32_t deviceID,
+                             uint32_t index,
+                             const PCIAddressTable& pciAddressTable,
+                             PCIDeviceIdentifier** deviceIdentifierPtr,
+                             std::vector<uint64_t>& barRegisters,
+                             bool swapFlag = false );
+
+    void findDeviceByBus( uint32_t busID, 
+                          uint32_t slotID,
+                          uint32_t functionID,
+                          const PCIAddressTable& pciAddressTable,
+                          PCIDeviceIdentifier** deviceIdentifierPtr,
+                          std::vector<uint32_t>& barRegisters,
+                          bool swapFlag = false );
+  
+    void findDeviceByBus( uint32_t busID, 
+                          uint32_t slotID,
+                          uint32_t functionID,
+                          const PCIAddressTable& pciAddressTable,
+                          PCIDeviceIdentifier** deviceIdentifierPtr,
+                          std::vector<uint64_t>& barRegisters,
+                          bool swapFlag = false );
+
+    /**
+     * Here the memory regions which might have beeen reserved
+     * in the openDevice call, are deleted.
+     */
+    void closeDevice( PCIDeviceIdentifier* deviceIdentifier );
   
-  void write( PCIDeviceIdentifier& device,
-              uint32_t address,
-              uint32_t data)
-    throw();
+    void write( PCIDeviceIdentifier& device,
+                uint32_t address,
+                uint32_t data);
   
-  void read( PCIDeviceIdentifier& DeviceIdentifier,
-             uint32_t address,
-             uint32_t* result)
-    throw();
-
-  void configWrite( PCIDeviceIdentifier& device, 
-                    uint32_t address, 
-                    uint32_t data ) 
-    throw( ) ;
-
-  void configRead( PCIDeviceIdentifier& device,
-                   uint32_t address, 
-                   uint32_t* result )
-    throw( );
-
-  void writeBlock( PCIDeviceIdentifier& deviceIdentifierPtr,
-                   uint32_t startAddress,
-                   uint32_t length,      // in bytes
-                   char *buffer,
-                   HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT )
-    throw();
+    void read( PCIDeviceIdentifier& DeviceIdentifier,
+               uint32_t address,
+               uint32_t* result);
+  
+    void configWrite( PCIDeviceIdentifier& device, 
+                      uint32_t address, 
+                      uint32_t data );
+
+    void configRead( PCIDeviceIdentifier& device,
+                     uint32_t address, 
+                     uint32_t* result );
+
+    void writeBlock( PCIDeviceIdentifier& deviceIdentifierPtr,
+                     uint32_t startAddress,
+                     uint32_t length,      // in bytes
+                     char *buffer,
+                     HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT );
+  
+    void readBlock( PCIDeviceIdentifier& deviceIdentifierPtr,
+                    uint32_t startAddress,
+                    uint32_t length,      // in bytes
+                    char *buffer,
+                    HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT );
+
+    void write64( PCIDeviceIdentifier& device,
+                  uint64_t address,
+                  uint64_t data);
+  
+    void read64( PCIDeviceIdentifier& device,
+                 uint64_t address,
+                 uint64_t* result);
+
+    void configWrite64( PCIDeviceIdentifier& device, 
+                        uint64_t address, 
+                        uint64_t data );
+
+    void configRead64( PCIDeviceIdentifier& device,
+                       uint64_t address, 
+                       uint64_t* result );
+
+    void writeBlock64(  PCIDeviceIdentifier& device,
+                        uint64_t startAddress,
+                        uint64_t length,
+                        char *buffer,
+                        HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT ) ;
+
+    void readBlock64(  PCIDeviceIdentifier& device,
+                       uint64_t startAddress,
+                       uint64_t length,
+                       char *buffer,
+                       HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT );
+
   
-  void readBlock( PCIDeviceIdentifier& deviceIdentifierPtr,
-                  uint32_t startAddress,
-                  uint32_t length,      // in bytes
-                  char *buffer,
-                  HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT )
-    throw();
-
-private:
-  // helpers:
-  void findDevice( const PCIAddressTable& pciAddressTable,
-		   PCIDeviceIdentifier** deviceIdentifierPtr,
-		   std::vector<uint32_t>& barRegisters,
-		   bool swapFlag )
-    throw();
-
-  uint32_t getBARIntervall( const std::vector<uint32_t>& maxAddresses);
-
-private:
-  uint32_t deviceNumberCounter;
-  enum VerboseMode verbose;
-  enum MemoryMode  memoryMode;
-  std::ostream& os_;
-};
+  private:
+    // helpers:
+    void findDevice( const PCIAddressTable& pciAddressTable,
+                     PCIDeviceIdentifier** deviceIdentifierPtr,
+                     std::vector<uint32_t>& barRegisters,
+                     bool swapFlag );
+
+    uint32_t getBARIntervall( const std::vector<uint32_t>& maxAddresses);
+
+  private:
+    uint32_t deviceNumberCounter;
+    enum VerboseMode verbose;
+    enum MemoryMode  memoryMode;
+    std::ostream& os_;
+  };
 
 } /* namespace HAL */
 
diff --git a/hal/busAdapter/dummy/include/hal/VMEDummyBusAdapter.hh b/hal/busAdapter/dummy/include/hal/VMEDummyBusAdapter.hh
index 995ec05cd..a7bba59d4 100755
--- a/hal/busAdapter/dummy/include/hal/VMEDummyBusAdapter.hh
+++ b/hal/busAdapter/dummy/include/hal/VMEDummyBusAdapter.hh
@@ -94,35 +94,32 @@ public:
                      uint32_t vmeBaseaddress,
                      DeviceIdentifier** deviceIdentifierPtr,
                      uint32_t* baseAddressPtr,
-                     bool doSwapping = false )
-        throw();
+                     bool doSwapping = false );
   
     void openDevice( const VMEAddressTable& vmeAddressTable,
                      std::vector<uint32_t>& vmeBaseaddresses,
                      DeviceIdentifier** deviceIdentifierPtr,
                      std::vector<uint32_t>* baseAddressPtr,
-                     bool doSwapping = 0) 
-        throw();
+                     bool doSwapping = 0);
+  
     /**
      * Here the memory regions which might have beeen reserved
      * in the openDevice call, are deleted.
      */
-    void closeDevice( DeviceIdentifier* deviceIdentifier )
-        throw();
+    void closeDevice( DeviceIdentifier* deviceIdentifier );
+
   
     void write( DeviceIdentifier* deviceIdentifier,
                 uint32_t address,
                 uint32_t addressModifier,
                 uint32_t dataWidth,
-                uint32_t data)
-        throw();
+                uint32_t data);
   
     void read( DeviceIdentifier* DeviceIdentifier,
                uint32_t address,
                uint32_t addressModifier,
                uint32_t dataWidth,
-               uint32_t* result)
-        throw();
+               uint32_t* result);
 
     void writeBlock( DeviceIdentifier* deviceIdentifierPtr,
                      uint32_t startAddress,
@@ -130,8 +127,7 @@ public:
                      uint32_t addressModifier,
                      uint32_t dataWidth,
                      char *buffer,
-                     HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT )
-        throw();
+                     HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT );
   
     void readBlock( DeviceIdentifier* deviceIdentifierPtr,
                     uint32_t startAddress,
@@ -139,11 +135,9 @@ public:
                     uint32_t addressModifier,
                     uint32_t dataWidth,
                     char *buffer,
-                    HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT )
-        throw();
+                    HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT );
 
-    void resetBus( )
-        throw();
+    void resetBus( );
   
 private:
     uint32_t doSwap( uint32_t data, uint32_t dataWidth ) const;
diff --git a/hal/busAdapter/dummy/src/common/PCIDummyBusAdapter.cc b/hal/busAdapter/dummy/src/common/PCIDummyBusAdapter.cc
index 31f0f55cd..655d28744 100755
--- a/hal/busAdapter/dummy/src/common/PCIDummyBusAdapter.cc
+++ b/hal/busAdapter/dummy/src/common/PCIDummyBusAdapter.cc
@@ -26,7 +26,7 @@ void HAL::PCIDummyBusAdapter::findDeviceByVendor( uint32_t vendorID,
 						  PCIDeviceIdentifier** deviceIdentifierPtr,
 						  std::vector<uint32_t>& barRegisters,
 						  bool swapFlag ) 
-  throw() {
+{
   
   os_ << "PCIDummyBusAdapter : find device by Vendor called :"
       << "\n   memory-mapping-mode : " << (int)this->memoryMode 
@@ -48,7 +48,7 @@ void HAL::PCIDummyBusAdapter::findDeviceByVendor( uint32_t vendorID,
 						  PCIDeviceIdentifier** deviceIdentifierPtr,
 						  std::vector<uint64_t>& barRegisters,
 						  bool swapFlag ) 
-  throw() {
+{
   
   os_ << "PCIDummyBusAdapter : find device by Vendor called :"
       << "\n   memory-mapping-mode : " << (int)this->memoryMode 
@@ -76,7 +76,7 @@ HAL::PCIDummyBusAdapter::findDeviceByBus( uint32_t busID,
 					  PCIDeviceIdentifier** deviceIdentifierPtr,
 					  std::vector<uint32_t>& barRegisters,
 					  bool swapFlag ) 
-  throw() {
+{
   
 
   os_ << "PCIDummyBusAdapter : find device by Bus called :"
@@ -100,7 +100,7 @@ HAL::PCIDummyBusAdapter::findDeviceByBus( uint32_t busID,
 					  PCIDeviceIdentifier** deviceIdentifierPtr,
 					  std::vector<uint64_t>& barRegisters,
 					  bool swapFlag ) 
-  throw() {
+{
   
 
   os_ << "PCIDummyBusAdapter : find device by Bus called :"
@@ -126,7 +126,7 @@ HAL::PCIDummyBusAdapter::findDevice( const PCIAddressTable& pciAddressTable,
 				     PCIDeviceIdentifier** deviceIdentifierPtr,
 				     std::vector<uint32_t>& barRegisters,
 				     bool swapFlag ) 
-  throw() {
+{
   
   int ic;
   uint32_t uic;
@@ -203,7 +203,7 @@ HAL::PCIDummyBusAdapter::findDevice( const PCIAddressTable& pciAddressTable,
 
 void
 HAL::PCIDummyBusAdapter::closeDevice( PCIDeviceIdentifier* PCIDevice ) 
-  throw() {
+{
     HAL::PCIDummyDeviceIdentifier* theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier*>(PCIDevice);
     os_ << "PCIDummyBusAdapter : closing Device  \n" 
          << "                     " << theDevice->printString() << std::endl;
@@ -214,7 +214,7 @@ void
 HAL::PCIDummyBusAdapter::read( PCIDeviceIdentifier& PCIDevice, 
                           uint32_t address,
                           uint32_t *resultPtr ) 
-  throw() {
+{
   HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(PCIDevice);
 
   *resultPtr = 0;
@@ -232,11 +232,33 @@ HAL::PCIDummyBusAdapter::read( PCIDeviceIdentifier& PCIDevice,
   }
 }
 
+void
+HAL::PCIDummyBusAdapter::read64( PCIDeviceIdentifier& PCIDevice, 
+                                 uint64_t address,
+                                 uint64_t *resultPtr ) 
+{
+  HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(PCIDevice);
+
+  *resultPtr = 0;
+  if ( memoryMode == MEMORY_MAP_ON ) {
+    char *memoryAddress = theDevice.remap( address );
+    memcpy( resultPtr, memoryAddress, 8);
+  }
+  if ( verbose == VERBOSE_ON ) {
+    os_ << std::endl;
+    os_ << "PCIDummyBusAdapter : read from Device number " << theDevice.printString() << std::endl;
+    os_ << "                     address   : " << std::hex << std::setw(16) << std::setfill('0') << address << std::endl;
+    os_ << "                     returning : 0x" << std::hex << std::setw(16) << std::setfill('0') << *resultPtr 
+         << " (dec) " << std::dec << *resultPtr << std::endl;
+    os_ << std::endl;
+  }
+}
+
 void
 HAL::PCIDummyBusAdapter::write( PCIDeviceIdentifier& PCIDevice, 
                            uint32_t address, 
                            uint32_t data) 
-  throw() {
+{
   HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(PCIDevice);
 
   if ( memoryMode == MEMORY_MAP_ON ) {
@@ -254,11 +276,33 @@ HAL::PCIDummyBusAdapter::write( PCIDeviceIdentifier& PCIDevice,
   }
 }
 
+void
+HAL::PCIDummyBusAdapter::write64( PCIDeviceIdentifier& PCIDevice, 
+                                  uint64_t address, 
+                                  uint64_t data) 
+{
+  HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(PCIDevice);
+
+  if ( memoryMode == MEMORY_MAP_ON ) {
+    char *memoryAddress = theDevice.remap( address );
+    memcpy( memoryAddress, &data, 8);
+  }
+
+  if (verbose == VERBOSE_ON) {
+    os_ << std::endl;
+    os_ << "PCIDummyBusAdapter : write to Device number " << theDevice.printString() << std::endl;
+    os_ << "                     address : " << std::hex << std::setw(16) << std::setfill('0') << address << std::endl;
+    os_ << "                   dataValue : 0x" << std::hex << std::setw(16) << std::setfill('0') << data 
+         << " (dec) " << std::dec << data << std::endl;
+    os_ << std::endl;
+  }
+}
+
 
 void HAL::PCIDummyBusAdapter::configWrite( PCIDeviceIdentifier& device, 
 					   uint32_t address, 
 					   uint32_t data ) 
-  throw( ) {
+{
 
   if ( memoryMode == MEMORY_MAP_ON ) {
     HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
@@ -276,11 +320,32 @@ void HAL::PCIDummyBusAdapter::configWrite( PCIDeviceIdentifier& device,
   }
 }
 
+void HAL::PCIDummyBusAdapter::configWrite64( PCIDeviceIdentifier& device, 
+                                             uint64_t address, 
+                                             uint64_t data ) 
+{
+
+  if ( memoryMode == MEMORY_MAP_ON ) {
+    HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
+    char* memoryAddress = address +  theDevice.getConfigSpacePtr();
+    memcpy( memoryAddress, &data, 8);
+  }
+
+  if ( verbose == VERBOSE_ON ) {
+    os_ << std::endl;
+    os_ << "PCIDummyBusAdapter : configuration write to Device number " << device.printString() << std::endl;
+    os_ << "                     address   : " << std::hex << std::setw(16) << std::setfill('0') << address << std::endl;
+    os_ << "                     dataValue : 0x" << std::hex << std::setw(16) << std::setfill('0') << data 
+         << " (dec) " << std::dec << data << std::endl;
+    os_ << std::endl;
+  }
+}
+
 
 void HAL::PCIDummyBusAdapter::configRead( PCIDeviceIdentifier& device,
 					  uint32_t address, 
 					  uint32_t* resultPtr )
-  throw( ) {
+{
 
   *resultPtr = 0;
   if ( memoryMode == MEMORY_MAP_ON ) {
@@ -298,13 +363,34 @@ void HAL::PCIDummyBusAdapter::configRead( PCIDeviceIdentifier& device,
   }
 }
 
+void HAL::PCIDummyBusAdapter::configRead64( PCIDeviceIdentifier& device,
+                                            uint64_t address, 
+                                            uint64_t* resultPtr )
+{
+
+  *resultPtr = 0;
+  if ( memoryMode == MEMORY_MAP_ON ) {
+    HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
+    char* memoryAddress = address + theDevice.getConfigSpacePtr();
+    memcpy( resultPtr, memoryAddress, 8);
+  }
+  if ( verbose == VERBOSE_ON ) {
+    os_ << std::endl;
+    os_ << "PCIDummyBusAdapter : configuration read from Device number " << device.printString() << std::endl;
+    os_ << "                     address   : " << std::hex << std::setw(16) << std::setfill('0') << address << std::endl;
+    os_ << "                     returning : 0x" << std::hex << std::setw(16) << std::setfill('0') << *resultPtr 
+         << " (dec) " << std::dec << *resultPtr << std::endl;
+    os_ << std::endl;
+  }
+}
+
 void
 HAL::PCIDummyBusAdapter::readBlock( PCIDeviceIdentifier &device,
 				    uint32_t startAddress,
 				    uint32_t length,      // in bytes
 				    char *buffer,
 				    HalAddressIncrement addressBehaviour ) 
-  throw() {
+{
   HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
 
   if ( memoryMode == MEMORY_MAP_ON ) {
@@ -333,6 +419,41 @@ HAL::PCIDummyBusAdapter::readBlock( PCIDeviceIdentifier &device,
     os_ << std::endl;
   }
 }
+void
+HAL::PCIDummyBusAdapter::readBlock64( PCIDeviceIdentifier &device,
+                                      uint64_t startAddress,
+                                      uint64_t length,      // in bytes
+                                      char *buffer,
+                                      HalAddressIncrement addressBehaviour ) 
+{
+  HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
+
+  if ( memoryMode == MEMORY_MAP_ON ) {
+    char *memoryAddress = theDevice.remap( startAddress );
+    if ( addressBehaviour == HAL_DO_INCREMENT ) {
+      memcpy( buffer, memoryAddress, length);
+    } else {
+      os_ << "HAL::PCIDummyBusAdapter::readBlock : No Fifo functionality in PCIDummyBusAdapter. Doing nothing!" << std::endl;
+    }
+  }
+
+  if( verbose == VERBOSE_ON ) {
+    os_ << std::endl;
+    os_ << "PCIDummyBusAdapter : readBlock from Device \n                     " << theDevice.printString() << std::endl;
+    os_ << "                     startaddress (hex) : " << std::hex << std::setw(16) << std::setfill('0') << startAddress << std::endl;
+    os_ << "                     length (hex)       : " << std::hex << std::setw(16) << std::setfill('0') << length << std::endl;
+    os_ << "                     addressBehaviour   : ";
+    if ( addressBehaviour == HAL_DO_INCREMENT ) {
+      os_ << "HAL_DO_INCREMENT" << std::endl;
+    } else if ( addressBehaviour == HAL_NO_INCREMENT ) {
+      os_ << "HAL_NO_INCREMENT" << std::endl;
+    } else { // should never happen
+      os_ << "XXXXXXXXXXXXXXXX" << std::endl;
+    }
+    os_ << "   pointer to readbuffer (hex) : " << std::hex << std::setw(16) << std::setfill('0') << buffer << std::endl;
+    os_ << std::endl;
+  }
+}
   
 void
 HAL::PCIDummyBusAdapter::writeBlock( PCIDeviceIdentifier& device,
@@ -340,7 +461,7 @@ HAL::PCIDummyBusAdapter::writeBlock( PCIDeviceIdentifier& device,
 				     uint32_t length,      // in bytes
 				     char *buffer,
 				     HalAddressIncrement addressBehaviour ) 
-  throw() {
+{
   
   HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
 
@@ -371,6 +492,43 @@ HAL::PCIDummyBusAdapter::writeBlock( PCIDeviceIdentifier& device,
   }
 }
  
+void
+HAL::PCIDummyBusAdapter::writeBlock64( PCIDeviceIdentifier& device,
+                                       uint64_t startAddress,
+                                       uint64_t length,      // in bytes
+                                       char *buffer,
+                                       HalAddressIncrement addressBehaviour ) 
+{
+  
+  HAL::PCIDummyDeviceIdentifier& theDevice = dynamic_cast<HAL::PCIDummyDeviceIdentifier&>(device);
+
+  if ( memoryMode == MEMORY_MAP_ON ) {
+    char *memoryAddress = theDevice.remap( startAddress );
+    if ( addressBehaviour == HAL_DO_INCREMENT ) {
+      memcpy( memoryAddress, buffer, length);
+     } else {
+       os_ << "HAL::PCIDummyBusAdapter::writeBlock : No Fifo functionality in PCIDummyBusAdapter. Doing nothing!" << std::endl;
+     }
+  }
+
+  if ( verbose == VERBOSE_ON ) {
+    os_ << std::endl;
+    os_ << "PCIDummyBusAdapter : writeBlock to Device \n                     " << theDevice.printString() << std::endl;
+    os_ << "                     startaddress (hex) : " << std::hex << std::setw(16) << std::setfill('0') << startAddress << std::endl;
+    os_ << "                     length (hex)       : " << std::hex << std::setw(16) << std::setfill('0') << length << std::endl;
+    os_ << "                     addressBehaviour   : ";
+    if ( addressBehaviour == HAL_DO_INCREMENT ) {
+      os_ << "HAL_DO_INCREMENT" << std::endl;
+    } else if ( addressBehaviour == HAL_NO_INCREMENT ) {
+      os_ << "HAL_NO_INCREMENT" << std::endl;
+    } else { // should never happen
+      os_ << "XXXXXXXXXXXXXXXX" << std::endl;
+    }
+    os_ << "   pointer to sourcebuffer (hex) : " << std::hex << std::setw(16) << std::setfill('0') << buffer << std::endl;
+    os_ << std::endl;
+  }
+}
+ 
 uint32_t HAL::PCIDummyBusAdapter::getBARIntervall( const std::vector<uint32_t>& maxAddresses ) {
   uint32_t intervall = 1;
   std::vector<uint32_t>::const_iterator it;
diff --git a/hal/busAdapter/dummy/src/common/VMEDummyBusAdapter.cc b/hal/busAdapter/dummy/src/common/VMEDummyBusAdapter.cc
index 6fa7f5814..60797573a 100755
--- a/hal/busAdapter/dummy/src/common/VMEDummyBusAdapter.cc
+++ b/hal/busAdapter/dummy/src/common/VMEDummyBusAdapter.cc
@@ -29,8 +29,8 @@ HAL::VMEDummyBusAdapter::openDevice(const VMEAddressTable& vmeAddressTable,
                                uint32_t vmeBaseaddress,
                                DeviceIdentifier** deviceIdentifierPtr,
                                uint32_t* baseAddressPtr,
-                               bool doSwapping ) 
-    throw() {
+                               bool doSwapping )
+{
     std::vector<char *> memoryRegions(NUMBER_OF_VME64XFUNCTIONS);
     for ( int i=0; i<NUMBER_OF_VME64XFUNCTIONS; i++ ) memoryRegions.push_back( (char*) 0 );
 
@@ -94,7 +94,7 @@ HAL::VMEDummyBusAdapter::openDevice( const VMEAddressTable& vmeAddressTable,
 				     DeviceIdentifier** deviceIdentifierPtr,
 				     std::vector<uint32_t>* baseAddressPtr,
 				     bool doSwapping ) 
-    throw() {
+{
     std::vector<char *> memoryRegions(NUMBER_OF_VME64XFUNCTIONS);
     for ( int i=0; i<NUMBER_OF_VME64XFUNCTIONS; i++ ) memoryRegions.push_back( (char*) 0 );
 
@@ -159,7 +159,7 @@ HAL::VMEDummyBusAdapter::openDevice( const VMEAddressTable& vmeAddressTable,
 
 void
 HAL::VMEDummyBusAdapter::closeDevice( DeviceIdentifier* vmeDevice ) 
-    throw() {
+{
     os_  << "VMEDummyBusAdapter : closing Device  \n" 
          << "                     " << vmeDevice->printString() << std::endl;
     delete( vmeDevice );
@@ -171,7 +171,7 @@ HAL::VMEDummyBusAdapter::read( DeviceIdentifier* vmeDevice,
                           uint32_t addressModifier,
                           uint32_t dataWidth,
                           uint32_t *resultPtr ) 
-    throw() {
+{
 
     *resultPtr = 0;
     if ( memoryMode == MEMORY_MAP_ON ) {
@@ -206,7 +206,7 @@ HAL::VMEDummyBusAdapter::write( DeviceIdentifier* vmeDevice,
                            uint32_t addressModifier,
                            uint32_t dataWidth,
                            uint32_t data) 
-    throw() {
+{
 
     bool doSwapping = dynamic_cast<HAL::VMEDummyDeviceIdentifier*>(vmeDevice)->doSwapping();
 
@@ -252,7 +252,7 @@ uint32_t HAL::VMEDummyBusAdapter::doSwap( uint32_t data, uint32_t dataWidth ) co
 
 void
 HAL::VMEDummyBusAdapter::resetBus( ) 
-    throw() {
+{
     if ( verbose == VERBOSE_ON ) {
         os_  << std::endl;
         os_  << "VMEDummyBusAdapter : resetting bus" << std::endl;
@@ -268,7 +268,7 @@ HAL::VMEDummyBusAdapter::readBlock( DeviceIdentifier *vmeDevice,
                                uint32_t dataWidth,
                                char *buffer,
                                HalAddressIncrement addressBehaviour ) 
-    throw() {
+{
 
     if ( memoryMode == MEMORY_MAP_ON ) {
         char *memoryAddress = dynamic_cast<HAL::VMEDummyDeviceIdentifier*>(vmeDevice)->remap( startAddress );
@@ -327,7 +327,7 @@ HAL::VMEDummyBusAdapter::writeBlock( DeviceIdentifier* vmeDevice,
                                 uint32_t dataWidth,
                                 char *buffer,
                                 HalAddressIncrement addressBehaviour ) 
-    throw() {
+{
   
 
     if ( memoryMode == MEMORY_MAP_ON ) {
diff --git a/hal/busAdapter/pci/include/hal/PCILinuxBusAdapter.hh b/hal/busAdapter/pci/include/hal/PCILinuxBusAdapter.hh
index e6d255a74..fea27d982 100755
--- a/hal/busAdapter/pci/include/hal/PCILinuxBusAdapter.hh
+++ b/hal/busAdapter/pci/include/hal/PCILinuxBusAdapter.hh
@@ -62,15 +62,13 @@ public:
 			   PCIDeviceIdentifier** deviceIdentifierPtr,
 			   std::vector<uint32_t>& barRegisters,
 			   bool swapFlag = false );
-
-  void findDeviceByVendor( uint32_t vendorID,
-                           uint32_t deviceID,
-                           uint32_t index,
-                           const PCIAddressTable& pciAddressTable,
-                           PCIDeviceIdentifier** deviceIdentifierPtr,
-                           std::vector<uint64_t>& barRegisters,
-                           bool swapFlag = false);
-
+  void findDeviceByVendor( uint32_t vendorID, 
+			   uint32_t deviceID,
+			   uint32_t index,
+			   const PCIAddressTable& pciAddressTable,
+			   PCIDeviceIdentifier** deviceIdentifierPtr,
+			   std::vector<uint64_t>& barRegisters,
+			   bool swapFlag = false );
   
   /**
    * Registers the device with the i2ocore driver and maps it into
diff --git a/hal/busAdapter/pci/include/hal/busAdapter/pci/version.h b/hal/busAdapter/pci/include/hal/busAdapter/pci/version.h
index 213e2b4b0..17d9588dc 100755
--- a/hal/busAdapter/pci/include/hal/busAdapter/pci/version.h
+++ b/hal/busAdapter/pci/include/hal/busAdapter/pci/version.h
@@ -6,7 +6,7 @@
 
 #define PCILINUXBUSADAPTER_VERSION_MAJOR 6
 #define PCILINUXBUSADAPTER_VERSION_MINOR 0
-#define PCILINUXBUSADAPTER_VERSION_PATCH 3
+#define PCILINUXBUSADAPTER_VERSION_PATCH 4
 
 #undef PCILINUXBUSADAPTER_PREVIOUS_VERSIONS 
 
diff --git a/hal/busAdapter/pci/src/common/PCILinuxBusAdapter.cc b/hal/busAdapter/pci/src/common/PCILinuxBusAdapter.cc
index 340fec0da..9cbab6043 100755
--- a/hal/busAdapter/pci/src/common/PCILinuxBusAdapter.cc
+++ b/hal/busAdapter/pci/src/common/PCILinuxBusAdapter.cc
@@ -109,7 +109,7 @@ void HAL::PCILinuxBusAdapter::findDevice( xpci::Address& deviceConfigAddress,
   try {
     uint64_t val;
     pciBus_.read (deviceConfigAddress, 0x00000010, val);
-  } catch ( xpci::exception::IOError e) {
+  } catch ( xpci::exception::IOError& e) {
     std::stringstream text;
     text << "Could not find PCI device \n"
          << std::ends;
diff --git a/hal/generic/include/hal/PCIBusAdapterInterface.hh b/hal/generic/include/hal/PCIBusAdapterInterface.hh
index 9bbfddde5..f888ca32e 100755
--- a/hal/generic/include/hal/PCIBusAdapterInterface.hh
+++ b/hal/generic/include/hal/PCIBusAdapterInterface.hh
@@ -165,7 +165,7 @@ public :
                       uint32_t address,
                       uint32_t data)  = 0;
   virtual void write64( PCIDeviceIdentifier& device, 
-                        uint32_t address,
+                        uint64_t address,
                         uint64_t data)  = 0;
 
   /**
@@ -178,7 +178,7 @@ public :
                      uint32_t address,
                      uint32_t* result)  = 0;
   virtual void read64( PCIDeviceIdentifier& device, 
-                       uint32_t address,
+                       uint64_t address,
                        uint64_t* result)  = 0;
 
  /** 
@@ -191,7 +191,7 @@ public :
                             uint32_t address, 
                             uint32_t data )  = 0;
   virtual void configWrite64( PCIDeviceIdentifier& device, 
-                              uint32_t address, 
+                              uint64_t address, 
                               uint64_t data )  = 0;
 
  /** 
@@ -204,7 +204,7 @@ public :
                            uint32_t address, 
                            uint32_t* result ) = 0;
   virtual void configRead64( PCIDeviceIdentifier& device,
-                             uint32_t address, 
+                             uint64_t address, 
                              uint64_t* result ) = 0;
 
   /**
@@ -235,8 +235,8 @@ public :
                             char *buffer,
                             HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT ) = 0;
   virtual void writeBlock64(  PCIDeviceIdentifier& device,
-                              uint32_t startAddress,
-                              uint32_t length,
+                              uint64_t startAddress,
+                              uint64_t length,
                               char *buffer,
                               HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT ) = 0;
 
@@ -268,8 +268,8 @@ public :
                            char *buffer,
                            HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT ) = 0;
   virtual void readBlock64(  PCIDeviceIdentifier& device,
-                             uint32_t startAddress,
-                             uint32_t length,
+                             uint64_t startAddress,
+                             uint64_t length,
                              char *buffer,
                              HalAddressIncrement addressBehaviour = HAL_DO_INCREMENT ) = 0;
 
diff --git a/hal/generic/include/hal/generic/version.h b/hal/generic/include/hal/generic/version.h
index 980b03e2f..7496708e7 100755
--- a/hal/generic/include/hal/generic/version.h
+++ b/hal/generic/include/hal/generic/version.h
@@ -7,7 +7,7 @@
 
 #define GENERICHAL_VERSION_MAJOR 5
 #define GENERICHAL_VERSION_MINOR 0
-#define GENERICHAL_VERSION_PATCH 3
+#define GENERICHAL_VERSION_PATCH 4
 
 // If any previous versions available E.g. #define GENERICHAL_PREVIOUS_VERSIONS "3.8.0,3.8.1"
 #undef GENERICHAL_PREVIOUS_VERSIONS
diff --git a/hal/generic/src/common/PCIDevice.cc b/hal/generic/src/common/PCIDevice.cc
index 910b880e0..55bf10b2d 100755
--- a/hal/generic/src/common/PCIDevice.cc
+++ b/hal/generic/src/common/PCIDevice.cc
@@ -187,10 +187,10 @@ void HAL::PCIDevice::hardwareWriteBlock( const HAL::GeneralHardwareAddress& pciA
 }
 
 void HAL::PCIDevice::hardwareWriteBlock64( const HAL::GeneralHardwareAddress& pciAddress,
-					 uint64_t length,
-					 char *buffer,
-					 HalAddressIncrement addressBehaviour,
-					 uint64_t offset) const {
+                                           uint64_t length,
+                                           char *buffer,
+                                           HalAddressIncrement addressBehaviour,
+                                           uint64_t offset) const {
 
   if ( !pciAddress.isMemorySpace() ) {
     std::string text = "Only implemented for Memory Space\n     (HAL::PCIDevice::writeBlock64)";
@@ -232,7 +232,7 @@ void HAL::PCIDevice::hardwareWriteBlock64( const HAL::GeneralHardwareAddress& pc
 
   pciBusAdapter.writeBlock64( *deviceIdentifierPtr, 
                               startAddress,
-                              length*4,
+                              length,
                               buffer,
                               addressBehaviour);
 }
@@ -290,10 +290,10 @@ void HAL::PCIDevice::hardwareReadBlock( const HAL::GeneralHardwareAddress& pciAd
 }
 
 void HAL::PCIDevice::hardwareReadBlock64( const HAL::GeneralHardwareAddress& pciAddress,
-					uint64_t length,
-					char *buffer,
-					HalAddressIncrement addressBehaviour,
-					uint64_t offset) const {
+                                          uint64_t length,
+                                          char *buffer,
+                                          HalAddressIncrement addressBehaviour,
+                                          uint64_t offset) const {
 
   if ( !pciAddress.isMemorySpace() ) {
     std::string text = "Only implemented for Memory Space\n     (HAL::PCIDevice::readBlock64)";
@@ -335,7 +335,7 @@ void HAL::PCIDevice::hardwareReadBlock64( const HAL::GeneralHardwareAddress& pci
 
   pciBusAdapter.readBlock64( *deviceIdentifierPtr, 
                              startAddress,
-                             length*4,
+                             length,
                              buffer,
                              addressBehaviour);
 }
diff --git a/hal/generic/src/common/VMESlot.cc b/hal/generic/src/common/VMESlot.cc
index cfc60dc28..d80ef2038 100755
--- a/hal/generic/src/common/VMESlot.cc
+++ b/hal/generic/src/common/VMESlot.cc
@@ -255,7 +255,7 @@ void HAL::VMESlot::checkVME64xTable( HAL::VMEAddressTable& table ) const {
       if ( vme64xAddress.isMemorySpace() ) {
  	vme64xAddress.setWindowConfiguration( AM, width );
       }
-    } catch ( std::bad_cast ) {
+    } catch ( std::bad_cast& ) {
       std::stringstream text;
       text << "The address table does not contain VME64x items!" 
 	   << "\n    (HAL::VMESlot::checkVME64xTable)" << std::ends;
diff --git a/jal/jtagChain/include/jal/jtagChain/JTAGChain.h b/jal/jtagChain/include/jal/jtagChain/JTAGChain.h
index d5cf9b773..140c987e3 100755
--- a/jal/jtagChain/include/jal/jtagChain/JTAGChain.h
+++ b/jal/jtagChain/include/jal/jtagChain/JTAGChain.h
@@ -80,28 +80,19 @@ namespace jal {
 		JTAGScanData const& input, 
 		JTAGScanData & response, 
 		bool doRead = true, 
-		JTAGState endstate = JTAGState::IDLE)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		JTAGState endstate = JTAGState::IDLE);
 
     /// Do a JTAG instruction register scan. Then go to endstate. Read back the response only if doRead is true. 
     void scanIR(uint32_t numBits, 
 		JTAGScanData const& input, 
 		JTAGScanData & response, 
 		bool doRead = true, 
-		JTAGState endstate = JTAGState::IDLE)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		JTAGState endstate = JTAGState::IDLE);
 
     /// Move the JTAG Test Access Port to a (stable !) JTAG state 
     /// If the state of the hardware is unknown (after contructing the chain), 
     /// the method does a reset (send 8 bits of 1 on the TMS line).
-    void gotoState(JTAGState state)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    void gotoState(JTAGState state);
 
     /// run the JTAG clock for a number of cycles in state runstate, then go to endstate
     ///
@@ -120,26 +111,17 @@ namespace jal {
 		 JTAGState endstate = JTAGState::IDLE,
 		 double mintime = -1., 
 		 double maxtime = -1.,
-		 jal::RunTestStage stage = jal::RTSTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		 jal::RunTestStage stage = jal::RTSTAGE_ALL);
 
     /// reset the Test Access Port (resulting TAP state = JTAGState::RESET)
     /// sends 8 bits of 1 on the TMS line regardless of the state the chain is in 
-    void resetTAP()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    void resetTAP();
 
     /// Move the JTAG Test Access Port to a (stable !) JTAG state on a specified path.
     /// The statepath must specify a valid path through the JTAG state machine. The 
     /// last element in statepath has to be a stable JTAG state.
     /// This rarely used function is implemented since it is defined in the SVF language.
-    void gotoStateByPath(std::vector<JTAGState> statepath)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    void gotoStateByPath(std::vector<JTAGState> statepath);
 
     /// lock the chain; foreseen for the (unlikely) case that multiple threads use the same JTAG chain concurrently
     void lock();
@@ -148,20 +130,14 @@ namespace jal {
     void unlock();
 
   private:
-    void toState(JTAGState state)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    void toState(JTAGState state);
 
     void doScan(bool irscan, 
 		uint32_t numBits, 
 		JTAGScanData const& input, 
 		JTAGScanData & response, 
 		bool doRead, 
-		JTAGState endstate)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		JTAGState endstate);
 
     JTAGController& _controller;
     int _chainNumber;
diff --git a/jal/jtagChain/include/jal/jtagChain/version.h b/jal/jtagChain/include/jal/jtagChain/version.h
index 7b030c4d5..2a076da18 100755
--- a/jal/jtagChain/include/jal/jtagChain/version.h
+++ b/jal/jtagChain/include/jal/jtagChain/version.h
@@ -43,7 +43,7 @@ namespace jaljtagChain
 	const std::string summary = "jaljtagChain";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/jal/jtagChain/src/common/JTAGChain.cpp b/jal/jtagChain/src/common/JTAGChain.cpp
index 9fc82118d..f12a7b7f6 100755
--- a/jal/jtagChain/src/common/JTAGChain.cpp
+++ b/jal/jtagChain/src/common/JTAGChain.cpp
@@ -28,10 +28,7 @@ void jal::JTAGChain::runTest(uint32_t nclk,
 			     jal::JTAGState endstate,
 			     double mintime, 
 			     double maxtime,
-			     jal::RunTestStage stage)
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+			     jal::RunTestStage stage) {
 
   if ( !runstate.isStable() )
     XCEPT_RAISE(jal::OutOfRangeException, "runTest(): invalid runstate specified.");
@@ -83,10 +80,7 @@ void jal::JTAGChain::runTest(uint32_t nclk,
 
 }
 
-void jal::JTAGChain::gotoState(jal::JTAGState state) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::JTAGChain::gotoState(jal::JTAGState state) {
 
   if ( !state.isStable() )
     XCEPT_RAISE(jal::OutOfRangeException, "gotoState(): invalid state specified.");
@@ -101,10 +95,7 @@ void jal::JTAGChain::gotoState(jal::JTAGState state)
   _controller.unlock();
 }
 
-void jal::JTAGChain::gotoStateByPath(vector<jal::JTAGState> statepath) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::JTAGChain::gotoStateByPath(vector<jal::JTAGState> statepath) {
   
   static const struct {       /* This structure is used for next state     */
     jal::JTAGState tms0;           /* logic implementation of the TAP state     */
@@ -186,10 +177,7 @@ void jal::JTAGChain::gotoStateByPath(vector<jal::JTAGState> statepath)
 
 }
 
-void jal::JTAGChain::resetTAP() 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::JTAGChain::resetTAP() {
 
   // get a lock on the controller & select the chain
   _controller.lock(); _controller.selectChain(_chainNumber);
@@ -206,10 +194,7 @@ void jal::JTAGChain::scanIR(uint32_t numBits,
 			    jal::JTAGScanData const& input, 
 			    jal::JTAGScanData & response, 
 			    bool doRead, 
-			    jal::JTAGState endstate) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+			    jal::JTAGState endstate) {
 
   doScan(true, numBits, input, response, doRead, endstate);
 
@@ -219,10 +204,7 @@ void jal::JTAGChain::scanDR(uint32_t numBits,
 			    jal::JTAGScanData const& input, 
 			    jal::JTAGScanData & response, 
 			    bool doRead, 
-			    jal::JTAGState endstate) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+			    jal::JTAGState endstate) {
 
   doScan(false, numBits, input, response, doRead, endstate);
 
@@ -250,10 +232,7 @@ void jal::JTAGChain::doScan(bool irscan,
 			    jal::JTAGScanData const& input, 
 			    jal::JTAGScanData & response, 
 			    bool doRead, 
-			    jal::JTAGState endstate) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+			    jal::JTAGState endstate) {
 
   if ( !endstate.isStable() )
     XCEPT_RAISE(jal::OutOfRangeException, "doScan(): invalid endstate specified.");
@@ -288,10 +267,7 @@ void jal::JTAGChain::doScan(bool irscan,
 }
 
 
-void jal::JTAGChain::toState(jal::JTAGState state) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::JTAGChain::toState(jal::JTAGState state) {
 
   if (state == jal::JTAGState::UNDEF) return;
 
diff --git a/jal/jtagChain/src/common/version.cc b/jal/jtagChain/src/common/version.cc
index cc4e54037..e488f9af2 100755
--- a/jal/jtagChain/src/common/version.cc
+++ b/jal/jtagChain/src/common/version.cc
@@ -17,7 +17,7 @@
 
 GETPACKAGEINFO(jaljtagChain)
 
-void jaljtagChain::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void jaljtagChain::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(jaljtagController);  
 	CHECKDEPENDENCY(config);  
diff --git a/jal/jtagController/include/jal/jtagController/ByteBlasterJTAGController.h b/jal/jtagController/include/jal/jtagController/ByteBlasterJTAGController.h
index 1462bce0c..59c595e9d 100755
--- a/jal/jtagController/include/jal/jtagController/ByteBlasterJTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/ByteBlasterJTAGController.h
@@ -43,21 +43,13 @@ namespace jal {
 
     /// select the JTAG chain active for subsequent commands. This just returns, 
     /// since the controller only supports one chain.
-    virtual void selectChain(int ichain) 
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) { return; }; 
+    virtual void selectChain(int ichain) { return; }; 
 
     /// Set the desired TCK frequency (in Hz) for subsequent commands.
-    virtual void setDesiredTCKFrequency (double f)     
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { _desiredTCKfrequency = f; };
+    virtual void setDesiredTCKFrequency (double f) { _desiredTCKfrequency = f; };
 
     /// send a sequence on the TMS line of the active chain (max. 16 bits)
-    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence)     
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence); 
 
     /** shift bits through the active JTAG chain
      *
@@ -70,10 +62,7 @@ namespace jal {
 		       std::vector<uint8_t> const & data_out, 
 		       std::vector <uint8_t> & data_in, 
 		       bool doRead, 
-		       bool autoTMS = true)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+		       bool autoTMS = true); 
 
 
 
@@ -82,10 +71,7 @@ namespace jal {
     ///                No operation on jal::PULSESTAGE_PAUSE
     virtual void pulseTCK(uint32_t num_tcks, 
 			  bool tmshigh = false, 
-			  jal::PulseStage stage = jal::PULSESTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+			  jal::PulseStage stage = jal::PULSESTAGE_ALL); 
 
     /// lock the controller
     virtual void lock();
@@ -95,20 +81,14 @@ namespace jal {
 
     /// get frequency of the JTAG System Clock in Hz.
     /// may be needed by the chain in order to convert microseconds into cycles
-    virtual double getSCKFrequency()    
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { return _desiredTCKfrequency; };
+    virtual double getSCKFrequency() { return _desiredTCKfrequency; };
 
     /// set debug flag (0..3 no debug, 4: debug, 5: debug & no hardware access)
     virtual void setDebugFlag (int f) { _debug_flag = f; };
 
     /// initialize the ByteBlaster JTAG Controller.
     /// this method is automatically called by the constructor
-    virtual void init()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+    virtual void init(); 
 
   private:
     /// return a (negated) byte from the parallel port status register
diff --git a/jal/jtagController/include/jal/jtagController/CMSDAQJTAGController.h b/jal/jtagController/include/jal/jtagController/CMSDAQJTAGController.h
index ee5afe97d..7cc3f422e 100755
--- a/jal/jtagController/include/jal/jtagController/CMSDAQJTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/CMSDAQJTAGController.h
@@ -74,8 +74,7 @@ namespace jal {
     CMSDAQJTAGController(HAL::PCIDevice& device, 
 			 std::string const& jtag_reg_prefix,
 			 bool simulatePulsing = true,
-			 double SCKFrequency = -1.)
-      throw(jal::HardwareException);
+			 double SCKFrequency = -1.);
 
     /// destructor
     virtual ~CMSDAQJTAGController();
@@ -85,9 +84,7 @@ namespace jal {
 
     /// select the JTAG chain active for subsequent commands. This just returns, 
     /// since the controller only supports one chain.
-    virtual void selectChain(int ichain)     
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) { return; }; 
+    virtual void selectChain(int ichain) { return; }; 
 
     /// Set the desired TCK frequency (in Hz) for subsequent commands.
     ///
@@ -99,18 +96,13 @@ namespace jal {
     /// that this implementation is always slower than the desired speed.
     ///
     /// @param f is the desired frequency in Hz.
-    virtual void setDesiredTCKFrequency (double f)     
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) { _desiredTCKfrequency = f; };
+    virtual void setDesiredTCKFrequency (double f) { _desiredTCKfrequency = f; };
 
     /// send a sequence on the TMS line of the active chain (max. 16 bits)
     ///
     /// @param bitcount is the number of bist (max 16).
     /// @param sequence contains teh bits. The LSB is shifted first.
-    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence); 
 
     /// shift bits through the active JTAG chain
     ///
@@ -125,10 +117,7 @@ namespace jal {
 		       std::vector<uint8_t> const & data_out, 
 		       std::vector <uint8_t> & data_in, 
 		       bool doRead, 
-		       bool autoTMS = true)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+		       bool autoTMS = true); 
 
 
     /// pulse the JTAG clock num_tck times
@@ -158,10 +147,7 @@ namespace jal {
     ///
     virtual void pulseTCK(uint32_t num_tcks, 
 			  bool tmshigh = false,
-			  jal::PulseStage stage = jal::PULSESTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+			  jal::PulseStage stage = jal::PULSESTAGE_ALL); 
 
 
     /// lock the controller
@@ -172,33 +158,27 @@ namespace jal {
 
     /// get frequency of the JTAG System Clock in Hz.
     /// may be needed by the chain in order to convert microseconds into cycles
-    virtual double getSCKFrequency()     
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { return _sck_frequency; };
+    virtual double getSCKFrequency() { return _sck_frequency; };
 
     /// set debug flag (0..3 no debug, 4: debug, 5: debug & no hardware access)
     virtual void setDebugFlag (int f) { _debug_flag = f; };
 
     /// initialize the CMSDAQJTAGController 
     /// this method is automatically called by all methods if not done before
-    virtual void init()
-      throw(jal::HardwareException);
+    virtual void init();
 
 
   private:
     /// return a bit from the TDO
     ///
     /// the TDO bit is returned in the LSB
-    uint8_t readJTAG()
-      throw(jal::HardwareException);
+    uint8_t readJTAG();
   
     /// write three bits to the "TDI_TMS_CLK" register
     ///
     /// @param data is written to the JTAG register. 
     ///        TDI is in bit 6, TMS in bit1, CLK in bit 0 
-    void writeJTAG(uint8_t data)
-      throw(jal::HardwareException);
+    void writeJTAG(uint8_t data);
 
     HAL::PCIDevice & _device;
     std::string _jtag_reg_prefix;
diff --git a/jal/jtagController/include/jal/jtagController/CMSDAQTurboJTAGController.h b/jal/jtagController/include/jal/jtagController/CMSDAQTurboJTAGController.h
index 265b6b889..6e29d9ff1 100755
--- a/jal/jtagController/include/jal/jtagController/CMSDAQTurboJTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/CMSDAQTurboJTAGController.h
@@ -53,8 +53,7 @@ namespace jal {
     CMSDAQTurboJTAGController(HAL::HardwareDeviceInterface& device, 
 			      std::string const& jtag_reg_prefix,
 			      bool simulatePulsing = true,
-			      double SCKFrequency = -1.)
-      throw(jal::HardwareException);
+			      double SCKFrequency = -1.);
 
     /// destructor
     virtual ~CMSDAQTurboJTAGController();
@@ -64,9 +63,7 @@ namespace jal {
 
     /// select the JTAG chain active for subsequent commands. This just returns, 
     /// since the controller only supports one chain.
-    virtual void selectChain(int ichain)     
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) { return; }; 
+    virtual void selectChain(int ichain) { return; }; 
 
     /// Set the desired TCK frequency (in Hz) for subsequent commands.
     ///
@@ -78,18 +75,13 @@ namespace jal {
     /// that this implementation is always slower than the desired speed.
     ///
     /// @param f is the desired frequency in Hz.
-    virtual void setDesiredTCKFrequency (double f)     
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) { _desiredTCKfrequency = f; };
+    virtual void setDesiredTCKFrequency (double f) { _desiredTCKfrequency = f; };
 
     /// send a sequence on the TMS line of the active chain (max. 16 bits)
     ///
     /// @param bitcount is the number of bist (max 32).
     /// @param sequence contains teh bits. The LSB is shifted first.
-    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence); 
 
     /// shift bits through the active JTAG chain
     ///
@@ -104,10 +96,7 @@ namespace jal {
 		       std::vector<uint8_t> const & data_out, 
 		       std::vector <uint8_t> & data_in, 
 		       bool doRead, 
-		       bool autoTMS = true)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+		       bool autoTMS = true); 
 
 
     /// pulse the JTAG clock num_tck times
@@ -137,10 +126,7 @@ namespace jal {
     ///
     virtual void pulseTCK(uint32_t num_tcks, 
 			  bool tmshigh = false,
-			  jal::PulseStage stage = jal::PULSESTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException); 
+			  jal::PulseStage stage = jal::PULSESTAGE_ALL); 
 
 
     /// lock the controller
@@ -151,18 +137,14 @@ namespace jal {
 
     /// get frequency of the JTAG System Clock in Hz.
     /// may be needed by the chain in order to convert microseconds into cycles
-    virtual double getSCKFrequency()     
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { return _sck_frequency; };
+    virtual double getSCKFrequency() { return _sck_frequency; };
 
     /// set debug flag (0..3 no debug, 4: debug, 5: debug & no hardware access)
     virtual void setDebugFlag (int f) { _debug_flag = f; };
 
     /// initialize the CMSDAQTurboJTAGController 
     /// this method is automatically called by all methods if not done before
-    virtual void init()
-      throw(jal::HardwareException);
+    virtual void init();
 
 
   private:
diff --git a/jal/jtagController/include/jal/jtagController/DTTFJTAGController.h b/jal/jtagController/include/jal/jtagController/DTTFJTAGController.h
index 73b6be20d..4ed5274cb 100755
--- a/jal/jtagController/include/jal/jtagController/DTTFJTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/DTTFJTAGController.h
@@ -73,26 +73,17 @@ namespace jal {
 		       std::vector<uint8_t> const & data_out, 
 		       std::vector <uint8_t> & data_in,
 		       bool doRead, 
-		       bool autoTMS = true)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		       bool autoTMS = true);
 
     /// pulse the JTAG clock num_tck times
     /// @param tmshigh is ignored since TMS is set by the last sequenceTMS command.
     /// @param stage: on jal::PULSESTAGE_ALL perform full operation, on jal::PULSESTAGE_PRE only do two pulses
     ///        on jal::PULSESTAGE_PAUSE, perform a wait
-    virtual void pulseTCK(uint32_t num_tcks, bool tmshigh = false, jal::PulseStage stage = jal::PULSESTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    virtual void pulseTCK(uint32_t num_tcks, bool tmshigh = false, jal::PulseStage stage = jal::PULSESTAGE_ALL);
 
     /// initialize the DTTF JTAG Controller. This method differs from ScanPSC100JTAGController::init()
     /// as the DTTF JTAG Controller does not support loopback testing.
-    virtual void init()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    virtual void init();
 
   private:
     jal::Timer _timer;
diff --git a/jal/jtagController/include/jal/jtagController/HALScanPSC100Adapter.h b/jal/jtagController/include/jal/jtagController/HALScanPSC100Adapter.h
index 56a3f849a..549148293 100755
--- a/jal/jtagController/include/jal/jtagController/HALScanPSC100Adapter.h
+++ b/jal/jtagController/include/jal/jtagController/HALScanPSC100Adapter.h
@@ -61,25 +61,19 @@ namespace jal {
     ///
     /// @param offset is the offset of the ScanPSC register (0..7)
     /// @param data is the data to write
-    virtual void writePSC(uint8_t offset, uint8_t data)
-      throw (jal::OutOfRangeException,
-	     jal::HardwareException);
+    virtual void writePSC(uint8_t offset, uint8_t data);
 
     /// write multiple bytes to a register of the ScanPSC100
     ///
     /// @param offset is the offset of the ScanPSC register (0..7)
     /// @param num_bytes is the number of bytes to write
     /// @param data is the data to write
-    virtual void writeBlockPSC(uint8_t offset, uint32_t num_bytes, const uint8_t* data)
-      throw (jal::OutOfRangeException,
-	     jal::HardwareException);
+    virtual void writeBlockPSC(uint8_t offset, uint32_t num_bytes, const uint8_t* data);
 
     /// read a byte from a register of the ScanPSC100
     ///
     /// @param offset is the offset of the ScanPSC register (0..7)
-    virtual uint8_t readPSC (uint8_t offset)
-      throw (jal::OutOfRangeException,
-	     jal::HardwareException);
+    virtual uint8_t readPSC (uint8_t offset);
 
   private:
     HAL::HardwareDeviceInterface& _device;
diff --git a/jal/jtagController/include/jal/jtagController/JTAGController.h b/jal/jtagController/include/jal/jtagController/JTAGController.h
index ea69c7575..244253672 100755
--- a/jal/jtagController/include/jal/jtagController/JTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/JTAGController.h
@@ -66,28 +66,20 @@ namespace jal {
     virtual uint32_t numberOfChains() = 0;
 
     /// select one of the chains of the JTAG controller as active chain for subsequent commands
-    virtual void selectChain(int ichain)
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) = 0;
+    virtual void selectChain(int ichain) = 0;
 
     /// Set the desired TCK frequency (in Hz) for subsequent commands.
     /// The controller either changes to the desired TCK frequency or remembers the desired
     /// frequency in order to scale subsequent cycle numbers in the pulseTCK commnd.
     ///
     /// @param f is the desired frequency in Hz or -1. if the default frequency is to be used.
-    virtual void setDesiredTCKFrequency (double f)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) = 0;
+    virtual void setDesiredTCKFrequency (double f) = 0;
 
     /// send a TMS seqence on the active JTAG chain (max. 16 bits)
     ///
     /// @param bitcount is the number of bits (max 16)
     /// @param sequence contain the sequence to be shifted (in the lowermost bits). Shifting starts with the LSB. 
-    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) = 0;
+    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence) = 0;
 
     /** shift bits through the active JTAG chain
      * 
@@ -106,10 +98,7 @@ namespace jal {
 		       std::vector<uint8_t> const & data_out, 
 		       std::vector <uint8_t> & data_in, 
 		       bool doRead, 
-		       bool autoTMS = true)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) = 0;
+		       bool autoTMS = true) = 0;
 
     /// pulse the JTAG clock for a number of clock cycles
     ///
@@ -130,17 +119,11 @@ namespace jal {
     ///        should be performed when called with jal::PULSESTAGE_PRE, 
     ///        and nothing should be done when called with jal::PULSESTAGE_PAUSE.
     ///
-    virtual void pulseTCK(uint32_t num_tcks, bool tmshigh = false, jal::PulseStage stage = jal::PULSESTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) = 0;
+    virtual void pulseTCK(uint32_t num_tcks, bool tmshigh = false, jal::PulseStage stage = jal::PULSESTAGE_ALL) = 0;
 
     /// get the actual frequency of the JTAG System Clock in Hz.
     /// may be needed by the chain in order to convert microseconds into cycles
-    virtual double getSCKFrequency()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) = 0;
+    virtual double getSCKFrequency() = 0;
 
     /// lock the JTAG controller software interface (needed if multiple threads use the same controller)
     virtual void lock() = 0;
diff --git a/jal/jtagController/include/jal/jtagController/ScanPSC100Adapter.h b/jal/jtagController/include/jal/jtagController/ScanPSC100Adapter.h
index 02cbe942b..ce926e666 100755
--- a/jal/jtagController/include/jal/jtagController/ScanPSC100Adapter.h
+++ b/jal/jtagController/include/jal/jtagController/ScanPSC100Adapter.h
@@ -34,23 +34,17 @@ namespace jal {
     /// write a byte to a ScanPSC100 register
     /// @param offset is in the range (0..7)
     /// @param data is the data byte to write
-    virtual void writePSC(uint8_t offset, uint8_t data)
-      throw (jal::OutOfRangeException,
-	     jal::HardwareException) = 0;
+    virtual void writePSC(uint8_t offset, uint8_t data) = 0;
 
     /// write a number of bytes to a ScanPSC100 register
     /// @param offset is in the range (0..7)
     /// @param num_bytes is the number of data bytes to write
     /// @param data is the array of data bytes.
-    virtual void writeBlockPSC(uint8_t offset, uint32_t num_bytes, const uint8_t* data)
-      throw (jal::OutOfRangeException,
-	     jal::HardwareException) = 0;
+    virtual void writeBlockPSC(uint8_t offset, uint32_t num_bytes, const uint8_t* data) = 0;
 
     /// read a byte from a ScanPSC100 register
     /// @param offset is in the range (0..7)
-    virtual uint8_t readPSC (uint8_t offset)
-      throw (jal::OutOfRangeException,
-	     jal::HardwareException) = 0;
+    virtual uint8_t readPSC (uint8_t offset) = 0;
 
   };
 
diff --git a/jal/jtagController/include/jal/jtagController/ScanPSC100JTAGController.h b/jal/jtagController/include/jal/jtagController/ScanPSC100JTAGController.h
index 64334c217..03856d2e5 100755
--- a/jal/jtagController/include/jal/jtagController/ScanPSC100JTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/ScanPSC100JTAGController.h
@@ -55,24 +55,16 @@ namespace jal {
     virtual uint32_t numberOfChains() { return 2; }; 
 
     /// select the JTAG chain active for subsequent commands (@param ichain = 0 or 1)
-    virtual void selectChain(int ichain)
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException);
+    virtual void selectChain(int ichain);
 
     /// Set the desired TCK frequency (in Hz) for subsequent commands.
     /// The ScanPSC100JTAGController remembers the desired
     /// frequency in order to scale subsequent cycle numbers in the pulseTCK commnd.
     /// @param f is the desired frequency in Hz or -1. if the default frequency is to be used.
-    virtual void setDesiredTCKFrequency (double f) 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { _desiredTCKfrequency = f; };
+    virtual void setDesiredTCKFrequency (double f) { _desiredTCKfrequency = f; };
 
     /// send a sequence on the TMS line of the active chain (max. 16 bits)
-    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence);
 
     /** shift bits through the active JTAG chain
      *
@@ -95,10 +87,7 @@ namespace jal {
 		       std::vector<uint8_t> const & data_out, 
 		       std::vector <uint8_t> & data_in, 
 		       bool doRead, 
-		       bool autoTMS = true)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		       bool autoTMS = true);
 
 
     /// pulse the JTAG clock num_tck times
@@ -109,10 +98,7 @@ namespace jal {
     ///                No operation on jal::PULSESTAGE_PAUSE
     virtual void pulseTCK(uint32_t num_tcks, 
 			  bool tmshigh = false, 
-			  jal::PulseStage stage = jal::PULSESTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+			  jal::PulseStage stage = jal::PULSESTAGE_ALL);
 
     /// lock the controller
     virtual void lock();
@@ -124,39 +110,23 @@ namespace jal {
     void setSCKFrequency(double f) { _SCK_frequency = f; };
 
     /// get Frequency of the ScanPSC100 system clock (in Hz)
-    virtual double getSCKFrequency() 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { return _SCK_frequency; }; 
+    virtual double getSCKFrequency() { return _SCK_frequency; }; 
   
     /// set debug flag (0..3 no debug, 4: debug, 5: debug & no hardware access)
     virtual void setDebugFlag (int f) { _debug_flag = f; };
 
     /// initialize the ScanPSC100 JTAG Controller.
-    virtual void init()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    virtual void init();
 
   protected:
-    virtual uint32_t readTCKCounter()
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException);
+    virtual uint32_t readTCKCounter();
 
-    virtual void writeTCKCounter(uint32_t count)
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException);
+    virtual void writeTCKCounter(uint32_t count);
 
-    virtual void waitForPSC(uint8_t status_mask, uint32_t times_to_check = 1)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    virtual void waitForPSC(uint8_t status_mask, uint32_t times_to_check = 1);
 
     /// check if the controller is initialized. if not, initialize it
-    virtual void init_check()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+    virtual void init_check();
 
     ScanPSC100Adapter& _adapter;
     int _currentChain;
diff --git a/jal/jtagController/include/jal/jtagController/TimedJTAGController.h b/jal/jtagController/include/jal/jtagController/TimedJTAGController.h
index 79c224d5b..b6ae0cfa5 100755
--- a/jal/jtagController/include/jal/jtagController/TimedJTAGController.h
+++ b/jal/jtagController/include/jal/jtagController/TimedJTAGController.h
@@ -40,10 +40,7 @@ namespace jal {
     virtual ~TimedJTAGController() { };
   
     /// send a sequence on the TMS line of the active chain (max. 16 bits)
-    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence) 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) {
+    virtual void sequenceTMS(uint32_t bitcount, uint32_t sequence) {
 
       _sw.start();
       _jc->sequenceTMS(bitcount, sequence);
@@ -58,10 +55,7 @@ namespace jal {
      *        the last bit in order to move the JTAG state machine to the EXIT1 state
      *
      */
-    virtual void shift(uint32_t bitcount, std::vector<uint8_t> const & data_out, std::vector <uint8_t> & data_in, bool doRead, bool autoTMS = true) 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) {
+    virtual void shift(uint32_t bitcount, std::vector<uint8_t> const & data_out, std::vector <uint8_t> & data_in, bool doRead, bool autoTMS = true) {
 
       _sw.start();
       _jc->shift(bitcount, data_out, data_in, doRead, autoTMS);
@@ -78,10 +72,7 @@ namespace jal {
     ///
     /// @param tmshigh indicates whether TMS should be high while pulsing the clock.
     ///        needed for RUNTEST in RESET state
-    virtual void pulseTCK(uint32_t num_tcks, bool tmshigh = false, jal::PulseStage stage = jal::PULSESTAGE_ALL) 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) {
+    virtual void pulseTCK(uint32_t num_tcks, bool tmshigh = false, jal::PulseStage stage = jal::PULSESTAGE_ALL) {
 
       _sw.start();
       _jc->pulseTCK(num_tcks, tmshigh, stage);
@@ -94,19 +85,11 @@ namespace jal {
 
     virtual uint32_t numberOfChains() { return _jc->numberOfChains(); };
 
-    virtual void selectChain(int ichain)
-      throw(jal::HardwareException,
-	    jal::OutOfRangeException) { _jc->selectChain(ichain); };
+    virtual void selectChain(int ichain) { _jc->selectChain(ichain); };
 
-    virtual void setDesiredTCKFrequency (double f)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { _jc->setDesiredTCKFrequency(f); if (f>0.) _desiredClockFrequency = f;}
+    virtual void setDesiredTCKFrequency (double f) { _jc->setDesiredTCKFrequency(f); if (f>0.) _desiredClockFrequency = f;}
 
-    virtual double getSCKFrequency()
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { return _jc->getSCKFrequency(); }
+    virtual double getSCKFrequency() { return _jc->getSCKFrequency(); }
 
     virtual void lock() { _jc->lock(); }
 
diff --git a/jal/jtagController/include/jal/jtagController/version.h b/jal/jtagController/include/jal/jtagController/version.h
index 625ef4b4e..1e502a26b 100755
--- a/jal/jtagController/include/jal/jtagController/version.h
+++ b/jal/jtagController/include/jal/jtagController/version.h
@@ -43,7 +43,7 @@ namespace jaljtagController
 	const std::string summary = "jaljtagController";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/jal/jtagController/src/common/ByteBlasterJTAGController.cpp b/jal/jtagController/src/common/ByteBlasterJTAGController.cpp
index 7b49a232d..edea163de 100755
--- a/jal/jtagController/src/common/ByteBlasterJTAGController.cpp
+++ b/jal/jtagController/src/common/ByteBlasterJTAGController.cpp
@@ -59,10 +59,7 @@ void jal::ByteBlasterJTAGController::shift(uint32_t num_bits,
 					   vector<uint8_t> const& data_out, 
 					   vector<uint8_t> &  data_in,
 					   bool doRead, 
-					   bool autoTMS) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+					   bool autoTMS) {
 
   if (!_initialized) init();
 
@@ -102,10 +99,7 @@ void jal::ByteBlasterJTAGController::shift(uint32_t num_bits,
 
 
 
-void jal::ByteBlasterJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms)   
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ByteBlasterJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) {
 
   if (!_initialized) init();
 
@@ -123,10 +117,7 @@ void jal::ByteBlasterJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms
 }
 
 
-void jal::ByteBlasterJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ByteBlasterJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) {
 
   // currently no support for separating pulseTCK into some pulses and then a pause
   if (stage == jal::PULSESTAGE_PAUSE) return;
@@ -144,10 +135,7 @@ void jal::ByteBlasterJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, j
 
 
 
-void jal::ByteBlasterJTAGController::init() 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ByteBlasterJTAGController::init() {
 
   static bool first=true;
   assert(first);
diff --git a/jal/jtagController/src/common/CMSDAQJTAGController.cpp b/jal/jtagController/src/common/CMSDAQJTAGController.cpp
index 6ca0471c8..2cb6a8493 100755
--- a/jal/jtagController/src/common/CMSDAQJTAGController.cpp
+++ b/jal/jtagController/src/common/CMSDAQJTAGController.cpp
@@ -20,8 +20,7 @@ using namespace HAL;
 jal::CMSDAQJTAGController::CMSDAQJTAGController(PCIDevice& device, 
 					   string const& jtag_reg_prefix,
 					   bool simulatePulsing,
-					   double SCKFrequency) 
-  throw (jal::HardwareException)
+					   double SCKFrequency)   
   : _device(device), 
     _jtag_reg_prefix(jtag_reg_prefix), 
     _simulatepulsing(simulatePulsing), 
@@ -74,10 +73,7 @@ void jal::CMSDAQJTAGController::shift(uint32_t num_bits,
 				      vector<uint8_t> const& data_out, 
 				      vector<uint8_t> &  data_in,
 				      bool doRead, 
-				      bool autoTMS) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+				      bool autoTMS) {
 
   if (!_initialized) init();
 
@@ -133,10 +129,7 @@ void jal::CMSDAQJTAGController::shift(uint32_t num_bits,
 
 
 
-void jal::CMSDAQJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::CMSDAQJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) {
 
   if (!_initialized) init();
 
@@ -165,10 +158,7 @@ void jal::CMSDAQJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms)
 }
 
 
-void jal::CMSDAQJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::CMSDAQJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) {
 
   if (!_initialized) init();
 
@@ -220,8 +210,7 @@ void jal::CMSDAQJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::P
 }
 
 
-void jal::CMSDAQJTAGController::init() 
-  throw(jal::HardwareException) { 
+void jal::CMSDAQJTAGController::init() { 
 
   try {
     _device.write(_jtag_reg_prefix+"ENABLE", 0x1);
@@ -233,8 +222,7 @@ void jal::CMSDAQJTAGController::init()
 }
 
 
-uint8_t jal::CMSDAQJTAGController::readJTAG() 
-  throw(jal::HardwareException) { 
+uint8_t jal::CMSDAQJTAGController::readJTAG() { 
 
   uint32_t d;
 
@@ -259,8 +247,7 @@ uint8_t jal::CMSDAQJTAGController::readJTAG()
   return (uint8_t) d;
 }
 
-void jal::CMSDAQJTAGController::writeJTAG(uint8_t data) 
-  throw(jal::HardwareException) { 
+void jal::CMSDAQJTAGController::writeJTAG(uint8_t data) { 
 
   uint32_t d = (uint32_t) data;
 
diff --git a/jal/jtagController/src/common/CMSDAQTurboJTAGController.cpp b/jal/jtagController/src/common/CMSDAQTurboJTAGController.cpp
index 92fadc2bc..29b7cc749 100755
--- a/jal/jtagController/src/common/CMSDAQTurboJTAGController.cpp
+++ b/jal/jtagController/src/common/CMSDAQTurboJTAGController.cpp
@@ -13,8 +13,7 @@ using namespace HAL;
 jal::CMSDAQTurboJTAGController::CMSDAQTurboJTAGController(HardwareDeviceInterface& device, 
 					   string const& jtag_reg_prefix,
 					   bool simulatePulsing,
-					   double SCKFrequency) 
-  throw (jal::HardwareException)
+					   double SCKFrequency)
   : _device(device), 
     _jtag_reg_prefix(jtag_reg_prefix), 
     _simulatepulsing(simulatePulsing), 
@@ -47,10 +46,7 @@ void jal::CMSDAQTurboJTAGController::shift(uint32_t num_bits,
 				      vector<uint8_t> const& data_out, 
 				      vector<uint8_t> &  data_in,
 				      bool doRead, 
-				      bool autoTMS) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+				      bool autoTMS) {
 
   if (!_initialized) init();
 
@@ -134,10 +130,7 @@ void jal::CMSDAQTurboJTAGController::shift(uint32_t num_bits,
 
 
 
-void jal::CMSDAQTurboJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::CMSDAQTurboJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) {
 
   if (!_initialized) init();
 
@@ -170,10 +163,7 @@ void jal::CMSDAQTurboJTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms
 }
 
 
-void jal::CMSDAQTurboJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::CMSDAQTurboJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) {
 
 
 
@@ -246,8 +236,7 @@ if (_debug_flag >= 4) std::cout << "pulseTCK(" << std::dec << num_tcks << ") cal
 }
 
 
-void jal::CMSDAQTurboJTAGController::init() 
-  throw(jal::HardwareException) { 
+void jal::CMSDAQTurboJTAGController::init() { 
 
   try {
     _device.write(_jtag_reg_prefix+"ENABLE", 0x1);
diff --git a/jal/jtagController/src/common/DTTFJTAGController.cpp b/jal/jtagController/src/common/DTTFJTAGController.cpp
index 79282be5f..4d2035f42 100755
--- a/jal/jtagController/src/common/DTTFJTAGController.cpp
+++ b/jal/jtagController/src/common/DTTFJTAGController.cpp
@@ -27,10 +27,7 @@ void jal::DTTFJTAGController::shift(uint32_t num_bits,
 				    vector<uint8_t> const& data_out, 
 				    vector<uint8_t> &  data_in,
 				    bool doRead, 
-				    bool autoTMS) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+				    bool autoTMS) {
 
   init_check();
 
@@ -95,10 +92,7 @@ void jal::DTTFJTAGController::shift(uint32_t num_bits,
 // The DTTF JTAGController firmware does not support pulsing the clock without
 // shifting data. Do a wait, instead.
 
-void jal::DTTFJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage)   
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::DTTFJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::PulseStage stage) {
 
   init_check();
 
@@ -140,10 +134,7 @@ void jal::DTTFJTAGController::pulseTCK(uint32_t num_tcks, bool tmshigh, jal::Pul
 /// Inititialize the DTTF JTAG Controller
 /// The DTTF JTAG controller is reset and left in Continuous Update mode upon exit.
 
-void jal::DTTFJTAGController::init()   
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::DTTFJTAGController::init() {
 
   if (_debug_flag >= 4) std::cout << "jal::DTTFJTAGController:init() called." << std::endl << std::endl;
   if (_debug_flag == 5) { _initialized = true; return; }
diff --git a/jal/jtagController/src/common/HALScanPSC100Adapter.cpp b/jal/jtagController/src/common/HALScanPSC100Adapter.cpp
index f506b4171..370cfec4e 100755
--- a/jal/jtagController/src/common/HALScanPSC100Adapter.cpp
+++ b/jal/jtagController/src/common/HALScanPSC100Adapter.cpp
@@ -20,9 +20,7 @@ jal::HALScanPSC100Adapter::HALScanPSC100Adapter(HardwareDeviceInterface& device,
 jal::HALScanPSC100Adapter::~HALScanPSC100Adapter() {
 }
 
-void jal::HALScanPSC100Adapter::writePSC(uint8_t offset, uint8_t data) 
-  throw (jal::OutOfRangeException,
-	 jal::HardwareException) {
+void jal::HALScanPSC100Adapter::writePSC(uint8_t offset, uint8_t data) {
 
   if (offset > 7) 
     XCEPT_RAISE(jal::OutOfRangeException, "PSC offset out of range" );
@@ -37,9 +35,7 @@ void jal::HALScanPSC100Adapter::writePSC(uint8_t offset, uint8_t data)
    }
 }
 
-void jal::HALScanPSC100Adapter::writeBlockPSC(uint8_t offset, uint32_t num_bytes, const uint8_t *data) 
-  throw (jal::OutOfRangeException,
-	 jal::HardwareException) {
+void jal::HALScanPSC100Adapter::writeBlockPSC(uint8_t offset, uint32_t num_bytes, const uint8_t *data) {
 
   if (offset > 7) 
     XCEPT_RAISE(jal::OutOfRangeException, "PSC offset out of range" );
@@ -63,9 +59,7 @@ void jal::HALScanPSC100Adapter::writeBlockPSC(uint8_t offset, uint32_t num_bytes
 }
 
 
-uint8_t jal::HALScanPSC100Adapter::readPSC(uint8_t offset)
-  throw (jal::OutOfRangeException,
-	 jal::HardwareException) {
+uint8_t jal::HALScanPSC100Adapter::readPSC(uint8_t offset) {
 
   if (offset > 7) 
     XCEPT_RAISE(jal::OutOfRangeException, "PSC offset out of range" );
diff --git a/jal/jtagController/src/common/ScanPSC100JTAGController.cpp b/jal/jtagController/src/common/ScanPSC100JTAGController.cpp
index 4e44dc8d9..c37ff154a 100755
--- a/jal/jtagController/src/common/ScanPSC100JTAGController.cpp
+++ b/jal/jtagController/src/common/ScanPSC100JTAGController.cpp
@@ -22,9 +22,7 @@ jal::ScanPSC100JTAGController::ScanPSC100JTAGController(jal::ScanPSC100Adapter&
 
 }
 
-void jal::ScanPSC100JTAGController::selectChain(int ichain) 
-  throw(jal::HardwareException,
-	jal::OutOfRangeException) {
+void jal::ScanPSC100JTAGController::selectChain(int ichain) {
 
   if (ichain<0 || ichain>=2) 
     XCEPT_RAISE(jal::OutOfRangeException, "selectChain(): ichain out of range");
@@ -34,9 +32,7 @@ void jal::ScanPSC100JTAGController::selectChain(int ichain)
 
 /// read the four bytes of the ScanPSC100 counter into an uint32_t
 
-uint32_t jal::ScanPSC100JTAGController::readTCKCounter()
-  throw(jal::HardwareException,
-	jal::OutOfRangeException) {
+uint32_t jal::ScanPSC100JTAGController::readTCKCounter() {
 
   uint32_t cnt = 0;
 
@@ -56,9 +52,7 @@ uint32_t jal::ScanPSC100JTAGController::readTCKCounter()
 /// TCK output of the SCANPSC100.
 
 
-void jal::ScanPSC100JTAGController::writeTCKCounter(uint32_t num_tcks)
-  throw(jal::HardwareException,
-	jal::OutOfRangeException) {
+void jal::ScanPSC100JTAGController::writeTCKCounter(uint32_t num_tcks) {
 
   _adapter.writePSC(PSC_WRITE_CNT, (uint8_t) num_tcks);
   _adapter.writePSC(PSC_WRITE_CNT, (uint8_t)(num_tcks >>= 8));
@@ -75,10 +69,7 @@ void jal::ScanPSC100JTAGController::writeTCKCounter(uint32_t num_tcks)
 /// SCANPSC100 datasheet for a complete description.
 
 
-void jal::ScanPSC100JTAGController::waitForPSC(uint8_t status_mask, uint32_t times_to_check)
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ScanPSC100JTAGController::waitForPSC(uint8_t status_mask, uint32_t times_to_check) {
 
   if (_debug_flag >= 4) 
     std::cout << "waitForPSC(" << std::dec << status_mask << ") called." << std::endl << std::endl;
@@ -136,10 +127,7 @@ void jal::ScanPSC100JTAGController::shift(uint32_t num_bits,
 					  vector<uint8_t> const& data_out, 
 					  vector<uint8_t> &  data_in,
 					  bool doRead, 
-					  bool autoTMS)
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+					  bool autoTMS) {
 
   init_check();
 
@@ -243,10 +231,7 @@ void jal::ScanPSC100JTAGController::shift(uint32_t num_bits,
 }
 
 
-void jal::ScanPSC100JTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ScanPSC100JTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms) {
 
   init_check();
 
@@ -290,10 +275,7 @@ void jal::ScanPSC100JTAGController::sequenceTMS(uint32_t num_bits, uint32_t tms)
 
 void jal::ScanPSC100JTAGController::pulseTCK(uint32_t num_tcks, 
 					     bool tmshigh, 
-					     jal::PulseStage stage)
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+					     jal::PulseStage stage) {
 
   // currently no support for separating pulseTCK into some pulses and then a pause
   if (stage == jal::PULSESTAGE_PAUSE) return;
@@ -326,10 +308,7 @@ void jal::ScanPSC100JTAGController::pulseTCK(uint32_t num_tcks,
 }
 
 
-void jal::ScanPSC100JTAGController::init_check() 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ScanPSC100JTAGController::init_check() {
 
   if (!_initialized) init();
 
@@ -346,10 +325,7 @@ void jal::ScanPSC100JTAGController::init_check()
 //                never traverse beyond the TLR, RTI, SEDR, SEIR, TAP states.  The
 //                SCANPSC100 is reset and left in Continuous Update mode upon exit.
 
-void jal::ScanPSC100JTAGController::init() 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+void jal::ScanPSC100JTAGController::init() {
 
   uint32_t times_checked = 0;
 
diff --git a/jal/jtagController/src/common/version.cc b/jal/jtagController/src/common/version.cc
index b1cf70f0f..d746287e3 100755
--- a/jal/jtagController/src/common/version.cc
+++ b/jal/jtagController/src/common/version.cc
@@ -16,7 +16,7 @@
 
 GETPACKAGEINFO(jaljtagController)
 
-void jaljtagController::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void jaljtagController::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 	CHECKDEPENDENCY(xcept);  
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFChain.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFChain.h
index f8665b7f2..ac86673a5 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFChain.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFChain.h
@@ -60,35 +60,22 @@ namespace jal {
     void setFrequency(double f) { _ch.setDesiredTCKFrequency(f);} ;
 
     /// set data register scan header
-    void HDR(JTAGSVFData const& d) 
-      throw(jal::SVFSyntaxException) { _header_dr.update(d); };
+    void HDR(JTAGSVFData const& d) { _header_dr.update(d); };
 
     /// set instruction register scan header
-    void HIR(JTAGSVFData const& d) 
-      throw(jal::SVFSyntaxException) { _header_ir.update(d); };
+    void HIR(JTAGSVFData const& d) { _header_ir.update(d); };
   
     /// set data register scan trailer
-    void TDR(JTAGSVFData const& d) 
-      throw(jal::SVFSyntaxException) { _trailer_dr.update(d); };
+    void TDR(JTAGSVFData const& d) { _trailer_dr.update(d); };
   
     /// set instruction register scan trailer
-    void TIR(JTAGSVFData const& d) 
-      throw(jal::SVFSyntaxException) { _trailer_ir.update(d); };
+    void TIR(JTAGSVFData const& d) { _trailer_ir.update(d); };
 
     /// do an instruction register scan. Return true is successful, false if compare error.
-    bool SIR(JTAGSVFData const& d)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException);
+    bool SIR(JTAGSVFData const& d);
 
     /// do a data register scan. Return true is successful, false if compare error.
-    bool SDR(JTAGSVFData const& d)      
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException);
-
+    bool SDR(JTAGSVFData const& d);
 
     /// set dr scan endstate. Return true is successful, false if not a valid state.
     bool ENDDR(JTAGState s);
@@ -98,18 +85,12 @@ namespace jal {
     bool ENDIR(JTAGState s);
 
     /// Move the JTAG Test Access Port to a stable JTAG state 
-    void gotoState(JTAGState state) 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { _ch.gotoState(state); };
+    void gotoState(JTAGState state) { _ch.gotoState(state); };
 
     /// Move the JTAG Test Access Port to a stable JTAG state on a specified path.
     /// The statepath must specify a valid path through the JTAG state machine. The 
     /// last element in statepath has to be a stable JTAG state.
-    void gotoStateByPath(std::vector<JTAGState> const& statepath) 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { _ch.gotoStateByPath(statepath); };
+    void gotoStateByPath(std::vector<JTAGState> const& statepath) {_ch.gotoStateByPath(statepath); };
 
 
     /// run the JTAG clock for a number of cycles in state runstate, then go to endstate
@@ -119,17 +100,11 @@ namespace jal {
 		 double mintime, 
 		 double maxtime, 
 		 bool sysclock=false,
-		 jal::RunTestStage stage = jal::RTSTAGE_ALL)
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException);
+		 jal::RunTestStage stage = jal::RTSTAGE_ALL);
 
 
     /// reset the TAP
-    void resetTAP() 
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException) { _ch.resetTAP(); };
+    void resetTAP() { _ch.resetTAP(); };
 
     /// control the test reset signal.
     //  bool TRST();
@@ -145,11 +120,7 @@ namespace jal {
     /// returns true on success
     bool executeSequence(std::vector<jal::JTAGSVFCommand *> const& sequence, 
 			 bool quietMode = false,
-			 bool overrideErrors = false)
-      throw (jal::HardwareException,
-	     jal::TimeoutException,
-	     jal::OutOfRangeException,
-	     jal::SVFSyntaxException);
+			 bool overrideErrors = false);
 
     /// get the execution process in per cent
     uint32_t getExecutionProgress() const { return _executionProgress; };
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommand.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommand.h
index 2c6a229a8..b9d6bac46 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommand.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommand.h
@@ -36,18 +36,10 @@ namespace jal {
     virtual ~JTAGSVFCommand() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) = 0;
+    virtual bool execute (JTAGSVFChain& svf_ch) const = 0;
 
     /// execute the command in stages. returns true if successful, false if not.
-    virtual bool executeStage (JTAGSVFChain& svf_ch, jal::CommandStage stage) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) { 
+    virtual bool executeStage (JTAGSVFChain& svf_ch, jal::CommandStage stage) const { 
     
       if (stage == CMDSTAGE_PRE)
 	return execute (svf_ch);
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandCreator.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandCreator.h
index 234c237d8..5fd3252c0 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandCreator.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandCreator.h
@@ -37,8 +37,7 @@ namespace jal {
     ~JTAGSVFCommandCreator();
 
     /// create a command
-    JTAGSVFCommand* create(std::vector<std::string> const& args) 
-      throw (jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
 
     /// reset the command creator (to start a new file)
     void reset();
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEnddr.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEnddr.h
index b2dd7837c..06ed32813 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEnddr.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEnddr.h
@@ -29,11 +29,7 @@ class JTAGSVFCommandEnddr : public JTAGSVFCommand {
   virtual ~JTAGSVFCommandEnddr() {};
 
   /// execute the command. returns true if successful, false if not.
-  virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+  virtual bool execute (JTAGSVFChain& svf_ch) const {
     
     return svf_ch.ENDDR( _endstate );
 
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEndir.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEndir.h
index eac8142f7..561fc68e5 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEndir.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandEndir.h
@@ -29,11 +29,7 @@ namespace jal {
     virtual ~JTAGSVFCommandEndir() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool execute (JTAGSVFChain& svf_ch) const {
     
       return svf_ch.ENDIR( _endstate );
 
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactory.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactory.h
index a64705e54..197a25e2f 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactory.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactory.h
@@ -30,8 +30,7 @@ class JTAGSVFCommandFactory {
  public:  
 
   /// create a command
-  virtual JTAGSVFCommand* create(std::vector<std::string> const& args) 
-    throw(jal::SVFSyntaxException) = 0;
+  virtual JTAGSVFCommand* create(std::vector<std::string> const& args) = 0;
   
   /// reset the command Factory (before starting a new file)
   virtual void reset() {};
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEnddr.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEnddr.h
index fb3fd7877..f77ea6681 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEnddr.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEnddr.h
@@ -31,8 +31,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryEnddr() {};
 
     /// parse an ENDDR command and create the command object
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
   };
 
 }
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEndir.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEndir.h
index f387b6312..0da0bda4d 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEndir.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryEndir.h
@@ -31,8 +31,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryEndir() {};
 
     /// parse an ENDIR command and create the command object
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
   };
 
 }
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryFrequency.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryFrequency.h
index 0d2309131..299916808 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryFrequency.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryFrequency.h
@@ -32,8 +32,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryFrequency() {};
 
     /// parse an frequency command and create the command object
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
   };
 
 }
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryRunTest.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryRunTest.h
index c36e5525d..369111957 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryRunTest.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryRunTest.h
@@ -32,8 +32,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryRunTest() {};
 
     /// parse an RunTest command and create the command object
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
   };
 
 }
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryScan.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryScan.h
index e8b52f6e8..44b2663e7 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryScan.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryScan.h
@@ -39,8 +39,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryScan() {};
 
     /// create a command
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
 
     /// reset the command factory
     virtual void reset() { _first = true; _previous_length = 0;}
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryState.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryState.h
index 6c7bf31d4..c70144c79 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryState.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryState.h
@@ -32,8 +32,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryState() {};
 
     /// parse an State command and create the command object
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
   };
 
 }
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryTRST.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryTRST.h
index 65dfeebe7..d8495cc6d 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryTRST.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFactoryTRST.h
@@ -32,8 +32,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFactoryTRST() {};
 
     /// parse an ENDIR command and create the command object
-    JTAGSVFCommand* create(std::vector<std::string> const& args)
-      throw(jal::SVFSyntaxException);
+    JTAGSVFCommand* create(std::vector<std::string> const& args);
   };
 
 }
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFrequency.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFrequency.h
index efc194257..2ec12c6c3 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFrequency.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandFrequency.h
@@ -33,11 +33,7 @@ namespace jal {
     virtual ~JTAGSVFCommandFrequency() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool execute (JTAGSVFChain& svf_ch) const {
     
       svf_ch.setFrequency ( _frequency );
       return true;
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoState.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoState.h
index 5635b5131..6d05d3db2 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoState.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoState.h
@@ -31,11 +31,7 @@ namespace jal {
     virtual ~JTAGSVFCommandGotoState() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool execute (JTAGSVFChain& svf_ch) const {
     
       svf_ch.gotoState( _state );
       return true;
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoStateByPath.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoStateByPath.h
index 5e581033d..6964afde9 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoStateByPath.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandGotoStateByPath.h
@@ -31,11 +31,7 @@ namespace jal {
     virtual ~JTAGSVFCommandGotoStateByPath() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool execute (JTAGSVFChain& svf_ch) const {
     
       svf_ch.gotoStateByPath( _statepath );
       return true;
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandRunTest.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandRunTest.h
index cafb53496..a05119cd1 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandRunTest.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandRunTest.h
@@ -52,11 +52,7 @@ namespace jal {
     virtual ~JTAGSVFCommandRunTest() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool execute (JTAGSVFChain& svf_ch) const {
     
       svf_ch.runTest(_nclk, _runstate, _endstate, _mintime, _maxtime, _sysclock);
       return true;
@@ -64,11 +60,7 @@ namespace jal {
     };
  
     /// execute the command in stages. returns true if successful, false if not.
-    virtual bool executeStage (JTAGSVFChain& svf_ch, jal::CommandStage stage) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool executeStage (JTAGSVFChain& svf_ch, jal::CommandStage stage) const {
     
       if (stage == jal::CMDSTAGE_PRE)
 	svf_ch.runTest(_nclk, _runstate, _endstate, _mintime, _maxtime, _sysclock, jal::RTSTAGE_PRE);
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandScan.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandScan.h
index fa50799bf..d4d5efcdb 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandScan.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFCommandScan.h
@@ -30,11 +30,7 @@ namespace jal {
     virtual ~JTAGSVFCommandScan() {};
 
     /// execute the command. returns true if successful, false if not.
-    virtual bool execute (JTAGSVFChain& svf_ch) const
-      throw(jal::HardwareException,
-	    jal::TimeoutException,
-	    jal::OutOfRangeException,
-	    jal::SVFSyntaxException) {
+    virtual bool execute (JTAGSVFChain& svf_ch) const {
 
       switch (_type) {
       case SDR : return svf_ch.SDR(_d); break;
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFData.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFData.h
index 34a667bd0..05eeecde3 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFData.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFData.h
@@ -69,22 +69,17 @@ namespace jal {
 
     void setSMask    (JTAGScanData const& smask   ) { _smask = smask; };
 
-    void setData     (std::string const& data    ) 
-      throw(jal::SVFSyntaxException) { stringToScanData (data, _data); };
+    void setData     (std::string const& data     ) { stringToScanData (data, _data); };
 
-    void setResponse (std::string const& response) 
-      throw(jal::SVFSyntaxException) { stringToScanData (response, _resp); };
+    void setResponse (std::string const& response ) { stringToScanData (response, _resp); };
 
-    void setMask     (std::string const& mask    ) 
-      throw(jal::SVFSyntaxException) { stringToScanData (mask, _mask); };
+    void setMask     (std::string const& mask     ) { stringToScanData (mask, _mask); };
 
-    void setSMask    (std::string const& smask   ) 
-      throw(jal::SVFSyntaxException) { stringToScanData (smask, _smask); };
+    void setSMask    (std::string const& smask    ) { stringToScanData (smask, _smask); };
 
     /// update with new data, keep elements that are not specified according to SVF specs.
     /// if the bitcount remains the same, then data, mask and smask are sticky
-    void update (JTAGSVFData const& d) 
-      throw(jal::SVFSyntaxException);
+    void update (JTAGSVFData const& d);
 
     /// get bitcount
     uint32_t bitcount() const { return _bitcount; };
@@ -121,13 +116,11 @@ namespace jal {
 
   private:
     /// parse an SVF style hex string and store it in a JTAGScanData vector
-    void stringToScanData (std::string const& pattern, JTAGScanData& scandata)
-      throw (jal::SVFSyntaxException);
+    void stringToScanData (std::string const& pattern, JTAGScanData& scandata);
 
     /// convect a hex character to a byte value 0 - 15 
     ///
-    static uint8_t hexCharToByte(char ch) 
-      throw (jal::SVFSyntaxException);
+    static uint8_t hexCharToByte(char ch);
 
   protected:
     uint32_t _bitcount;
@@ -138,8 +131,7 @@ namespace jal {
 }
 
 /// in the header in order to inline
-inline uint8_t jal::JTAGSVFData::hexCharToByte(char ch) 
-  throw (jal::SVFSyntaxException) {
+inline uint8_t jal::JTAGSVFData::hexCharToByte(char ch) {
   
   if (ch >= '0' && ch <= '9') 
     return ch-'0';
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFFileReader.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFFileReader.h
index a681344ef..1cb193600 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFFileReader.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFFileReader.h
@@ -36,8 +36,7 @@ namespace jal {
     ~JTAGSVFFileReader();
 
     /// get next command
-    bool nextCommand(std::vector<std::string> & args)
-      throw (jal::FileOpenException);
+    bool nextCommand(std::vector<std::string> & args);
 
 
   private:
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFSequencer.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFSequencer.h
index a38ec62a7..64a695e3a 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFSequencer.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/JTAGSVFSequencer.h
@@ -49,39 +49,20 @@ namespace jal {
     /// the method checks the syntax of the SVF file, but cannot guarantee that there will be no errors when
     /// playing the file. For example, it cannot check, if STATE transitions are valid as it does not check the
     /// endstates of previous commands.
-    bool loadSVFFile(const char *fn, double default_frequency = -1.)
-      throw (jal::SVFSyntaxException,
-	     jal::FileOpenException);
+    bool loadSVFFile(const char *fn, double default_frequency = -1.);
 
     /// execute the stored SVF sequence on a given JTAG chain
-    bool execute(jal::JTAGChain& ch)
-      throw (jal::HardwareException,
-	     jal::TimeoutException,
-	     jal::OutOfRangeException,
-	     jal::SVFSyntaxException);
+    bool execute(jal::JTAGChain& ch);
 
     /// execute the stored SVF sequence on multiple JTAG chains, 
     /// In case of errors, continue on chains that are still ok
-    std::vector<bool> executeParallelNoStopOnError(std::vector<jal::JTAGChain* > chains)
-      throw (jal::HardwareException,
-       jal::TimeoutException,
-       jal::OutOfRangeException,
-       jal::SVFSyntaxException);
+    std::vector<bool> executeParallelNoStopOnError(std::vector<jal::JTAGChain* > chains);
 
     /// execute the stored SVF sequence on multiple JTAG chains
-    bool executeParallel(std::vector<jal::JTAGChain* > chains)
-      throw (jal::HardwareException,
-	     jal::TimeoutException,
-	     jal::OutOfRangeException,
-	     jal::SVFSyntaxException);
+    bool executeParallel(std::vector<jal::JTAGChain* > chains);
 
     /// load and execute an SVF sequence command by command without storing the sequence
-    bool execute_from_file(char *fn, jal::JTAGChain& ch) const 
-      throw (jal::HardwareException,
-	     jal::TimeoutException,
-	     jal::OutOfRangeException,
-	     jal::SVFSyntaxException,
-	     jal::FileOpenException);
+    bool execute_from_file(char *fn, jal::JTAGChain& ch) const;
 
     /// get the progress of the current execute() call (has to be called from a different thread)
     ///
diff --git a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/version.h b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/version.h
index 081d4eba1..3f1d61f7d 100755
--- a/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/version.h
+++ b/jal/jtagSVFSequencer/include/jal/jtagSVFSequencer/version.h
@@ -43,7 +43,7 @@ namespace jaljtagSVFSequencer
 	const std::string summary = "jaljtagSVFSequencer";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFChain.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFChain.cpp
index 925182fd8..430481f5d 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFChain.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFChain.cpp
@@ -16,11 +16,7 @@
 
 using namespace std;
 
-bool jal::JTAGSVFChain::SIR(jal::JTAGSVFData const& d) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException,
-	jal::SVFSyntaxException) {
+bool jal::JTAGSVFChain::SIR(jal::JTAGSVFData const& d) {
 
   _last_ir.update(d);
 
@@ -58,11 +54,7 @@ bool jal::JTAGSVFChain::SIR(jal::JTAGSVFData const& d)
 }
 
 
-bool jal::JTAGSVFChain::SDR(jal::JTAGSVFData const& d)   
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException,
-	jal::SVFSyntaxException) {
+bool jal::JTAGSVFChain::SDR(jal::JTAGSVFData const& d) {
      
   _last_dr.update(d);
 
@@ -150,10 +142,7 @@ void jal::JTAGSVFChain::runTest(uint32_t nclk,
 				double mintime, 
 				double maxtime, 
 				bool sysclock,
-				jal::RunTestStage stage) 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException) {
+				jal::RunTestStage stage) {
   
   if (stage == jal::RTSTAGE_PRE || stage == jal::RTSTAGE_ALL) {
     if (runstate != jal::JTAGState::UNDEF) 
@@ -176,11 +165,7 @@ void jal::JTAGSVFChain::runTest(uint32_t nclk,
 
 bool jal::JTAGSVFChain::executeSequence(std::vector<jal::JTAGSVFCommand *> const& sequence, 
 					bool quietMode,
-					bool overrideErrors)       
-  throw (jal::HardwareException,
-	 jal::TimeoutException,
-	 jal::OutOfRangeException,
-	 jal::SVFSyntaxException) {
+					bool overrideErrors) {
 
   _executionProgress = 0;
   lock();
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandCreator.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandCreator.cpp
index 6edd1b325..c5db9f3e3 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandCreator.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandCreator.cpp
@@ -46,8 +46,7 @@ void jal::JTAGSVFCommandCreator::reset() {
 }
 
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandCreator::create(vector<string> const& args) 
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandCreator::create(vector<string> const& args) {
   
   if (args.size() < 1) 
     XCEPT_RAISE(jal::SVFSyntaxException, "Zero length command encountered.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEnddr.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEnddr.cpp
index eb002f16f..2ce20412b 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEnddr.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEnddr.cpp
@@ -5,8 +5,7 @@
 
 using namespace std;
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryEnddr::create(vector<string> const& args)
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryEnddr::create(vector<string> const& args) {
 
   if (args.size() != 2) 
     XCEPT_RAISE(jal::SVFSyntaxException, "Enddr command needs exactly one parameter.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEndir.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEndir.cpp
index 7d797e830..b1ce47ee5 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEndir.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryEndir.cpp
@@ -5,8 +5,7 @@
 
 using namespace std;
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryEndir::create(vector<string> const& args) 
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryEndir::create(vector<string> const& args) {
 
   if (args.size() != 2) 
     XCEPT_RAISE(jal::SVFSyntaxException, "Endir command needs exactly one parameter.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryFrequency.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryFrequency.cpp
index fe27d1315..54793c245 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryFrequency.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryFrequency.cpp
@@ -7,8 +7,7 @@
 #include <sstream>
 using namespace std;
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryFrequency::create(vector<string> const& args) 
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryFrequency::create(vector<string> const& args) {
 
   // reset to original frequency
   if (args.size() == 1) 
@@ -23,7 +22,7 @@ jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryFrequency::create(vector<string>
   double frequency;
 
   std::istringstream iss( args[1] );
-  bool success = ( iss >> frequency );
+  bool success = static_cast<bool> ( iss >> frequency );
   
   if ( !success )
     XCEPT_RAISE(jal::SVFSyntaxException, "error converting frequency parameter ");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryRunTest.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryRunTest.cpp
index a03c9b8cb..14c314311 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryRunTest.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryRunTest.cpp
@@ -26,8 +26,7 @@ using namespace std;
 //
 
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryRunTest::create(vector<string> const& args) 
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryRunTest::create(vector<string> const& args){
 
   uint32_t i=1;
 
@@ -56,7 +55,7 @@ jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryRunTest::create(vector<string> co
     if (args[i+1] == "SCK" || args[i+1] == "TCK") {
 
       std::istringstream iss ( args[i] );
-      bool success = ( iss >> std::dec >> nclk );
+      bool success = static_cast<bool> ( iss >> std::dec >> nclk );
       if ( ! success ) 
 	XCEPT_RAISE(jal::SVFSyntaxException, "TCK or SCK parameter must be preceeded by and integer.");
       
@@ -76,7 +75,7 @@ jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryRunTest::create(vector<string> co
   if ( i+1<args.size() && args[i+1] == "SEC") {
     
     std::istringstream iss ( args[i] );
-    bool success = ( iss >> mintime );
+    bool success = static_cast<bool> ( iss >> mintime );
     if ( ! success ) 
       XCEPT_RAISE(jal::SVFSyntaxException, "mintime parameter must be a double.");
       
@@ -89,7 +88,7 @@ jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryRunTest::create(vector<string> co
     if ( i+2 < args.size() && args[i] == "MAXTIME" && args[i+2] == "SEC") {
 	
       std::istringstream iss1 ( args[i+1] );
-      bool success1 = ( iss1 >> maxtime );
+      bool success1 = static_cast<bool> ( iss1 >> maxtime );
       if ( ! success1 ) 
 	XCEPT_RAISE(jal::SVFSyntaxException, "maxtime parameter must be a double.");
       
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryScan.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryScan.cpp
index 80bf405cf..7fe2f4f05 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryScan.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryScan.cpp
@@ -19,8 +19,7 @@
 
 using namespace std;
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryScan::create(vector<string> const& args) 
-  throw(jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryScan::create(vector<string> const& args) {
 
   if (args.size() < 2) 
     XCEPT_RAISE(jal::SVFSyntaxException, "Scan command needs at least one parameter.");
@@ -29,7 +28,7 @@ jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryScan::create(vector<string> const
   uint32_t length = 0;
 
   std::istringstream iss(args[1]);  
-  bool success = ( iss >> std::dec >> length ); 
+  bool success = static_cast<bool> ( iss >> std::dec >> length ); 
 
   if (!success) 
     XCEPT_RAISE (jal::SVFSyntaxException, "wrong data format for length field.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryState.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryState.cpp
index 4fc5dcc02..938e65a8d 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryState.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryState.cpp
@@ -7,8 +7,7 @@
 using namespace std;
 
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryState::create(vector<string> const& args) 
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryState::create(vector<string> const& args) {
 
   if (args.size() < 2)    
     XCEPT_RAISE(jal::SVFSyntaxException, "State command needs at least one parameter.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryTRST.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryTRST.cpp
index be1f69be9..5c0c48641 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryTRST.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFCommandFactoryTRST.cpp
@@ -4,8 +4,7 @@
 
 using namespace std;
 
-jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryTRST::create(vector<string> const& args) 
-  throw (jal::SVFSyntaxException) {
+jal::JTAGSVFCommand* jal::JTAGSVFCommandFactoryTRST::create(vector<string> const& args) {
 
   if (args.size() != 2) 
     XCEPT_RAISE(jal::SVFSyntaxException, "TRST command needs exactly one parameter.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFData.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFData.cpp
index 16a250847..f31b81cfd 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFData.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFData.cpp
@@ -15,8 +15,7 @@
 
 using namespace std;
 
-void jal::JTAGSVFData::update (jal::JTAGSVFData const& d) 
-  throw(jal::SVFSyntaxException) {
+void jal::JTAGSVFData::update (jal::JTAGSVFData const& d) {
     
   if (_bitcount == d._bitcount) {
 
@@ -67,8 +66,7 @@ jal::JTAGSVFData& jal::JTAGSVFData::operator+= (jal::JTAGSVFData const& d2) {
 
 
 void jal::JTAGSVFData::stringToScanData (string const& pattern, 
-					 jal::JTAGScanData& scandata) 
-  throw(jal::SVFSyntaxException) {
+					 jal::JTAGScanData& scandata) {
   
 
   if ( pattern.length() < 2 )
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFFileReader.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFFileReader.cpp
index c842880be..1e57df408 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFFileReader.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFFileReader.cpp
@@ -13,8 +13,7 @@ jal::JTAGSVFFileReader::~JTAGSVFFileReader () {
   _filestream.close();
 }
 
-bool jal::JTAGSVFFileReader::nextCommand (vector <string> & args) 
-  throw (jal::FileOpenException) {
+bool jal::JTAGSVFFileReader::nextCommand (vector <string> & args) {
 
   if (! _filestream ) 
     XCEPT_RAISE(jal::FileOpenException, "cannot open SVF file.");
diff --git a/jal/jtagSVFSequencer/src/common/JTAGSVFSequencer.cpp b/jal/jtagSVFSequencer/src/common/JTAGSVFSequencer.cpp
index c30241191..8d42902b9 100755
--- a/jal/jtagSVFSequencer/src/common/JTAGSVFSequencer.cpp
+++ b/jal/jtagSVFSequencer/src/common/JTAGSVFSequencer.cpp
@@ -17,9 +17,7 @@
 using namespace std;
 
 
-bool jal::JTAGSVFSequencer::loadSVFFile(const char *fn, double default_frequency) 
-  throw (jal::SVFSyntaxException,
-	 jal::FileOpenException) {
+bool jal::JTAGSVFSequencer::loadSVFFile(const char *fn, double default_frequency) {
 
   jal::JTAGSVFFileReader reader(fn);
   jal::JTAGSVFCommandCreator fab;
@@ -51,11 +49,7 @@ jal::JTAGSVFSequencer::~JTAGSVFSequencer() {
     delete (*it);
 }
 
-bool jal::JTAGSVFSequencer::execute(JTAGChain& ch) 
-  throw (jal::HardwareException,
-	 jal::TimeoutException,
-	 jal::OutOfRangeException,
-	 jal::SVFSyntaxException) {
+bool jal::JTAGSVFSequencer::execute(JTAGChain& ch) {
 
   _progress = 0;
   jal::JTAGSVFChain svf_ch(ch);
@@ -87,11 +81,7 @@ bool jal::JTAGSVFSequencer::execute(JTAGChain& ch)
   return ok;
 }
 
-bool jal::JTAGSVFSequencer::executeParallel(std::vector<jal::JTAGChain*> chains)  // leave this original implementation for backwards compatibility
-  throw (jal::HardwareException,
-   jal::TimeoutException,
-   jal::OutOfRangeException,
-   jal::SVFSyntaxException) {
+bool jal::JTAGSVFSequencer::executeParallel(std::vector<jal::JTAGChain*> chains) {  // leave this original implementation for backwards compatibility 
 
 
   if (chains.size() < 1) 
@@ -179,11 +169,7 @@ bool jal::JTAGSVFSequencer::anyOk(vector<bool> v) const {
   return anyOk; 
 }
 
-std::vector<bool> jal::JTAGSVFSequencer::executeParallelNoStopOnError(std::vector<jal::JTAGChain*> chains) // new implementation that continues on remaining chains in case of errors
-  throw (jal::HardwareException,
-	 jal::TimeoutException,
-	 jal::OutOfRangeException,
-	 jal::SVFSyntaxException) {
+std::vector<bool> jal::JTAGSVFSequencer::executeParallelNoStopOnError(std::vector<jal::JTAGChain*> chains) { // new implementation that continues on remaining chains in case of errors 
 
 
   if (chains.size() < 1) 
@@ -292,12 +278,7 @@ std::vector<bool> jal::JTAGSVFSequencer::executeParallelNoStopOnError(std::vecto
 }
 
 
-bool jal::JTAGSVFSequencer::execute_from_file(char *fn, JTAGChain& ch) const 
-  throw(jal::HardwareException,
-	jal::TimeoutException,
-	jal::OutOfRangeException,
-	jal::SVFSyntaxException,
-	jal::FileOpenException) {
+bool jal::JTAGSVFSequencer::execute_from_file(char *fn, JTAGChain& ch) const {
 
   jal::JTAGSVFFileReader reader(fn);
   jal::JTAGSVFCommandCreator fab;
diff --git a/jal/jtagSVFSequencer/src/common/version.cc b/jal/jtagSVFSequencer/src/common/version.cc
index 057d4c835..ae3ef220e 100755
--- a/jal/jtagSVFSequencer/src/common/version.cc
+++ b/jal/jtagSVFSequencer/src/common/version.cc
@@ -18,7 +18,7 @@
 
 GETPACKAGEINFO(jaljtagSVFSequencer)
 
-void jaljtagSVFSequencer::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void jaljtagSVFSequencer::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(jaljtagChain);  
 	CHECKDEPENDENCY(jaljtagController);  
diff --git a/jal/jtagSVFSequencer/test/common/SimpleSVFTest.cpp b/jal/jtagSVFSequencer/test/common/SimpleSVFTest.cpp
index d50730b76..7bcff9e87 100755
--- a/jal/jtagSVFSequencer/test/common/SimpleSVFTest.cpp
+++ b/jal/jtagSVFSequencer/test/common/SimpleSVFTest.cpp
@@ -23,7 +23,7 @@ using namespace jal;
 int main(int argc, char **argv) {
 
   uint32_t VMEbase = 0xA10000;
-  char *addrtable_fn = "/home/hsakulin/jtag_test2/AddressTable_Outcard.txt";
+  const char *addrtable_fn = "/home/hsakulin/jtag_test2/AddressTable_Outcard.txt";
 
   try {
 
diff --git a/psx/watchdog/include/psx/watchdog/Application.h b/psx/watchdog/include/psx/watchdog/Application.h
index 555121a6e..969ccd4cb 100644
--- a/psx/watchdog/include/psx/watchdog/Application.h
+++ b/psx/watchdog/include/psx/watchdog/Application.h
@@ -45,7 +45,7 @@ namespace psx {
 			bool ping();
 			void kill();
 			std::string prepareKillLine(xdaq::ApplicationDescriptor* psxDesc, const xdaq::ApplicationDescriptor* watchdogDesc) ;
-			std::string prepareRestartLine(xdaq::ApplicationDescriptor* psxDesc, const xdaq::ApplicationDescriptor* watchdogDesc) throw(psx::watchdog::exception::Exception);
+			std::string prepareRestartLine(xdaq::ApplicationDescriptor* psxDesc, const xdaq::ApplicationDescriptor* watchdogDesc); 
 			void createPingMessage(const xoap::MessageReference& msg);
 			void createPSXDescriptor(xdaq::ApplicationDescriptor*& psxDesc, xdaq::ContextDescriptor*& psxContext) ;
 
diff --git a/psx/watchdog/src/common/Application.cc b/psx/watchdog/src/common/Application.cc
index 26a0bcc46..707a4d740 100644
--- a/psx/watchdog/src/common/Application.cc
+++ b/psx/watchdog/src/common/Application.cc
@@ -438,7 +438,7 @@ std::string psx::watchdog::Application::prepareKillLine(xdaq::ApplicationDescrip
 	return pkill;
 }
 
-std::string psx::watchdog::Application::prepareRestartLine(xdaq::ApplicationDescriptor* psxDesc, const xdaq::ApplicationDescriptor* watchdogDesc) throw(psx::watchdog::exception::Exception)
+std::string psx::watchdog::Application::prepareRestartLine(xdaq::ApplicationDescriptor* psxDesc, const xdaq::ApplicationDescriptor* watchdogDesc)
 {
 	std::string zone;
 	std::string restartline = "";
diff --git a/sentinel/arc/include/sentinel/arc/Application.h b/sentinel/arc/include/sentinel/arc/Application.h
index 44f7759b3..b4cf0aa50 100755
--- a/sentinel/arc/include/sentinel/arc/Application.h
+++ b/sentinel/arc/include/sentinel/arc/Application.h
@@ -89,12 +89,12 @@ namespace sentinel
 
 
 				// restful
-				void getNode (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception);
-				void getException (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception);
-				void getExceptionList (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception);
-				void getModelTree (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception);
-				void accept (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception);
-				void clear (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception);
+				void getNode (xgi::Input * in, xgi::Output * out);
+				void getException (xgi::Input * in, xgi::Output * out);
+				void getExceptionList (xgi::Input * in, xgi::Output * out);
+				void getModelTree (xgi::Input * in, xgi::Output * out);
+				void accept (xgi::Input * in, xgi::Output * out);
+				void clear (xgi::Input * in, xgi::Output * out);
 
 			protected:
 				void getExceptionList (json_t * jsonvector, sentinel::arc::utils::Node::ExceptionMap & exceptionsMap, const std::string & exceptionState);
diff --git a/sentinel/arc/src/common/Application.cc b/sentinel/arc/src/common/Application.cc
index 3b9a72161..adcd065e6 100755
--- a/sentinel/arc/src/common/Application.cc
+++ b/sentinel/arc/src/common/Application.cc
@@ -477,7 +477,7 @@ std::list<std::string> sentinel::arc::Application::getAlarmStoreNames()
 }
 
 //RESTful
-void sentinel::arc::Application::getNode (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception)
+void sentinel::arc::Application::getNode (xgi::Input * in, xgi::Output * out)
 {
 	int nodeID = 1; // default root
 
@@ -503,7 +503,7 @@ void sentinel::arc::Application::getNode (xgi::Input * in, xgi::Output * out) th
 	json_decref(document);
 }
 
-void sentinel::arc::Application::getException (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception)
+void sentinel::arc::Application::getException (xgi::Input * in, xgi::Output * out)
 {
 	std::string exceptionID;
 
@@ -542,7 +542,7 @@ void sentinel::arc::Application::getException (xgi::Input * in, xgi::Output * ou
 	*out << blobStr;
 }
 
-void sentinel::arc::Application::getExceptionList (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception)
+void sentinel::arc::Application::getExceptionList (xgi::Input * in, xgi::Output * out)
 {
 	int nodeID = 1; // default root
 	std::set<std::string> states;
@@ -575,7 +575,7 @@ void sentinel::arc::Application::getExceptionList (xgi::Input * in, xgi::Output
 
 
 
-void sentinel::arc::Application::getModelTree (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception)
+void sentinel::arc::Application::getModelTree (xgi::Input * in, xgi::Output * out)
 {
 	json_t* document = this->model_->getModelTree();
 
@@ -590,7 +590,7 @@ void sentinel::arc::Application::getModelTree (xgi::Input * in, xgi::Output * ou
 
 
 
-void sentinel::arc::Application::clear (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception)
+void sentinel::arc::Application::clear (xgi::Input * in, xgi::Output * out)
 {
 	try
 	{
@@ -678,7 +678,7 @@ void sentinel::arc::Application::clear (xgi::Input * in, xgi::Output * out) thro
 	out->getHTTPResponseHeader().addHeader("Cache-Control", "max-age=60");
 }
 
-void sentinel::arc::Application::accept (xgi::Input * in, xgi::Output * out) throw (xgi::exception::Exception)
+void sentinel::arc::Application::accept (xgi::Input * in, xgi::Output * out)
 {
 	try
 	{
diff --git a/sentinel/arc/utils/src/common/AlarmStore.cc b/sentinel/arc/utils/src/common/AlarmStore.cc
index 21f233665..03aba1686 100644
--- a/sentinel/arc/utils/src/common/AlarmStore.cc
+++ b/sentinel/arc/utils/src/common/AlarmStore.cc
@@ -1193,18 +1193,15 @@ void sentinel::arc::utils::AlarmStore::revoke (xcept::Exception& ex)
 // for fire event this identify the originator
 	properties.setProperty("source", ex.getProperty("notifier"));
 
-	std::vector < xcept::ExceptionInformation > &history = ex.getHistory();
-	std::vector<xcept::ExceptionInformation>::reverse_iterator ri = history.rbegin();
+	xcept::Exception::const_reverse_iterator ri = ex.rbegin();
 	std::stringstream blob;
-	while (ri != history.rend())
+	while (ri != ex.rend())
 	{
-		std::map<std::string, std::string, std::less<std::string> >& p = (*ri).getProperties();
-		std::map<std::string, std::string, std::less<std::string> >::iterator mi;
-		mi = p.begin();
-		while (mi != p.end())
+		std::map<std::string, std::string, std::less<std::string> >::const_iterator mi = (*ri).begin();
+		while (mi != (*ri).end())
 		{
 			// if leading exception then keep properties
-			if (ri == history.rbegin())
+			if (ri == ex.rbegin())
 			{
 				properties.setProperty((*mi).first, (*mi).second);
 			}
@@ -1337,21 +1334,18 @@ void sentinel::arc::utils::AlarmStore::fire (xcept::Exception& ex)
 			// for fire event this identify the originator
 			properties.setProperty("source", ex.getProperty("notifier"));
 
-			std::vector < xcept::ExceptionInformation > &history = ex.getHistory();
-			std::vector<xcept::ExceptionInformation>::reverse_iterator ri = history.rbegin();
+			xcept::Exception::const_reverse_iterator ri = ex.rbegin();
 			std::stringstream blob;
 			blob << "{";
-			while (ri != history.rend())
+			while (ri != ex.rend())
 			{
-				std::map<std::string, std::string, std::less<std::string> >& p = (*ri).getProperties();
-				blob << "\"label\":\"" << p["identifier"] << "\",";
+				blob << "\"label\":\"" << (*ri).getProperty("identifier") << "\",";
 				blob << "\"properties\":[";
-				std::map<std::string, std::string, std::less<std::string> >::iterator mi;
-				mi = p.begin();
-				while (mi != p.end())
+				std::map<std::string, std::string, std::less<std::string> >::const_iterator mi = (*ri).begin();
+				while (mi != (*ri).end())
 				{
 					// if leading exception then keep properties
-					if (ri == history.rbegin())
+					if (ri == ex.rbegin())
 					{
 						properties.setProperty((*mi).first, (*mi).second);
 
@@ -1367,20 +1361,20 @@ void sentinel::arc::utils::AlarmStore::fire (xcept::Exception& ex)
 					}
 
 					++mi;
-					if (mi != p.end())
+					if (mi != (*ri).end())
 					{
 						blob << ",";
 					}
 				}
 				++ri;
 				blob << "]";
-				if (ri != history.rend())
+				if (ri != ex.rend())
 				{
 					blob << ",\"children\":[{";
 				}
 			}
 
-			for (size_t s = 0; s < (history.size() - 1); ++s)
+			for (size_t s = 0; s < (ex.size() - 1); ++s)
 			{
 				blob << "}]";
 			}
diff --git a/sentinel/spotlight2g/src/common/DataBase.cc b/sentinel/spotlight2g/src/common/DataBase.cc
index 927cb8ffa..e36334041 100755
--- a/sentinel/spotlight2g/src/common/DataBase.cc
+++ b/sentinel/spotlight2g/src/common/DataBase.cc
@@ -974,23 +974,20 @@ void sentinel::spotlight2g::DataBase::revoke (xcept::Exception& ex)
 
 	std::stringstream storeTimeStream;
 	storeTimeStream <<  std::fixed << std::setprecision(6) << (double)lastExceptionTime_;
-    properties.setProperty("storeTime", storeTimeStream.str());
+    	properties.setProperty("storeTime", storeTimeStream.str());
 
-    // for fire event this identify the originator
+    	// for fire event this identify the originator
 	properties.setProperty("source", ex.getProperty("notifier") );
 
-	std::vector<xcept::ExceptionInformation> & history = ex.getHistory();
-	std::vector<xcept::ExceptionInformation>::reverse_iterator ri = history.rbegin();
+	xcept::Exception::const_reverse_iterator ri = ex.rbegin();
 	std::stringstream blob;
-	while ( ri != history.rend() )
+	while ( ri != ex.rend() )
 	{
-		std::map<std::string, std::string, std::less<std::string> >& p = (*ri).getProperties();			
-		std::map<std::string, std::string, std::less<std::string> >::iterator mi;		
-		mi = p.begin();
-		while (mi != p.end())
+		std::map<std::string, std::string, std::less<std::string> >::const_iterator mi = (*ri).begin();		
+		while (mi != (*ri).end())
 		{
 			// if leading exception then keep properties 
-			if ( ri ==  history.rbegin())
+			if ( ri ==  ex.rbegin())
 			{
 				properties.setProperty((*mi).first,(*mi).second);
 			}
@@ -1065,21 +1062,18 @@ void sentinel::spotlight2g::DataBase::store (xcept::Exception& ex)
     // for fire event this identify the originator
 	properties.setProperty("source", ex.getProperty("notifier") );
 
-	std::vector<xcept::ExceptionInformation> & history = ex.getHistory();
-	std::vector<xcept::ExceptionInformation>::reverse_iterator ri = history.rbegin();
+	xcept::Exception::const_reverse_iterator ri = ex.rbegin();
 	std::stringstream blob;
 	blob << "{";
-	while ( ri != history.rend() )
+	while ( ri != ex.rend() )
 	{
-		std::map<std::string, std::string, std::less<std::string> >& p = (*ri).getProperties();			
-		blob << "\"label\":\"" << p["identifier"] << "\",";		
+		blob << "\"label\":\"" << (*ri).getProperty("identifier") << "\",";		
 		blob << "\"properties\":["; 
-		std::map<std::string, std::string, std::less<std::string> >::iterator mi;		
-		mi = p.begin();
-		while (mi != p.end())
+		std::map<std::string, std::string, std::less<std::string> >::const_iterator mi = (*ri).begin();		
+		while (mi != (*ri).end())
 		{
 			// if leading exception then keep properties 
-			if ( ri ==  history.rbegin())
+			if ( ri ==  ex.rbegin())
 			{
 				properties.setProperty((*mi).first,(*mi).second);
 
@@ -1095,20 +1089,20 @@ void sentinel::spotlight2g::DataBase::store (xcept::Exception& ex)
 			}
 			
 			++mi;
-			if (mi != p.end())
+			if (mi != (*ri).end())
 			{
 				blob << ",";
 			}
 		}		
 		++ri;
 		blob << "]";
-		if (ri != history.rend())
+		if (ri != ex.rend())
 		{
 			blob << ",\"children\":[{";
 		}
 	}
 	
-	for (size_t s = 0; s < (history.size()-1); ++s)
+	for (size_t s = 0; s < (ex.size()-1); ++s)
 	{
 		blob << "}]";
 	}
diff --git a/sentinel/spotlightocci/src/common/DataBase.cc b/sentinel/spotlightocci/src/common/DataBase.cc
index 2c4eed324..20cfb975f 100755
--- a/sentinel/spotlightocci/src/common/DataBase.cc
+++ b/sentinel/spotlightocci/src/common/DataBase.cc
@@ -1216,18 +1216,15 @@ void sentinel::spotlightocci::DataBase::revoke (xcept::Exception& ex)
     // for fire event this identify the originator
 	properties.setProperty("source", ex.getProperty("notifier") );
 
-	std::vector<xcept::ExceptionInformation> & history = ex.getHistory();
-	std::vector<xcept::ExceptionInformation>::reverse_iterator ri = history.rbegin();
+	xcept::Exception::const_reverse_iterator ri = ex.rbegin();
 	std::stringstream blob;
-	while ( ri != history.rend() )
+	while ( ri != ex.rend() )
 	{
-		std::map<std::string, std::string, std::less<std::string> >& p = (*ri).getProperties();			
-		std::map<std::string, std::string, std::less<std::string> >::iterator mi;		
-		mi = p.begin();
-		while (mi != p.end())
+		std::map<std::string, std::string, std::less<std::string> >::const_iterator mi = (*ri).begin();		
+		while (mi != (*ri).end())
 		{
 			// if leading exception then keep properties 
-			if ( ri ==  history.rbegin())
+			if ( ri ==  ex.rbegin())
 			{
 				properties.setProperty((*mi).first,(*mi).second);
 			}
@@ -1468,21 +1465,18 @@ void sentinel::spotlightocci::DataBase::fire (xcept::Exception& ex)
 			// for fire event this identify the originator
 			properties.setProperty("source", ex.getProperty("notifier"));
 
-			std::vector < xcept::ExceptionInformation > &history = ex.getHistory();
-			std::vector<xcept::ExceptionInformation>::reverse_iterator ri = history.rbegin();
+			xcept::Exception::const_reverse_iterator ri = ex.rbegin();
 			std::stringstream blob;
 			blob << "{";
-			while (ri != history.rend())
+			while (ri != ex.rend())
 			{
-				std::map<std::string, std::string, std::less<std::string> >& p = (*ri).getProperties();
-				blob << "\"label\":\"" << p["identifier"] << "\",";
+				blob << "\"label\":\"" << (*ri).getProperty("identifier") << "\",";
 				blob << "\"properties\":[";
-				std::map<std::string, std::string, std::less<std::string> >::iterator mi;
-				mi = p.begin();
-				while (mi != p.end())
+				std::map<std::string, std::string, std::less<std::string> >::const_iterator mi = (*ri).begin();
+				while (mi != (*ri).end())
 				{
 					// if leading exception then keep properties
-					if (ri == history.rbegin())
+					if (ri == ex.rbegin())
 					{
 						properties.setProperty((*mi).first, (*mi).second);
 
@@ -1498,20 +1492,20 @@ void sentinel::spotlightocci::DataBase::fire (xcept::Exception& ex)
 					}
 
 					++mi;
-					if (mi != p.end())
+					if (mi != (*ri).end())
 					{
 						blob << ",";
 					}
 				}
 				++ri;
 				blob << "]";
-				if (ri != history.rend())
+				if (ri != ex.rend())
 				{
 					blob << ",\"children\":[{";
 				}
 			}
 
-			for (size_t s = 0; s < (history.size() - 1); ++s)
+			for (size_t s = 0; s < (ex.size() - 1); ++s)
 			{
 				blob << "}]";
 			}
diff --git a/tstore/client/src/common/LoadDOM.cc b/tstore/client/src/common/LoadDOM.cc
index ccfb3d6dc..d2089fd69 100755
--- a/tstore/client/src/common/LoadDOM.cc
+++ b/tstore/client/src/common/LoadDOM.cc
@@ -141,7 +141,7 @@ std::string tstoreclient::writeXML(DOMNode *pDoc)  {
 		}
 		return xml.str();
 		delete target;
-	} catch (xcept::Exception) {
+	} catch (xcept::Exception &) {
 		if (target) delete target;
 		throw;
 	}
diff --git a/tstore/src/common/SQLView.cc b/tstore/src/common/SQLView.cc
index d49c127aa..5485436d1 100755
--- a/tstore/src/common/SQLView.cc
+++ b/tstore/src/common/SQLView.cc
@@ -237,7 +237,7 @@ void tstore::SQLView::addTables(TStoreAPI *API)  {
 			}
 		}
 		tstore::View::addTables(API); //add tables to the database. Do this last, so that we don't have to drop them if something else fails.
-	} catch (tstore::exception::Exception) {
+	} catch (const tstore::exception::Exception & ) {
 		//remove the configuration we added in memory
 		for (std::vector<std::string>::iterator addedSubview=subviewsAdded.begin();addedSubview!=subviewsAdded.end();++addedSubview) {
 			removeSubviewWithName(*addedSubview);
diff --git a/tstore/src/common/TStore.cc b/tstore/src/common/TStore.cc
index 5de95887e..633c2cfb2 100755
--- a/tstore/src/common/TStore.cc
+++ b/tstore/src/common/TStore.cc
@@ -591,16 +591,16 @@ tstore::Connection* tstore::TStore::connectionFromMessage(xoap::MessageReference
 }
 
 void tstore::TStore::addFault(xcept::Exception &e,const std::string &task)  {
-	xcept::ExceptionHistory exHistory(e);
 	string msg = "Failed to '" + task + "'";
 
-	while(exHistory.hasMore()) {
-		xcept::ExceptionInformation& exInfo = exHistory.getPrevious();
-
-		msg += "<-- " + exInfo.getProperty("message") +
-			" raised at " + exInfo.getProperty("function") +
-			"(" +  exInfo.getProperty("module") +
-			":" + exInfo.getProperty("line") + ")";
+	xcept::Exception::const_reverse_iterator ri = e.rbegin();
+	while ( ri != e.rend() )
+	{
+		 msg += "<-- " + (*ri).getProperty("message") +
+                        " raised at " + (*ri).getProperty("function") +
+                        "(" +  (*ri).getProperty("module") +
+                        ":" + (*ri).getProperty("line") + ")";
+		++ri;
 	}
 
 	LOG4CPLUS_ERROR(this->getApplicationLogger(), msg);
diff --git a/tstore/src/common/View.cc b/tstore/src/common/View.cc
index 7289c88a5..ba435b8a9 100755
--- a/tstore/src/common/View.cc
+++ b/tstore/src/common/View.cc
@@ -28,7 +28,7 @@ DOMNode *tstore::View::getConfiguration(std::string configurationPath)  {
 			}
 		}
 		return NULL;
-	} catch (xoap::exception::Exception) {
+	} catch (const xoap::exception::Exception &) {
 		return NULL;
 	}
 }
diff --git a/tstore/utils/include/tstore/Connection.h b/tstore/utils/include/tstore/Connection.h
index f58967dc2..35703ef52 100755
--- a/tstore/utils/include/tstore/Connection.h
+++ b/tstore/utils/include/tstore/Connection.h
@@ -90,7 +90,7 @@ class Connection: public toolbox::Properties {
 	void attemptRollback() {
 		try {
 			rollback();
-		} catch (tstore::exception::Exception) {
+		} catch (tstore::exception::Exception &) {
 			;
 		}
 	}
diff --git a/tstore/utils/src/common/OracleConnection.cc b/tstore/utils/src/common/OracleConnection.cc
index e00fdcc5d..0bedfadf5 100755
--- a/tstore/utils/src/common/OracleConnection.cc
+++ b/tstore/utils/src/common/OracleConnection.cc
@@ -1091,7 +1091,7 @@ void tstore::OracleConnection::setStatementParameter(oracle::occi::Statement *st
 		std::string valueAsString;
 		try {
 			valueAsString=value->toString();
-		} catch (xdata::exception::Exception) {
+		} catch (xdata::exception::Exception &) {
 			valueAsString="(cannot display value)";
 		}
 		std::ostringstream error;
@@ -2344,7 +2344,7 @@ void tstore::OracleConnection::copyResultsToTable(oracle::occi::ResultSet *rs,xd
 				try {
 					results.setValueAt(rowIndex,(*columnIterator).getString(oracle::occi::MetaData::ATTR_NAME),*value);
 					delete value;
-				} catch (xdata::exception::Exception e) {
+				} catch (xdata::exception::Exception & e) {
 					if (value) delete value;
 					//deleteValueBuffers(currentRow);//reduce reallocation
 					std::ostringstream error;
@@ -2395,7 +2395,7 @@ void tstore::OracleConnection::execute(tstore::SQLQuery &query,xdata::Table &res
 		    << "-- total: "              <<   ((float)totalT.sec() + ((float)totalT.millisec())*.001)
 		    << std::endl;
 		out.close();*/
-	} catch (tstore::exception::Exception) {
+	} catch (tstore::exception::Exception &) {
 		if (resultset) statement->closeResultSet(resultset);
 		terminateStatement(statement);
 		throw;
diff --git a/ttc/Makefile b/ttc/Makefile
old mode 100644
new mode 100755
index d6ed0a9d2..d705250c3
--- a/ttc/Makefile
+++ b/ttc/Makefile
@@ -1,14 +1,28 @@
 BUILD_HOME:=$(shell pwd)/..
 
-include $(XDAQ_ROOT)/config/mfAutoconf.rules
-include $(XDAQ_ROOT)/config/mfDefs.$(XDAQ_OS)
+ifndef BUILD_SUPPORT
+  BUILD_SUPPORT=build
+endif
+export BUILD_SUPPORT
+
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfAutoconf.rules
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfDefs.$(XDAQ_OS)
+
+PROJECT_NAME=worksuite
 
 Project=daq
 
-Packages= \
+ifndef PACKAGES
+  PACKAGES= \
 	ttc/utils \
 	ttc/monitoring \
+	ttc/ltc \
 	ttc/ttcci
+endif
+export PACKAGES
+
+Project=$(PROJECT_NAME)
+Packages=$(PACKAGES)
 
-include $(XDAQ_ROOT)/config/Makefile.rules
-include $(XDAQ_ROOT)/config/mfRPM.rules
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/Makefile.rules
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfRPM.rules
diff --git a/ttc/ltc/Makefile b/ttc/ltc/Makefile
new file mode 100755
index 000000000..0678fa2fb
--- /dev/null
+++ b/ttc/ltc/Makefile
@@ -0,0 +1,55 @@
+BUILD_HOME:=$(shell pwd)/../..
+
+BUILD_SUPPORT=build
+PROJECT_NAME=worksuite
+
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfAutoconf.rules
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfDefs.$(XDAQ_OS)
+include $(BUILD_HOME)/mfDefs.$(PROJECT_NAME)
+
+Project=$(PROJECT_NAME)
+Package=ttc/ltc
+PackageName=ttcltc
+
+Sources=\
+	version.cc \
+	LTC.cc \
+	LTCConfiguration.cc \
+	LTCEvent.cc \
+	LTCControl.cc \
+	LTCControlSoapHandler.cc \
+	LTCAddresses.cc \
+	Monitoring.cc \
+	LTCStatusInfo.cc \
+	TriggerComposition.cc \
+	StateChanges.cc
+
+IncludeDirs = \
+	$(XERCES_INCLUDE_PREFIX) \
+	$(LOG4CPLUS_INCLUDE_PREFIX) \
+	$(CGICC_INCLUDE_PREFIX) \
+	$(XCEPT_INCLUDE_PREFIX) \
+	$(CONFIG_INCLUDE_PREFIX) \
+	$(TOOLBOX_INCLUDE_PREFIX) \
+	$(XDAQ_INCLUDE_PREFIX) \
+	$(XDATA_INCLUDE_PREFIX) \
+	$(XOAP_INCLUDE_PREFIX) \
+	$(XGI_INCLUDE_PREFIX) \
+	$(HAL_INCLUDE_PREFIX) \
+	$(PT_INCLUDE_PREFIX) \
+	$(TTC_UTILS_INCLUDE_PREFIX) \
+	$(TTC_MONITORING_INCLUDE_PREFIX)
+
+UserCCFlags = -g -Werror
+
+DependentLibraryDirs = \
+	$(TTC_UTILS_LIB_PREFIX) \
+	$(TTC_MONITORING_LIB_PREFIX)
+
+DependentLibraries = ttcutils
+
+DynamicLibrary= ttcltc
+
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/Makefile.rules
+include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfRPM.rules
+
diff --git a/ttc/ltc/images/ltccontrol.gif b/ttc/ltc/images/ltccontrol.gif
new file mode 100644
index 000000000..ac6f322d5
Binary files /dev/null and b/ttc/ltc/images/ltccontrol.gif differ
diff --git a/ttc/ltc/include/ttc/ltc/LTC.hh b/ttc/ltc/include/ttc/ltc/LTC.hh
new file mode 100755
index 000000000..5ed3b8138
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTC.hh
@@ -0,0 +1,529 @@
+#ifndef _ttc_ltc_LTC_hh_
+#define _ttc_ltc_LTC_hh_
+
+
+#include "ttc/utils/GenericTTCModule.hh"
+
+#include "ttc/ltc/Monitoring.hh"
+#include "ttc/ltc/LTCStatusInfo.hh"
+#include "ttc/utils/BGOChannel.hh"
+#include "ttc/utils/CyclicTriggerOrBGO.hh"
+
+#include <string>
+
+
+#define LTC_RESET_BGOS 2
+#define LTC_RESET_ORBIT 4
+#define LTC_RESET_EVENT 8
+#define LTC_RESET_TRIGGER 16
+#define LTC_RESET_BLOCKED 32
+#define LTC_RESET_CANCELLED 256
+#define LTC_RESET_ALLCOUNTERS 0x13e
+
+
+namespace HAL
+{
+class VMEBusAdapterInterface;
+}
+
+
+//! exception thrown by CheckBXConflicts
+XCEPT_DEFINE_EXCEPTION(ttc, BXConflictsDetected);
+
+
+namespace ttc
+{
+
+class RAMTriggers;
+class BGOMap;
+
+struct PeriodicThreadPars
+{
+  bool newSetup;
+  double waitNsec;
+  double enabled;
+  time_t t0, t1;
+};
+
+struct GPSTimeThreadPars
+{
+  bool newSetup;
+  double waitNsec;
+  double enabled;
+  time_t t0, t1;
+};
+
+struct MonitoringThreadPars
+{
+  bool newSetup;
+  double waitNsec;
+  double enabled;
+  time_t t0, t1;
+};
+
+struct StatusParameters
+{
+  bool newSetup;
+  double waitNsec;
+  double enabled;
+  time_t t0, t1;
+};
+
+struct LTCThreadPars
+{
+  bool newSetup;
+  LTC* myLTC;
+  MonitoringThreadPars Monitoring;
+  GPSTimeThreadPars GPS;
+  PeriodicThreadPars Periodic;
+  StatusParameters Parameters;
+};
+
+/**
+ * Represents an LTC card, and all the operations that may be performed on it.
+ */
+class LTC : public GenericTTCModule
+{
+  // Classes which need access to private items.
+  friend class LTCConfiguration;
+  friend class LTCConfigurationItem_RunLog;
+  friend class LTCConfigurationItem_FifoDump;
+  friend class LTCConfigurationItem_CyclicTriggerOrBgo;
+  friend class LTCOrbitJumps;
+
+public:
+
+  /**
+   * The LTC constructor. Scans the crate looking for an LTC card.
+   * If there is not exactly one enabled LTC in the crate,
+   * the plug-n-play code will throw a logic_error exception.
+   *
+   * @param bus A reference to a bus adapter to communicate with the LTC.
+   * @param useSingleWordBlockTransfer if true, block transfers will be split into single word accesses.
+   */
+  LTC(
+      HAL::VMEBusAdapterInterface& bus,
+      int location,
+      uint32_t btimecorr,
+      bool enable_vme_writes_,
+      uint32_t slinkSrcId = 815);
+
+  virtual ~LTC();
+
+  virtual std::string firmwareVersionString();
+
+  //! Returns the numeric LTC firmware version.
+  uint32_t ReadFirmwareVersion() const;
+
+  //! Returns the lower 16 bits of ReadFirmwareVersion().
+  uint32_t GetFirmwareVersion() const;
+
+  //! Reads the Board ID and returns it.
+  uint32_t GetBoardID() const;
+
+  size_t NChannels() const;
+
+  void ExecuteVMEBGO(const int8_t ibgo, const int32_t BX = -1);
+
+  void ExecuteVMETrigger();
+
+  uint32_t GetSlinkSrcId() const;
+
+  void StartCyclicGenerators();
+
+  void StopCyclicGenerators();
+
+  //! Like StopCyclicGenerators() but also stop the ones configured as 'permanent'.
+  void StopAllCyclicGenerators();
+
+  void StartPermanentCyclicGenerators();
+
+  void SendControlWord();
+
+  uint32_t GetControlWord() const;
+
+  uint32_t ReadControlWord() const;
+
+  uint32_t GetVMEBGOBX() const;
+
+  void SetVMEBX(const uint32_t bx);
+
+  //! Configure the LTC.
+  virtual void Configure(std::istream &in);
+
+  /**
+   * Writes the current configuration to the stream 'out'.
+   * Adds lots of comments to the configuration text.
+   */
+  virtual void WriteConfiguration(std::ostream& out, const std::string& comment = "");
+
+  virtual void ExecuteSequence(const std::string& identifier);
+
+  virtual void ExecuteSequenceLine(const std::string& line);
+
+  void failParseSequenceLineInvalidParam(
+      const std::string& line,
+      const std::string& command,
+      const std::string& param);
+
+  RAMTriggers* GetRAMTriggers();
+
+  BGOChannel* GetBGOChannel(const size_t channel);
+
+  void SetQPLLExternal(bool external);
+
+  bool IsQPLLExternal() const;
+
+  /**
+   * If called with doReset == true,
+   * this will clear the reset state after a given delay (0.1 s)
+   */
+  void ResetQPLL(bool doReset);
+
+  bool Is_ResetQPLL() const;
+
+  void AutoRestartQPLL(bool enable);
+
+  bool Is_AutoRestartQPLL() const;
+
+  void SetQPLLFrequencyBits(uint32_t freq, bool only4LSBs = false);
+
+  uint32_t GetQPLLFrequencyBits() const;
+
+  uint32_t ReadEventCounter() const;
+
+  uint32_t ReadTriggerCounter() const;
+
+  uint32_t ReadOrbitCounter() const;
+
+  uint32_t ReadStrobeCounter() const;
+
+  uint32_t ReadBlockedTriggersCounter() const;
+
+  uint32_t BoardStatus() const;
+
+  void ResetCounters(unsigned counters = LTC_RESET_ALLCOUNTERS & ~LTC_RESET_TRIGGER);
+
+  void ResetEventFIFO();
+
+  void MainReset();
+
+  bool IsExternalTriggerEnabled(const size_t i) const;
+
+  void EnableExternalTrigger(const size_t i, const bool Enable = true);
+
+  void SetL1ATicket(unsigned num); // set size of trigger burst (0=disable)
+
+  unsigned GetL1ATicket() const;
+
+  unsigned GetMaxTrigger() const;
+
+  void SendL1ATicket();
+
+  //! Start the triggers which are generated from a pattern stored in internal RAM.
+  void StartRAMTrigs();
+
+  //! Stop the triggers which are generated from a pattern stored in internal RAM.
+  void StopRAMTrigs();
+
+  bool IsCyclicTrigEnabled() const;
+
+  void EnableCyclicTrig(bool enable = true);
+
+  bool IsRAMTrigEnabled() const;
+
+  void EnableRAMTrig(bool enable = true);
+
+  /**
+   * Enables/disables L1A.
+   * Note: It seems this also needs to be called in order to to
+   * enable non-permanent cyclic BGO (!) generators.
+   */
+  void EnableL1A(const bool enable = true);
+
+  bool IsL1AEnabled() const;
+
+  bool OrbitInSync() const;
+
+  uint32_t CancelledTriggers() const;
+
+  /**
+   * Checks whether any of the bunch crossings at which BGOs shall be sent
+   * (e.g. from VME or cyclic triggers) are too close to each other.
+   * Thrown ttc::exception::BXConflictsDetected in case of conflicts found, else returns normally.
+   */
+  void CheckBXConflicts();
+
+  bool PeriodicSequenceEnabled() const;
+
+  double Periodicity() const;
+
+  //! Returns the number of cyclic trigger generators.
+  size_t NCyclicTrigger() const;
+
+  //! Returns the number of cyclic BGO generators.
+  size_t NCyclicBGO() const;
+
+  CyclicTriggerOrBGO* GetCyclic(const bool trigger, const size_t i);
+
+  //! Reads all cyclic generators back from the LTC.
+  void ReadAllCyclicGeneratorsFromLTC();
+
+  /**
+   * @param trigger Defines whether this is a trigger (true) or a BGO cyclic generator (false).
+   * @param i The number of the generator.
+   */
+  void WriteCyclicGeneratorToLTC(const bool trigger, const size_t i);
+
+  void ResetCyclicGenerators(const bool trigger, const bool bgo);
+
+  void SetTriggerRule(size_t ntrig, uint32_t minDeltaBX);
+
+  uint32_t GetTriggerRule(size_t ntrig) const;
+
+  size_t FirstTriggerRule() const;
+
+  size_t TriggerRuleSize() const;
+
+  size_t Nextern() const;
+
+  //! Returns the number of 'events' which are in the Event Fifo (?).
+  unsigned int GetFIFOLevel() const;
+
+  bool GetFIFOEvents(LTCEventFIFO & ret);
+
+  //! Reads the TTS status register and returns its content.
+  uint32_t ReadTTSStatus() const;
+
+  std::string TTSStatusSummary(size_t& mask) const;
+
+  size_t NTTS() const;
+
+  bool IsTTSEnabled(const size_t idx) const;
+
+  void EnableTTS(const size_t idx, const bool Enable = true);
+
+  void EnableBSTGPSviaVME(bool Enable = true);
+
+  bool IsBSTGPSviaVME() const;
+
+  double GetBSTGPSInterval() const;
+
+  void SetBSTGPS(const uint32_t GPSlow, const uint32_t GPShigh);
+
+  void IgnoreSlinkBackpressure(bool Ignore = true);
+
+  bool IsSlinkBackpressureIgnored() const;
+
+  void UpdateMonitoring();
+
+  void EnableMonitoring(const bool enable = true);
+
+  bool IsMonitoringEnabled() const;
+
+  void SetMonitoringInterval(const double dt);
+
+  double GetMonitoringInterval() const;
+
+  uint32_t IncrementRunNumber(bool dontIncrement = false);
+
+  uint32_t GetRunNumber() const;
+
+  void SetRunNumber(const uint32_t run);
+
+  Monitoring* GetMonitoring();;
+
+  void SetBXMask(const bool enable, const size_t begin, const size_t end = 9999);
+
+  void BXMaskReset();
+
+  void GetBXGaps(std::vector<size_t> &begin, std::vector<size_t> &end) const;
+
+  double GetActiveBXFraction() const;
+
+  uint32_t ReadSLinkStatus() const;
+
+  uint32_t ReadSLinkStatus(std::string &status, const bool usehtmlstyle = false) const;
+
+  uint32_t GetWarningInterval() const;
+
+  void SetWarningInterval(const uint32_t pause);
+
+  void SetHWInputDelays(const std::vector<float> &delays);
+
+  std::vector<float> GetHWInputDelays() const;
+
+  void DumpEventFIFO(std::ostream *oo = NULL, bool html = false);
+
+  std::string GetTriggerName(const size_t i) const;
+
+  void SetTriggerName(const size_t i, const std::string &name);
+
+  bool IsClockLocked() const;
+
+  uint32_t GetBTimeCorrection() const;
+
+  const LTCStatusInfo *GetLTCStatusInfo() const;
+
+  void UpdateLTCStatusInfo();
+
+  bool DumpEventFIFOToFile() const;
+
+  bool DefaultFIFODumpEnabled() const;
+
+  std::string FIFODumpPrefix() const;
+
+  std::string EventFIFOToFilePath() const;
+
+  void SetFilePathForFIFODump(const bool enable, const std::string &newpath);
+
+  /**
+   * Don't call this method unless you want to get an output frequency around 32 MHz
+   * and thus the TTCci unlocked (in an interconnection test).
+   */
+  void SetExternalCrystalTo160MHz(bool externalQuarzIs160MHz);
+
+  //! Sets the S-Link source ID for the LTC
+  void SetSlinkSrcId(uint32_t);
+
+  //! Sets the internal trigger frequency. PUBLIC for Tracker.
+  void SetInternalTriggerFrequency(const double frequency, bool random = 0);
+
+private:
+
+  //! Creates (starts) the parallel thread which e.g. does updating the GPS time via VME etc.
+  void CreateParallelThread();
+
+  /** This flag must be read by threads spawned. If this is true,
+   they should terminate as soon as possible. */
+  bool stop_thread_flag;
+
+  friend void* ParallelThread(void *);
+
+  RAMTriggers* ram_triggers;
+
+  //! Returns information about which TTS inputs were enabled (not the actual input signals).
+  size_t GetTTSStatus_Pattern(size_t idx) const;
+
+  //! Returns the date when the firmware was built (the upper 16 bits of ReadFirmwareVersion()).
+  uint32_t GetFirmwareBuiltNumber() const;
+
+  void PrintBoardStatus() const;
+
+  //! Stop the cyclic generators configured as 'permanent'.
+  void ResetInternalTrigsAndAllCyclicGenerators();
+
+  /**
+   * Determines the B channel names (which depends on the BGO map).
+   * This should be called whenever the BGO map has changed.
+   */
+  void SetBChannelNames();
+
+  void ReadChannelStatus(
+      const size_t channel,
+      uint32_t& signalcounter,
+      bool& anycancelled,
+      uint32_t& cancelcounter,
+      bool& ramempty) const;
+
+  CyclicTriggerOrBGO* ReadCyclicGeneratorFromLTC(const bool trigger, const size_t i);
+
+  /**
+   * Same as the TTSStatusSummary command but without the
+   * possibility of getting the mask back (for convenience mostly, e.g. from python).
+   */
+  std::string TTSStatusSummary() const;
+
+  void SetBSTGPSInterval(const double dt);
+
+  //! returns the number of microseconds since 1.1.1970
+  uint64_t GetBSTGPSTime() const;
+
+  //! Returns the number of seconds since 1.1.1970.
+  unsigned GetBSTGPSTimeSeconds() const;
+
+  void ReadBSTGPS(uint32_t &GPSlow, uint32_t &GPShigh) const;
+
+  //! Returns true if the slink status is 'full' which corresponds to backpressure.
+  bool HasSlinkBackPressure() const;
+
+  void EnableGPSFromVME(const bool enable = true);
+
+  void EnableCurrentRatesUpdate(bool enable = true);
+
+  void EnablePeriodicSequence(bool enable = true);
+
+  const Monitoring* GetMonitoring() const;
+
+  std::string GetRunLogPath() const;
+
+  void WriteRunLog() const;
+
+
+  //! Front Panel input selection.
+  mutable uint32_t control_;
+
+  unsigned l1aticket;
+
+  uint32_t VMEbx;
+
+  bool CyclicTrigOn;
+
+  std::vector<BGOChannel> bgo;
+
+  static const size_t maxtriglength = 1024;
+
+  bool L1Aenabled_;
+
+  uint32_t BTimeCorrection_;
+
+  LTCThreadPars ThreadParameters;
+
+  size_t _n_ctg;
+
+  //! cyclic trigger generators
+  std::vector<CyclicTriggerOrBGO> _ctg;
+
+  size_t _n_cbg;
+
+  //! Cyclic BGO generators.
+  std::vector<CyclicTriggerOrBGO> _cbg;
+
+  bool _ResumeCylic;
+
+  //! The thread spawned (e.g. for periodic updating of the BST time via VME.
+  pthread_t thethread;
+
+  Mutex periodicmutex;
+
+  mutable Monitoring monitor;
+  bool overwriteRunNo;
+  time_t mont0;
+  uint32_t orb0;
+  uint32_t evt0;
+  uint32_t blockedevt0;
+  uint32_t bgo0;
+  uint32_t can0;
+  std::vector<bool> bxmask;
+  std::vector<std::string> trigname;
+  LTCStatusInfo CurrentRates;
+  std::string runlog;
+  bool dumpevtstofile;
+  std::string dumpevtstofilepath;
+  bool dumpevtstofile_setonenable;
+  std::string dumpevtstofilepath_prefix;
+
+  //! Object to handle things related to the BGO map.
+  BGOMap* bgo_map;
+};
+
+/**
+ * This is the method which is called when spawning another thread.
+ * It's an infinite loop which periodically performs certain tasks.\
+ */
+void* ParallelThread(void*);
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/LTCAddDefs.hh b/ttc/ltc/include/ttc/ltc/LTCAddDefs.hh
new file mode 100644
index 000000000..da4866d64
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCAddDefs.hh
@@ -0,0 +1,66 @@
+/**
+ * this file is used two times: Once included from a .hh file where
+ * the macros are defined such that they declare the variables
+ * (i.e. that they exists) and once from a .cc file where the
+ * macros are defined such that they initialize the variables
+ * (i.e. call the corresponding constructors).
+ */
+
+//             name            address      write
+MAKE_REGISTER( BRD_ID        , 0x0       ,  0 ); // board id register
+MAKE_REGISTER( FWARE_VER     , 0x4       ,  0 ); // Firmware version
+MAKE_REGISTER( TRIG_NUM      , 0x8       ,  0 );
+MAKE_REGISTER( EVNCNT        , 0x10      ,  0 );
+MAKE_REGISTER( ORBCNT        , 0x14      ,  0 );
+MAKE_REGISTER( TRIGCNT       , 0x18      ,  0 );
+MAKE_REGISTER( STRCNT        , 0x1C      ,  0 );
+MAKE_REGISTER( STATUS        , 0x20      ,  1 );
+MAKE_REGISTER( CONTROL       , 0x24      ,  1 ); // control register
+MAKE_REGISTER( BTCNT         , 0x28      ,  1 );
+MAKE_REGISTER( CNTRST        , 0x40      ,  1 );
+MAKE_REGISTER( BGO_MAP       , 0x44      ,  1 );
+MAKE_REGISTER( INSELECT      , 0x48      ,  1 );
+MAKE_REGISTER( OUTSELECT     , 0x4C      ,  1 );
+MAKE_REGISTER( QPLLCTRL      , 0x50      ,  1 );
+MAKE_REGISTER( ORBOFFS       , 0x54      ,  1 );
+MAKE_REGISTER( ORBOFFS2      , 0x58      ,  1 );
+MAKE_REGISTER( VMEBGO        , 0x60      ,  1 );
+MAKE_REGISTER( VMEDATS       , 0x64      ,  1 );
+MAKE_REGISTER( VMEDATL       , 0x68      ,  1 );
+MAKE_REGISTER( BDAT_CFG      , 0x6C      ,  1 );
+MAKE_REGISTER( SLINK_STAT    , 0x80      ,  0 );
+MAKE_REGISTER( SLINK_CONF    , 0x84      ,  1 );
+MAKE_REGISTER( SLINK_CONF1   , 0x88      ,  1 );
+MAKE_REGISTER( SLINK_CONF2   , 0x8C      ,  1 );
+MAKE_REGISTER( MAXTRIG       , 0x90      ,  1 );
+MAKE_REGISTER( TTS_DELAY     , 0x94      ,  1 );
+MAKE_REGISTER( TTS_FIFLG     , 0x98      ,  0 );
+MAKE_REGISTER( TTS_FIFO      , 0x9C      ,  0 );
+MAKE_REGISTER( TTS_STAT      , 0xA0      ,  0 );
+MAKE_REGISTER( TTS_MASK      , 0xA4      ,  1 );
+MAKE_REGISTER( GPS_LO        , 0xA8      ,  1 );
+MAKE_REGISTER( GPS_HI        , 0xAC      ,  1 );
+MAKE_REGISTER( HWI_SKEW      , 0xB0      ,  1 );
+MAKE_REGISTER( HWI_SKEW1     , 0xB4      ,  1 );
+
+MAKE_REGISTER( BCH_IHB_OFS   ,  0x0      ,  1 );
+MAKE_REGISTER( BCH_PSC_OFS   ,  0x4      ,  1 );
+MAKE_REGISTER( BCH_POS_OFS   ,  0x8      ,  1 );
+MAKE_REGISTER( BCH_RMC_OFS   ,  0xC      ,  0 );
+
+MAKE_REGISTER( CTG_IHB_OFS   ,  0x0      ,  1 );
+MAKE_REGISTER( CTG_IPSC_OFS  ,  0x4      ,  1 );
+MAKE_REGISTER( CTG_PSC_OFS   ,  0x8      ,  1 );
+MAKE_REGISTER( CTG_POS_OFS   ,  0xC      ,  1 );
+MAKE_REGISTER( CTG_PAS_OFS   ,  0x10     ,  1 );
+MAKE_REGISTER( CTG_TGV_OFS   ,  0x14     ,  1 );
+
+MAKE_RAM( STA_BCH            ,  0x100    ,  1                ,  64);
+MAKE_RAM( STA_CTG            ,  0x200    ,  1                ,  24);
+MAKE_RAM( STA_CBG            ,  0x260    ,  1                ,  40);
+
+MAKE_REGISTER( TRR_CANC      ,  0x400    ,  0 );
+
+MAKE_RAM( TRR_nT             ,  0x404    ,  1                ,  9);
+MAKE_RAM( StartTrigDPRAM     ,  0x1000   ,  1                ,  1024);
+MAKE_RAM( StartBDPRAM        ,  0x20000  ,  1                ,  32768);
diff --git a/ttc/ltc/include/ttc/ltc/LTCAddresses.hh b/ttc/ltc/include/ttc/ltc/LTCAddresses.hh
new file mode 100644
index 000000000..9a52a5448
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCAddresses.hh
@@ -0,0 +1,53 @@
+#ifndef _ttc_ltc_LTCAddresses_hh_
+#define _ttc_ltc_LTCAddresses_hh_
+
+
+#include "ttc/utils/Address.hh"
+
+#include <stdint.h>
+
+namespace ttc
+{
+
+#ifndef MAKE_REGISTER
+#define MAKE_REGISTER(name, add, write) extern const Address name
+#endif
+
+#ifndef MAKE_RAM
+#define MAKE_RAM(name, add, write, num) extern const Address name
+#endif
+
+#ifndef MAKE_SUBREG
+#define MAKE_SUBREG(name, reg, offs, num, step) extern const Address name
+#endif
+
+#ifndef MAKE_REGCOPY
+#define MAKE_REGCOPY(name, reg) extern const Address name
+#endif
+
+
+namespace LTCAdd
+{
+
+#include "ttc/ltc/LTCAddDefs.hh"
+
+MAKE_SUBREG(CHIHB, STA_BCH, 0x00, 16, 16);
+MAKE_SUBREG(CHPRESC, STA_BCH, 0x04, 16, 16);
+MAKE_SUBREG(CHPOSTSC, STA_BCH, 0x08, 16, 16);
+MAKE_SUBREG(CHRMC, STA_BCH, 0x0c, 16, 16);
+
+MAKE_SUBREG(CTBG_INH, STA_CTG, 0x00, 14, 32);
+MAKE_SUBREG(CTBG_IPRESC, STA_CTG, 0x04, 14, 32);
+MAKE_SUBREG(CTBG_PRESC, STA_CTG, 0x08, 14, 32);
+MAKE_SUBREG(CTBG_POSTSC, STA_CTG, 0x0c, 14, 32);
+MAKE_SUBREG(CTBG_PAUSE, STA_CTG, 0x10, 14, 32);
+MAKE_SUBREG(CTBG_TYPE, STA_CTG, 0x14, 14, 32);
+
+}
+
+#undef MAKE_ADDRESS
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/LTCConfiguration.hh b/ttc/ltc/include/ttc/ltc/LTCConfiguration.hh
new file mode 100644
index 000000000..aa15ebe7b
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCConfiguration.hh
@@ -0,0 +1,80 @@
+#ifndef _ttc_ltc_LTCConfiguration_hh_
+#define _ttc_ltc_LTCConfiguration_hh_
+
+
+#include "ttc/utils/GenericTTCModuleConfiguration.hh"
+
+
+namespace ttc
+{
+
+// forward declarations
+
+class LTC;
+
+// configuration keywords
+
+const std::string WORD_QPLL = "QPLL";
+const std::string WORD_QPLLEXTERNAL = "EXTERN";
+const std::string WORD_QPLLINTERNAL = "INTERN";
+const std::string WORD_QPLLRESET = "Reset=";
+const std::string WORD_QPLLAUTORESTART = "AutoRestart=";
+const std::string WORD_QPLLFREQBITS = "FreqBits=";
+const std::string WORD_BXGAP = "BXGAP";
+const std::string WORD_TRIGGERS = "TRIGGERS";
+const std::string WORD_TRIGGERS_RAM = "RAM";
+const std::string WORD_TRIGGERS_CYCLIC = "CYCLIC";
+const std::string WORD_TRIGGER_DELAY = "TRIGGERDELAY";
+const std::string WORD_TRIGGER_INTERVAL = "TRIGGER_INTERVAL";
+const std::string WORD_TRIGGER_FREQUENCY = "TRIGGER_FREQUENCY_HZ";
+const std::string WORD_TRIGGER_FREQUENCY_MODE = "MODE=";
+const std::string WORD_CYCLICGEN_TRIGGER = "CYCLICTRIGGER";
+const std::string WORD_CYCLICGEN_BGO = "CYCLICBGO";
+const std::string WORD_CYCLICGEN_STARTBX = "STARTBX=";
+const std::string WORD_CYCLICGEN_PRESCALE = "PRES=";
+const std::string WORD_CYCLICGEN_POSTSCALE = "POST=";
+const std::string WORD_CYCLICGEN_INITPRECALE = "INITWAIT=";
+const std::string WORD_CYCLICGEN_PAUSE = "PAUSE=";
+const std::string WORD_CYCLICGEN_REPETITIVE = "REPETITIVE=";
+const std::string WORD_CYCLICGEN_PERMANENT = "PERMANENT=";
+const std::string WORD_CYCLICGEN_CHANNEL = "CH=";
+const std::string WORD_VMEBX = "VMEBGOBX";
+const std::string WORD_TRIGRULE = "TRIGGERRULE";
+const std::string WORD_TRIGTICKET = "L1ATICKET";
+const std::string WORD_TTS_ENABLE = "ENABLETTS";
+const std::string WORD_TTS_WARNINT = "WARNING_INTERVAL";
+const std::string WORD_MONITORING = "MONITORING";
+const std::string WORD_MONITORING_INTERVAL = "INTERVAL=";
+const std::string WORD_BSTVME = "VMEGPSTIME";
+const std::string WORD_SLINKBACKPRESSURE = "IGNORESLINKBACKPRESSURE";
+const std::string WORD_TRIGGERNAME = "HWTRIGGERNAME";
+const std::string WORD_RUNLOG = "RUNLOG";
+const std::string WORD_FIFODUMP = "SPYFIFODUMP";
+
+//! A class to hold the LTC configuration info.
+class LTCConfiguration : public GenericTTCModuleConfiguration
+{
+
+public:
+
+  LTCConfiguration(ttc::LTC &_ltc);
+
+  /**
+   * Configures the LTC with the given stream.
+   * If a BX conflict is detected, a warning will be logged after the fact.
+   */
+  void Configure(std::istream &in);
+
+protected:
+
+  virtual void registerConfigurationCommands();
+
+  LTC &ltc;
+
+  std::vector<float> extdelays;
+};
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/LTCControl.hh b/ttc/ltc/include/ttc/ltc/LTCControl.hh
new file mode 100755
index 000000000..7278d4ac9
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCControl.hh
@@ -0,0 +1,271 @@
+#ifndef _ttc_ltc_LTCControl_hh_
+#define _ttc_ltc_LTCControl_hh_
+
+
+#include "ttc/utils/BoardLockingProxy.hh"
+#include "ttc/utils/TTCXDAQBase.hh"
+
+#include "ttc/ltc/LTC.hh"
+#include "ttc/utils/HTMLFieldElement.hh"
+
+#include "xdata/UnsignedInteger32.h"
+#include "xdata/Double.h"
+
+#include <string>
+#include <map>
+
+
+namespace ttc
+{
+
+// forward declarations
+
+class LTCControl;
+class LTCControlSoapHandler;
+
+
+//! proxy class managing resources for talking to LTC
+class LTCProxy : public BoardLockingProxy
+{
+public:
+  LTCProxy();
+
+  BoardTempLocker<LTC> operator->();
+
+  void initAdditionalParams(
+      const uint32_t& bTimeCorrection,
+      const uint32_t& sLinkSrcId);
+
+protected:
+  virtual LTC* createPtr(HAL::VMEBusAdapterInterface* busAdapter);
+
+  uint32_t bTimeCorrection_;
+  uint32_t sLinkSrcId_;
+};
+
+
+/**
+ * This class implements 'HyperDAQ the web interface' to the LTC,
+ * i.e. it generates various html pages, processes form input etc.
+ */
+class LTCControl : public TTCXDAQBase
+{
+  friend class LTCControlSoapHandler;
+
+public:
+
+  XDAQ_INSTANTIATOR();
+
+  LTCControl(xdaq::ApplicationStub* stub);
+
+  virtual ~LTCControl();
+
+  virtual LTCProxy& boardLockingProxy();
+
+  virtual std::string softwareVersion();
+
+private:
+
+  // SOAP - application info space
+
+  virtual void itemRetrieveAction(xdata::ItemRetrieveEvent& e);
+
+  virtual void itemChangedAction(xdata::ItemChangedEvent& e);
+
+  virtual void setDefaultValuesAction();
+
+
+  // SOAP - FSM
+
+  virtual void ConfigureAction(toolbox::Event::Reference e);
+
+  virtual void EnableAction(toolbox::Event::Reference e);
+
+  virtual void StopAction(toolbox::Event::Reference e);
+
+  virtual void SuspendAction(toolbox::Event::Reference e);
+
+
+  // CGI
+
+  virtual void CommandImpl(cgicc::Cgicc& cgi, const std::string& command);
+
+  //! The main HyperDAQ entry point.
+  virtual void HTMLPageMain(xgi::Input* in, xgi::Output* out);
+
+  //! The LTC Main Configuration Page (long method, should be splitted)
+  void HTMLPageMainConfiguration(xgi::Input* in, xgi::Output* out);
+
+  //! The Send BGOs from VME page
+  void HTMLPageBGOConfiguration(xgi::Input* in, xgi::Output* out);
+
+  //! The LTC sequence edit page. Produces html.
+  void HTMLPageSequences(xgi::Input* in, xgi::Output* out);
+
+  //! The Cyclic Generators Page.
+  void HTMLPageCyclicGenerators(xgi::Input* in, xgi::Output* out);
+
+  //! The Summary Page. Produces html.
+  void HTMLPageSummary(xgi::Input* in, xgi::Output* out);
+
+  //! The LTC Register Access. Produces html.
+  void HTMLPageRegisterAccess(xgi::Input* in, xgi::Output* out);
+
+  //! HTML page which displays trigger and BGO rates (for use as popup).
+  void HTMLPageRatesPopup(xgi::Input* in, xgi::Output* out);
+
+  void HTMLPageCommandConfigureTTS(xgi::Input* in, xgi::Output* out);
+
+  /**
+   * This is called when the user selects a new configuration file
+   * in the 'Configure LTC FROM file' radio button group on the 'LTC Control' tab.
+   */
+  void HTMLPageCommandNewConfigFile(xgi::Input* in, xgi::Output* out);
+
+  /**
+   * This is called when the user selects 'Write current configuration TO file'
+   * in the 'LTC Control' tab.
+   */
+  void HTMLPageCommandWriteConfigFile(xgi::Input* in, xgi::Output* out);
+
+  void HTMLPageCommandMainConfig(xgi::Input* in, xgi::Output* out);
+
+  void HTMLPageCommandTriggerRulesDelays(xgi::Input* in, xgi::Output* out);
+
+  void HTMLPageCommandVMEBGOTiming(xgi::Input* in, xgi::Output* out);
+
+  //! callback for command to perform sequence action
+  void HTMLPageCommandSequenceAction(xgi::Input* in, xgi::Output* out);
+
+  //! callback for command to edit selected sequence
+  void HTMLPageCommandEditSequence(xgi::Input* in, xgi::Output* out);
+
+  /**
+   * Evaluates a HTTP request for updating the cyclic generator configuration
+   * (i.e. this is behind the 'apply' button of the cyclic generator configuration page.
+   */
+  void HTMLPageCommandConfigureCyclicGenerator(xgi::Input* in, xgi::Output* out);
+
+  /**
+   * Triggers reading back of the cyclic generators from the hardware
+   * (used on the cyclic generator's page).
+   */
+  void HTMLPageCommandReadCyclicGeneratorConfig(xgi::Input* in, xgi::Output* out);
+
+  void HTMLPageCommandRegisterAccess(xgi::Input* in, xgi::Output* out);
+
+  //! Read from / write to LTC adresses.
+  void HTMLPageSetControlRegisterBits(xgi::Input* in, xgi::Output* out);
+
+
+  // utilities
+
+ //! initialization before CGI callbacks
+  virtual void initHTMLFields();
+
+  virtual void ErrorStatement(xgi::Output& out);
+
+  /**
+   * This probably should go away as we should not support any more
+   * calling the 'default' sequence which somebody has selected on the html page.
+   */
+  std::string GetDefaultSequenceName();
+
+  void ReadLTCCounters();
+
+  void GetFileList();
+
+  /**
+   * Main page helper function for generating radio buttons corresponding to a binary value
+   * (actually, this is the functionality a checkbox provides...)
+   */
+  void WriteBinaryRadioButton(
+      std::ostream &out,
+      const std::string &radio_group_name,
+      const std::string &text1,
+      const std::string &text2,
+      const std::string &value1,
+      const std::string &value2,
+      unsigned selected_index,
+      bool disabled);
+
+
+  // info space items
+
+  xdata::String TimeOfLastStateChange_;
+
+  //! fraction of active bunches
+  xdata::Double FractionOfActiveBunches_;
+
+  //! B-Channel timing correction
+  xdata::UnsignedInteger32 BTimeCorrection_;
+
+  xdata::UnsignedInteger32 SlinkSrcId_;
+
+  //! Current state of TTS (summary)
+  xdata::String TTSStatus_;
+  xdata::String SLinkStatus_;
+  xdata::String ClockSignal_;
+  xdata::String OrbitSignal_;
+
+  xdata::UnsignedInteger32 TriggerCounter_;
+  xdata::UnsignedInteger32 EventCounter_;
+  xdata::UnsignedInteger32 OrbitCounter_;
+  xdata::UnsignedInteger32 StrobeCounter_;
+  xdata::UnsignedInteger32 BlockedL1ACntr_;
+  xdata::UnsignedInteger32 BoardStatus_;
+
+  xdata::String TriggerInputs_;
+  xdata::Double TotalEfficiency_;
+  xdata::Double Efficiency_;
+  xdata::Double AvEfficiency_;
+  xdata::Double L1ARate_;
+  xdata::Double AvL1ARate_;
+  xdata::Double RawL1ARate_;
+  xdata::Double AvRawL1ARate_;
+  xdata::Double BlockedL1ARate_;
+
+  xdata::Double DeltaT_;
+  xdata::Double UptimeSec_;
+
+  std::vector<xdata::Double> HWTriggerFraction_;
+
+  std::vector<xdata::String> HWTriggerName_;
+
+  std::vector<xdata::Boolean> HWTriggerEnable_;
+
+  std::vector<xdata::Double> HWTriggerDelay_;
+
+  xdata::String ClockSource_;
+  xdata::UnsignedInteger32 ClockFrequency_;
+
+  xdata::UnsignedInteger32 RunNumber_;
+
+  // other parameters
+
+  int resetbits_;
+  bool OverwriteRunNumber_;
+
+  //! the soap handler
+  LTCControlSoapHandler* soapHandler_;
+
+  // HTML field elements
+  ttc::HTMLFieldElement RegList;
+  ttc::HTMLFieldElement InputFileList;
+  ttc::HTMLFieldElement CurrentBGOList;
+  ttc::HTMLFieldElement CurrentCyclicList;
+  ttc::HTMLFieldElement Trigselector;
+  ttc::HTMLFieldElement BGOselector;
+  ttc::HTMLFieldElement VMEAddrList1;
+  ttc::HTMLFieldElement VMEAddrList2;
+  ttc::HTMLFieldElement DataTypeSelector;
+  ttc::HTMLFieldElement SequenceSelector;
+
+  //! the LTC board proxy object
+  LTCProxy ltcProxy_;
+};
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/LTCControlSoapHandler.hh b/ttc/ltc/include/ttc/ltc/LTCControlSoapHandler.hh
new file mode 100644
index 000000000..97a3d016c
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCControlSoapHandler.hh
@@ -0,0 +1,36 @@
+#ifndef _ttc_ltc_LTCControlSoapHandler_hh_
+#define _ttc_ltc_LTCControlSoapHandler_hh_
+
+
+#include "log4cplus/logger.h"
+#include "xoap/MessageReference.h"
+#include "toolbox/lang/Method.h"
+
+
+namespace ttc
+{
+
+class LTCControl;
+
+//! Class to handle SOAP callbacks from LTCControl application
+class LTCControlSoapHandler
+{
+public:
+
+  LTCControlSoapHandler(LTCControl* _ltc_control);
+
+  void addMethod(toolbox::lang::Method* m, std::string name);
+
+private:
+
+  //! Processes a user command.
+  xoap::MessageReference userCommand(xoap::MessageReference msg);
+
+  LTCControl* ltc_control;
+  log4cplus::Logger logger_;
+};
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/LTCEvent.hh b/ttc/ltc/include/ttc/ltc/LTCEvent.hh
new file mode 100644
index 000000000..1d7260b66
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCEvent.hh
@@ -0,0 +1,171 @@
+#ifndef _ttc_ltc_LTCEvent_hh_
+#define _ttc_ltc_LTCEvent_hh_
+
+
+#include <stdint.h>
+#include <string>
+#include <vector>
+#include <ostream>
+
+
+namespace ttc
+{
+
+//! Class representing one entry in LTC's event fifo.
+class LTCEvent
+{
+public:
+
+  LTCEvent(size_t BTCorrection = 0, size_t ATCorrection = 0);
+
+  LTCEvent(const std::vector<uint32_t>& Data, size_t BTCorrection = 0, size_t ATCorrection = 0);
+
+  uint32_t GetStrobeCounter() const;
+
+  uint32_t GetEventCounter() const;
+
+  uint32_t GetBunchCounter() const;
+
+  uint32_t GetOrbitCounter() const;
+
+  uint32_t GetBlockedCounter() const;
+
+  size_t GetTTSWord() const;
+
+  std::string GetTTSStatusString(const size_t idx, const bool htmlcolors = false) const;
+
+  bool IsReady(size_t idx) const;
+
+  bool IsDisconnected(size_t idx) const;
+
+  bool IsOutOfSync(size_t idx) const;
+
+  bool IsWarning(size_t idx) const;
+
+  bool IsBusy(size_t idx) const;
+
+  bool IsRAMTrigger() const;
+
+  bool IsVMETrigger() const;
+
+  bool IsHWTrigger(size_t idx = 99) const;
+
+  bool IsCyclicTrigger(size_t idx = 99) const;
+
+  bool IsBGO() const;
+
+  void Print(std::ostream& out, bool html = false) const;
+
+  size_t BGOChannel() const;
+
+  bool IsSuppressed() const;
+
+  bool IsBXMaskOK() const;
+
+private:
+
+  std::vector<uint32_t> data;
+  size_t BTCorr;
+  size_t ATCorr;
+
+  bool CheckReady(size_t pattern) const;
+
+  bool CheckDisconnected(size_t pattern) const;
+
+  bool CheckOutOfSync(size_t pattern) const;
+
+  bool CheckWarning(size_t pattern) const;
+
+  bool CheckBusy(size_t pattern) const;
+
+  void Set(const std::vector<uint32_t>& Data);
+
+  std::vector<uint32_t> Get() const;
+
+  void Clear();
+
+  size_t NWordsPerEvent() const;
+
+  uint32_t GetGPSWord0() const;
+
+  void SetGPSWord0(const uint32_t GPSwd);
+
+  uint32_t GetGPSWord1() const;
+
+  void SetGPSWord1(const uint32_t GPSwd);
+
+  void SetGPSWords(const uint32_t GPSwd0, const uint32_t GPSwd1);
+
+  void SetStrobeCounter(const uint32_t cntr);
+
+  void SetEventCounter(const uint32_t cntr);
+
+  void SetBunchCounter(const uint32_t BC);
+
+  void SetOrbitCounter(const uint32_t orbit);
+
+  size_t NTTS() const;
+
+  size_t GetTTSStatusPattern(const size_t idx) const;
+
+  bool IsOK() const;
+};
+
+class LTC;
+
+
+/**
+ * Class containing data read out from the LTC's event fifo
+ * (mainly used for debugging).
+ */
+class LTCEventFIFO
+{
+public:
+
+  LTCEventFIFO();
+
+  LTCEventFIFO(const std::vector<uint32_t>& buf, const LTC& ltc);
+
+  LTCEvent& operator[](size_t i);
+
+  const LTCEvent& operator[](size_t i) const;
+
+  size_t size() const;
+
+  bool IsL1AEnabled() const;
+
+  bool IsExternalTriggerEnabled(const size_t i) const;
+
+  std::string GetTriggerName(const size_t i) const;
+
+  void print(std::ostream& os, bool html = false) const;
+
+  void tofile(const std::string& path) const;
+
+private:
+
+  //! pointer to LTC object
+  const LTC* ltcptr;
+
+  std::vector<LTCEvent> data;
+  uint32_t BTimeCorrection_;
+  bool L1AEnabled_;
+  bool ExternalTriggerEnabled_[6];
+  bool TTSEnabled_[7];
+  bool SlinkBackpressureIgnored_;
+  std::string TriggerName_[6];
+
+  void UpdateGeneralInfo();
+};
+
+
+// non-member-functions in ttc namespace
+
+std::ostream& operator<<(std::ostream& os, const LTCEvent& e);
+
+std::ostream& operator<<(std::ostream& os, const LTCEventFIFO& e);
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/LTCStatusInfo.hh b/ttc/ltc/include/ttc/ltc/LTCStatusInfo.hh
new file mode 100644
index 000000000..671d69e94
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/LTCStatusInfo.hh
@@ -0,0 +1,96 @@
+#ifndef _ttc_ltc_LTCStatusInfo_hh_
+#define _ttc_ltc_LTCStatusInfo_hh_
+
+
+#include "ttc/ltc/TriggerComposition.hh"
+
+#include <ctime>
+#include <vector>
+
+
+namespace ttc
+{
+
+class LTCStatusInfo
+{
+public:
+
+  LTCStatusInfo();
+
+  void Set(uint32_t orbit, uint32_t evtnum, uint32_t blockedL1As, uint32_t nbgos, uint32_t ncancelled = 0);
+
+  void SetTriggerComposition(const TriggerComposition* Composition);
+
+  const TriggerComposition* GetTriggerComposition() const;
+
+  //! Delta(T) in sec
+  double DeltaT() const;
+
+  double L1ARate() const;
+
+  double RawTriggerRate() const;
+
+  double BlockedTriggerRate() const;
+
+  double CancelledRate() const;
+
+  double Efficiency() const;
+
+  double BGORate() const;
+
+  double L1AsPerOrbit() const;
+  
+  double BGOsPerOrbit() const;
+
+  uint32_t OrbitDiff() const;
+
+  uint32_t L1ADiff() const;
+
+  uint32_t RawDiff() const;
+
+  uint32_t BGODiff() const;
+
+  double DeltaT_Accumulated() const;
+
+  double L1ARate_Accumulated() const;
+
+  double RawTriggerRate_Accumulated() const;
+
+  double BlockedTriggerRate_Accumulated() const;
+
+  double CancelledRate_Accumulated() const;
+
+  double BGORate_Accumulated() const;
+
+  double Efficiency_Accumulated() const;
+
+  size_t NAccumulations() const;
+
+  void Print() const;
+
+private:
+
+  std::vector<time_t> _tupdate;
+  std::vector<uint32_t> _evt0;
+  std::vector<uint32_t> _evt1;
+  std::vector<uint32_t> _blocked0;
+  std::vector<uint32_t> _blocked1;
+  std::vector<uint32_t> _cancelled0;
+  std::vector<uint32_t> _cancelled1;
+  std::vector<uint32_t> _bgo0;
+  std::vector<uint32_t> _bgo1;
+  std::vector<uint32_t> _orb0;
+  std::vector<uint32_t> _orb1;
+  TriggerComposition _comp;
+
+  size_t N() const;
+
+  double DeltaT_Accum(size_t &i0, size_t &i1) const;
+
+  time_t Time() const;
+};
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/Monitoring.hh b/ttc/ltc/include/ttc/ltc/Monitoring.hh
new file mode 100644
index 000000000..d30b48844
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/Monitoring.hh
@@ -0,0 +1,69 @@
+#ifndef _ttc_ltc_Monitoring_hh_
+#define _ttc_ltc_Monitoring_hh_
+
+
+#include "ttc/ltc/LTCEvent.hh"
+#include "ttc/ltc/TriggerComposition.hh"
+#include "ttc/ltc/StateChanges.hh"
+#include "ttc/utils/Utils.hh"
+
+#include <stdint.h>
+#include <ctime>
+#include <iostream>
+
+
+namespace ttc
+{
+
+class LTCStatusInfo;
+
+
+class Monitoring
+{
+public:
+  Monitoring(
+      size_t BTCorrection = DEFAULT_LTC_BTC,
+      size_t ATCorrection = 0,
+      size_t maxbufsize = 2048,
+      std::ostream* outputstream = &std::cout);
+
+  void Flush();
+
+  size_t N() const;
+
+  size_t Nmax() const;
+
+  void SetEventFIFO(const LTCEventFIFO& myevts);
+
+  void SetRunNumber(const int32_t No);
+
+  void Print(std::ostream& out = std::cout) const;
+
+  void NewState(const std::string& Name);
+
+  LTCEventFIFO GetEventFIFO() const;
+
+  const TriggerComposition* GetTriggerComposition() const;
+
+  double RunDuration() const;
+
+  void SetLTCStatusInfo(LTCStatusInfo *stat = 0);
+
+private:
+
+  LTCStatusInfo *Status;
+  const size_t nmax;
+  LTCEventFIFO buf;
+  std::ostream *out_;
+  int32_t runno;
+  StateChanges MyStates;
+  size_t BTCorr;
+  size_t ATCorr;
+  TriggerComposition Comp;
+  time_t tinit;
+};
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/StateChanges.hh b/ttc/ltc/include/ttc/ltc/StateChanges.hh
new file mode 100644
index 000000000..9bce8cdc9
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/StateChanges.hh
@@ -0,0 +1,62 @@
+#ifndef _ttc_ltc_StatusChanges_hh_
+#define _ttc_ltc_StatusChanges_hh_
+
+
+#include <string>
+#include <vector>
+#include <ctime>
+
+namespace ttc
+{
+
+enum Action
+{
+  COLDRESET, CONFIGURE, ENABLE, SUSPEND, STOP, UNKNOWN
+};
+
+
+struct StateEvent
+{
+  Action act;
+  time_t t;
+};
+
+
+class StateChanges
+{
+public:
+
+  StateChanges();
+
+  void push_back(const StateEvent& evt);
+
+  void push_back(const std::string& statename);
+
+  void push_back(const Action statechange);
+
+  void push_back(const Action statechange, const time_t time);
+
+  size_t size() const;
+
+  StateEvent* Get(const size_t idx);
+
+  const StateEvent* Get(const size_t idx) const;
+
+  void Delete(const size_t idx);
+
+private:
+
+  std::vector<StateEvent> states;
+};
+
+
+// non-member-functions in namespace ttc
+
+Action State(const std::string& Name);
+
+std::string State(const Action State);
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/TriggerComposition.hh b/ttc/ltc/include/ttc/ltc/TriggerComposition.hh
new file mode 100644
index 000000000..02324eae3
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/TriggerComposition.hh
@@ -0,0 +1,55 @@
+#ifndef _ttc_ltc_TriggerComposition_hh_
+#define _ttc_ltc_TriggerComposition_hh_
+
+
+#include <vector>
+#include <iostream>
+#include <stdint.h>
+
+
+namespace ttc
+{
+
+class TriggerComposition
+{
+private:
+
+  static const size_t _NN = 7;
+  static const size_t _Nmax = 5000;
+
+public:
+
+  TriggerComposition();
+
+  void Clear();
+
+  size_t N() const
+  {
+    return _NN;
+  }
+
+  void SetTrigger(const std::vector<bool>& trig);
+
+  void SetTrigger(bool HW0, bool HW1, bool HW2, bool HW3, bool HW4, bool HW5, bool INT = false);
+
+  double GetTriggerFraction(size_t itrig, size_t itrig2 = 999) const;
+
+  uint32_t GetSum() const;
+
+  void Print(std::ostream &out = std::cout) const;
+
+private:
+
+  size_t _n;
+  size_t _countall;
+  size_t _countall0;
+  std::vector<uint32_t> _counter;
+  std::vector<uint32_t> _counter0;
+  uint32_t _cnt[_NN][_NN];
+  uint32_t _cnt0[_NN][_NN];
+};
+
+}
+
+
+#endif
diff --git a/ttc/ltc/include/ttc/ltc/version.h b/ttc/ltc/include/ttc/ltc/version.h
new file mode 100755
index 000000000..12022c6f1
--- /dev/null
+++ b/ttc/ltc/include/ttc/ltc/version.h
@@ -0,0 +1,31 @@
+#ifndef _ttc_ltc_version_h_
+#define _ttc_ltc_version_h_
+
+#include "config/PackageInfo.h"
+
+// !!! Edit these lines to reflect the latest package version !!!
+#define TTCLTC_VERSION_MAJOR 1
+#define TTCLTC_VERSION_MINOR 7
+#define TTCLTC_VERSION_PATCH 0
+#undef TTCUTILS_PREVIOUS_VERSIONS
+
+#define TTCLTC_VERSION_CODE PACKAGE_VERSION_CODE(TTCLTC_VERSION_MAJOR,TTCLTC_VERSION_MINOR,TTCLTC_VERSION_PATCH)
+#ifndef TTCLTC_PREVIOUS_VERSIONS
+#define TTCLTC_FULL_VERSION_LIST  PACKAGE_VERSION_STRING(TTCLTC_VERSION_MAJOR,TTCLTC_VERSION_MINOR,TTCLTC_VERSION_PATCH)
+#else
+#define TTCLTC_FULL_VERSION_LIST  TTCLTC_VERSION_MAJOR "," TTCLTC_VERSION_MINOR "," TTCLTC_VERSION_PATCH
+#endif
+
+namespace ttcltc {
+  const std::string package  = "ttcltc";
+  const std::string versions = TTCLTC_FULL_VERSION_LIST;
+  const std::string description = "Local Trigger Control XDAQ application";
+  const std::string authors = "CMS DAQ group";
+  const std::string summary = "LTC XDAQ application";
+  const std::string link = "https://twiki.cern.ch/twiki/bin/view/CMS/TTCManual";
+  config::PackageInfo getPackageInfo();
+  void checkPackageDependencies();
+  std::set<std::string, std::less<std::string> > getPackageDependencies();
+}
+
+#endif
diff --git a/ttc/ltc/src/common/LTC.cc b/ttc/ltc/src/common/LTC.cc
new file mode 100755
index 000000000..6347ecdf6
--- /dev/null
+++ b/ttc/ltc/src/common/LTC.cc
@@ -0,0 +1,2944 @@
+#include "ttc/ltc/LTC.hh"
+
+#include "ttc/ltc/LTCAddresses.hh"
+#include "ttc/ltc/LTCConfiguration.hh"
+#include "ttc/ltc/LTCEvent.hh"
+#include "ttc/ltc/version.h"
+#include "ttc/utils/TTSInfo.hh"
+#include "ttc/utils/LockMutex.hh"
+#include "ttc/utils/RAMTriggers.hh"
+#include "ttc/utils/VME64xPNP.hh"
+#include "ttc/utils/BGOMap.hh"
+#include "ttc/utils/LockMutex.hh"
+
+#include "xcept/tools.h"
+#include "log4cplus/logger.h"
+#include "hal/VMEBusAdapterInterface.hh"
+
+//#include <boost/tokenizer.hpp>
+#include <boost/lexical_cast.hpp>
+
+#include <unistd.h>
+#include <fstream>
+#include <cmath>
+#include <cstring>
+#include <iomanip>
+
+
+#define N_CYCL_TRIG_ 4
+#define N_CYCL_BGO_ 4
+
+// Macros for bit packing.
+#define QPLLAUTORESTART_BIT 4
+#define QPLLRESET_BIT 5
+#define QPLLEXTERNAL_BIT 6
+#define LTC_NTRR_OFFSET 1 // Trigger rules start with 2 triggers
+#define BGOMAP_RESYNC_OFFS 0    // channel 5
+#define BGOMAP_RESYNC_WDTH 4
+#define BGOMAP_HARDRESET_OFFS 4 // channel 6
+#define BGOMAP_HARDRESET_WDTH 4
+#define BGOMAP_ECRST_OFFS 8     // channel 7
+#define BGOMAP_ECRST_WDTH 4
+#define BGOMAP_OCRST_OFFS 12    // channel 8
+#define BGOMAP_OCRST_WDTH 4
+#define BGOMAP_START_OFFS 16    // channel 9
+#define BGOMAP_START_WDTH 4
+#define BGOMAP_PAUSE_OFFS 20     // channel ?? // should not exist?!?
+#define BGOMAP_PAUSE_WDTH 4
+#define BGOMAP_STOP_OFFS 28     // channel 10
+#define BGOMAP_STOP_WDTH 4
+#define DFLTBGOMAP 0x01008765       // Default w/o start/stop response of LTC
+#define CNTRST_RESET_ALL_INTERNAL_TRIGSANDBGOS (1<<16)
+
+#define CNTRLBIT_STARTBIT_L1A 4 //4
+#define CNTRLBIT_STARTBIT_BGO 7 //4
+#define CNTRLBIT_ENABLE_CYLIC 6 // ()
+#define CNTRLBIT_ENABLE_RAMTRIG 8 //
+#define CNTRLBIT_START_RAMTRIG 9  // (just a pulse, set back to 0!)
+#define CNTRLBIT_RESET_CANCELCNTR 10 // (set back to 0 to restart counting)
+#define CNTRLBIT_EXT0 11
+#define CNTRLBIT_EXT1 12
+#define CNTRLBIT_EXT2 13
+#define CNTRLBIT_EXT3 14
+#define CNTRLBIT_EXT4 15
+#define CNTRLBIT_EXT5 16
+#define CNTRLBIT_RESET_EVTFIFO 20 // (set back to 0 to restart event FIFO)
+#define CNTRLBIT_SLINKBACKPRESSURE 21
+#define CNTRLBIT_MAXTRIG 22 // (enable MAXTRIG register)
+#define CNTRLBIT_EXT(i) (i==0?CNTRLBIT_EXT0:(i==1?CNTRLBIT_EXT1:(i==2?CNTRLBIT_EXT2:(i==3?CNTRLBIT_EXT3:(i==4?CNTRLBIT_EXT4:CNTRLBIT_EXT5)))))
+
+#define STARTCYCLATSTART_BIT 28
+#define QPLLLOCKEDBIT 10 // of QPLLCTRL
+
+
+using namespace std;
+
+
+// methods wrapped in anonymous namespace
+
+namespace
+{
+
+ttc::VME64xDeviceInfo
+GetLTCInfo(
+    HAL::VMEBusAdapterInterface& bus,
+    int location)
+{
+  ttc::VME64xDeviceInfo info(
+      ttc::VME64xDeviceInfo::MF_CERN,
+      ttc::VME64xDeviceInfo::BOARD_ID_LTC,
+      location);
+
+  return ttc::VME64xPNP::GetDevice(bus, info);
+}
+
+}
+
+
+// class ttc::LTC
+
+ttc::LTC::LTC(
+    HAL::VMEBusAdapterInterface& bus,
+    int location,
+    uint32_t btimecorr,
+    bool enable_vme_writes_,
+    uint32_t slinkSrcId)
+:
+  GenericTTCModule(
+      Address::LTC,
+      bus,
+      GetLTCInfo(bus, location),
+      enable_vme_writes_),
+  l1aticket(0),
+  VMEbx(90),
+  CyclicTrigOn(false),
+  L1Aenabled_(false),
+  BTimeCorrection_(btimecorr),
+  _n_ctg(N_CYCL_TRIG_),
+  _n_cbg(N_CYCL_BGO_),
+  _ResumeCylic(false),
+  monitor(btimecorr, 0),
+  overwriteRunNo(false),
+  orb0(0),
+  evt0(0),
+  blockedevt0(0),
+  bgo0(0),
+  can0(0),
+  runlog(""),
+  dumpevtstofile(false),
+  dumpevtstofilepath(""),
+  dumpevtstofile_setonenable(false),
+  dumpevtstofilepath_prefix(""),
+  bgo_map(0)
+{
+  logger_ = log4cplus::Logger::getInstance("LTC");
+
+  ram_triggers = new RAMTriggers(*this, LTCAdd::StartTrigDPRAM);
+
+  bgo_map = new BGOMap(*this, LTCAdd::BGO_MAP, true);
+  bgo_map->GetBGOMap();
+
+  control_ = Read(LTCAdd::CONTROL);
+  L1Aenabled_ = control_ & (
+      CNTRLBIT_ENABLE_CYLIC
+      | CNTRLBIT_ENABLE_RAMTRIG
+      | CNTRLBIT_EXT0
+      | CNTRLBIT_EXT1
+      | CNTRLBIT_EXT2
+      | CNTRLBIT_EXT3
+      | CNTRLBIT_EXT4
+      | CNTRLBIT_EXT5);
+
+  // some initialization for monitoring
+  monitor.SetLTCStatusInfo(&CurrentRates);
+  time(&mont0);
+
+  evt0 = ReadTriggerCounter();
+  blockedevt0 = ReadBlockedTriggersCounter();
+  bgo0 = ReadStrobeCounter();
+  can0 = CancelledTriggers();
+  orb0 = ReadOrbitCounter();
+
+  // First time: take run number, but don't increment yet.
+  IncrementRunNumber(true);
+
+  // Determine the number of cyclic generators.
+  const uint32_t trignum = Read(LTCAdd::TRIG_NUM);
+
+  if (trignum > 0)
+  {
+    _n_ctg = size_t((trignum & 0xff));
+    _n_cbg = size_t(((trignum >> 8) & 0xff));
+    if (_n_ctg > 8 || _n_cbg > 8)
+    {
+      LOG4CPLUS_ERROR(
+          logger_,
+          "LTC::LTC(): Read(LTCAdd::TRIG_NUM)=0x" << hex << trignum << dec << ", "
+          << "_n_ctg=" << _n_ctg
+          << " _n_cbg=" << _n_cbg << " --> setting both to 4");
+      _n_ctg = _n_cbg = 4;
+    }
+  }
+  else
+  {
+    LOG4CPLUS_WARN(
+        logger_,
+        "LTC::LTC(): LTCAdd::TRIG_NUM returned 0 (DUMMY(64X) bus adapter?)"
+        "--> Unable to read no. of cyclic generators");
+  }
+
+  trigname = vector<string>(Nextern(), "Unnamed");
+
+  // BX mask.
+  bxmask = vector<bool>(NClocksPerOrbit(), true);
+  for (size_t i = 0; i < NClocksPerOrbit(); ++i)
+  {
+    bxmask[i] = Read(LTCAdd::StartBDPRAM, i, "(BX Mask)");
+  }
+
+  // Create the BGO channel objects.
+  for (size_t i = 0; i < NChannels(); ++i)
+    bgo.push_back(BGOChannel(i));
+
+  SetBChannelNames();
+
+  // Init sequences.
+  _sequences.clear();
+  vector<string> emptyseq;
+  _sequences.push_back(Sequence(emptyseq, "coldReset", true));
+  _sequences.push_back(Sequence(emptyseq, "configure", true));
+  _sequences.push_back(Sequence(emptyseq, "enable", true));
+  _sequences.push_back(Sequence(emptyseq, "stop", true));
+  _sequences.push_back(Sequence(emptyseq, "suspend", true));
+  _sequences.push_back(Sequence(emptyseq, "periodic", true));
+  _sequences.push_back(Sequence(emptyseq, "user", true));
+  _sequences.push_back(Sequence(emptyseq, "resync", true));
+  _sequences.push_back(Sequence(emptyseq, "hardReset", true));
+
+  // Cyclic trigger/BGO generators.
+  for (size_t i = 0; i < _n_ctg; ++i)
+  {
+    _ctg.push_back(CyclicTriggerOrBGO(true, i, BTimeCorrection_));
+  }
+
+  for (size_t i = 0; i < _n_cbg; ++i)
+  {
+    _cbg.push_back(CyclicTriggerOrBGO(false, i, BTimeCorrection_));
+  }
+
+  CreateParallelThread();
+
+  LOG4CPLUS_INFO(logger_, "Initialised LTC hardware");
+  LOG4CPLUS_INFO(logger_, "  firmware version: " << firmwareVersionString());
+  LOG4CPLUS_INFO(logger_, "  Board-ID " << GetBoardID());
+
+  if ((GetFirmwareVersion() > 0) && (GetFirmwareVersion() < 9))
+  {
+    ostringstream msg;
+    msg << "Potential incompatibility between LTC software and firmware "
+        << "(FW version " << firmwareVersionString() << ")";
+    XCEPT_RAISE(xcept::Exception, msg.str());
+  }
+
+  MainReset();
+  SetSlinkSrcId(slinkSrcId);
+}
+
+
+ttc::LTC::~LTC()
+{
+  stop_thread_flag = true;
+  LOG4CPLUS_INFO(logger_, "Waiting for the parallel thread to terminate");
+  void* dummy;
+  pthread_join(thethread, &dummy);
+  LOG4CPLUS_INFO(logger_, "Parallel thread terminated");
+}
+
+
+string ttc::LTC::firmwareVersionString()
+{
+  ostringstream s;
+  uint32_t fw = GetFirmwareVersion();
+  s << "Version " << fw << " (= 0x" << hex << fw << dec << "); Build " << GetFirmwareBuiltNumber() << "";
+  return s.str();
+}
+
+
+void ttc::LTC::MainReset()
+{
+  StopRAMTrigs();
+  for (size_t i = 0; i < Nextern(); ++i)
+  {
+    EnableExternalTrigger(i, false);
+  }
+  EnableRAMTrig(false);
+  EnableCyclicTrig(false);
+  EnableL1A(false);
+  ram_triggers->ClearTriggerDelays();
+  ram_triggers->ClearDPRAM();
+  ResetCyclicGenerators(true, true);
+  ResetInternalTrigsAndAllCyclicGenerators();
+  ResetEventFIFO();
+
+  SetL1ATicket(0);
+  BXMaskReset();
+  // trigger rules:
+  SetTriggerRule(1, 4);
+  SetTriggerRule(2, 25);
+  SetTriggerRule(3, 100);
+  SetTriggerRule(4, 240);
+  SetTriggerRule(5, 0);
+  SetTriggerRule(6, 0);
+  SetTriggerRule(7, 0);
+  SetTriggerRule(8, 0);
+  SetTriggerRule(9, 0);
+
+  bgo_map->SetBGOMap(DFLTBGOMAP);
+  SetBChannelNames(); // updated BGO map, need to udpate b channel names
+
+  for (size_t i = 0; i < NTTS(); ++i)
+  {
+    EnableTTS(i, false);
+  }
+
+  // SLINK Configuration
+  Write(LTCAdd::SLINK_CONF1, (1 << 24), "(Revision+DAQPartition)");
+  SetBSTGPS(0, 0);
+
+  IncrementRunNumber();
+
+  IgnoreSlinkBackpressure();
+
+  SetMonitoringInterval(10.0);
+  EnableMonitoring(false);
+  SetBSTGPSInterval(3.0);
+  EnableBSTGPSviaVME(false);
+  ResetCounters();
+}
+
+
+#ifndef BUILDDATE
+# define BUILDDATE
+#endif
+
+
+uint32_t ttc::LTC::GetSlinkSrcId() const
+{
+  return Read(LTCAdd::SLINK_CONF) >> 20;
+}
+
+
+uint32_t ttc::LTC::ReadFirmwareVersion() const
+{
+  return Read(LTCAdd::FWARE_VER, "(ReadFirmwareVersion())");
+}
+
+
+uint32_t ttc::LTC::GetFirmwareVersion() const
+{
+  return ReadFirmwareVersion() & 0xffff;
+}
+
+
+uint32_t ttc::LTC::GetBoardID() const
+{
+  return Read(LTCAdd::BRD_ID, "(GetBoardID())");
+}
+
+
+size_t ttc::LTC::NChannels() const
+{
+  return 16;
+}
+
+
+uint32_t ttc::LTC::ReadControlWord() const
+{
+  return Read(LTCAdd::CONTROL);
+}
+
+
+void ttc::LTC::SendControlWord()
+{
+  if (L1Aenabled_)
+  {
+    Write(LTCAdd::CONTROL, control_, "(CONROL Word (on))");
+  }
+  else
+  {
+    uint32_t dum = control_;
+
+    // Switch the non-permanent cyclic generators off.
+    SetBit_off(dum, CNTRLBIT_ENABLE_CYLIC);
+    SetBit_off(dum, CNTRLBIT_ENABLE_RAMTRIG);
+    SetBit_off(dum, CNTRLBIT_EXT0);
+    SetBit_off(dum, CNTRLBIT_EXT1);
+    SetBit_off(dum, CNTRLBIT_EXT2);
+    SetBit_off(dum, CNTRLBIT_EXT3);
+    SetBit_off(dum, CNTRLBIT_EXT4);
+    SetBit_off(dum, CNTRLBIT_EXT5);
+    // Start cyclic triggers.
+    SetBit_off(dum, CNTRLBIT_STARTBIT_L1A);
+    // Start cyclic BGOs.
+    SetBit_off(dum, CNTRLBIT_STARTBIT_BGO);
+
+    Write(LTCAdd::CONTROL, dum, "(CONROL Word (off))");
+  }
+}
+
+
+uint32_t ttc::LTC::GetControlWord() const
+{
+  return control_;
+}
+
+
+void ttc::LTC::EnableExternalTrigger(const size_t i, const bool Enable)
+{
+  if (i >= Nextern())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::EnableExternalTrigger(i=" <<i << ", ...): invalid arg i=" << i);
+    return;
+  }
+  SetBit(control_, CNTRLBIT_EXT(i), Enable);
+  SendControlWord();
+}
+
+
+bool ttc::LTC::IsExternalTriggerEnabled(const size_t i) const
+{
+  if (i >= Nextern())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::IsExternalTriggerEnabled(i=" << i << ", ...): invalid arg i=" << i);
+    return false;
+  }
+  return ((control_ >> CNTRLBIT_EXT(i)) & 1);
+}
+
+
+uint32_t ttc::LTC::ReadEventCounter() const
+{
+  return Read(LTCAdd::EVNCNT, "(Event Counter)") & 0xffffff;
+}
+
+
+uint32_t ttc::LTC::ReadTriggerCounter() const
+{
+  return Read(LTCAdd::TRIGCNT, "(Trigger Counter)");
+}
+
+
+uint32_t ttc::LTC::ReadOrbitCounter() const
+{
+  return Read(LTCAdd::ORBCNT, "(Orbit Counter)");
+}
+
+
+uint32_t ttc::LTC::ReadStrobeCounter() const
+{
+  return Read(LTCAdd::STRCNT, "(Strobe Counter)");
+}
+
+
+uint32_t ttc::LTC::ReadBlockedTriggersCounter() const
+{
+  return Read(LTCAdd::BTCNT, "(Blocked triggers)");
+}
+
+
+void ttc::LTC::ResetCounters(unsigned cntrs)
+{
+  Write(LTCAdd::CNTRST, cntrs & LTC_RESET_ALLCOUNTERS, "(Counter reset)");
+  if (cntrs & LTC_RESET_TRIGGER)
+    Write(LTCAdd::MAXTRIG, ReadTriggerCounter());
+
+  // Reset the cancel counter.
+  if (cntrs & LTC_RESET_CANCELLED)
+  {
+    SetBit_on(control_, CNTRLBIT_RESET_CANCELCNTR);
+    SendControlWord();
+    // Clear the bit again.
+    SetBit_off(control_, CNTRLBIT_RESET_CANCELCNTR);
+    SendControlWord();
+  }
+  orb0 = evt0 = blockedevt0 = bgo0 = can0 = 0;
+  time(&mont0);
+  // Reset the Evt FIFO:
+  ResetEventFIFO();
+}
+
+
+void ttc::LTC::ResetEventFIFO()
+{
+  uint32_t ctrl = Read(LTCAdd::CONTROL, "(Reset Evt FIFO)");
+  Write(LTCAdd::CONTROL, ctrl | (1 << CNTRLBIT_RESET_EVTFIFO), "(Reset Evt FIFO)");
+  Write(LTCAdd::CONTROL, ctrl & ~(1 << CNTRLBIT_RESET_EVTFIFO), "(Reset Evt FIFO)");
+}
+
+
+ttc::RAMTriggers*
+ttc::LTC::GetRAMTriggers()
+{
+  return ram_triggers;
+}
+
+
+ttc::BGOChannel* ttc::LTC::GetBGOChannel(const size_t channel)
+{
+  if (channel >= NChannels())
+  {
+    ; // error
+    stringstream my;
+    my << "ERROR: LTC::GetBGOChannel(channel=\"" << channel << "\"): Invalid argument!";
+    throw std::invalid_argument(my.str());
+  }
+  return &(bgo[channel]);
+}
+
+
+uint32_t ttc::LTC::GetVMEBGOBX() const
+{
+  return VMEbx;
+}
+
+
+void ttc::LTC::SetVMEBX(const uint32_t bx)
+{
+  VMEbx = bx;
+}
+
+
+bool ttc::LTC::IsCyclicTrigEnabled() const
+{
+  return (CyclicTrigOn);
+}
+
+
+void ttc::LTC::SetL1ATicket(unsigned num)
+{
+  l1aticket = num;
+  if (num)
+  {
+    Write(LTCAdd::MAXTRIG, ReadTriggerCounter(), "(SetL1ATicket)");
+  }
+  SetBit(control_, CNTRLBIT_MAXTRIG, (num > 0));
+  SendControlWord();
+}
+
+
+unsigned ttc::LTC::GetL1ATicket() const
+{
+  return l1aticket;
+}
+
+
+unsigned ttc::LTC::GetMaxTrigger() const
+{
+  return Read(LTCAdd::MAXTRIG);
+}
+
+
+void ttc::LTC::SendL1ATicket()
+{
+  Write(LTCAdd::MAXTRIG, ReadTriggerCounter() + l1aticket, "(SendL1ATicket)");
+  if (!GetL1ATicket())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::SendL1ATicket() called "
+    "but trigger burst not enabled");
+  }
+}
+
+
+void ttc::LTC::StartRAMTrigs()
+{
+  if (L1Aenabled_)
+  {
+    SetBit_on(control_, CNTRLBIT_START_RAMTRIG);
+    SendControlWord();
+    SetBit_off(control_, CNTRLBIT_START_RAMTRIG);
+    SendControlWord();
+  }
+}
+
+
+void ttc::LTC::StopRAMTrigs()
+{
+  SetBit_off(control_, CNTRLBIT_ENABLE_RAMTRIG);
+  SendControlWord();
+}
+
+
+void ttc::LTC::EnableCyclicTrig(bool enable)
+{
+  CyclicTrigOn = enable;
+}
+
+
+bool ttc::LTC::IsRAMTrigEnabled() const
+{
+  return ((control_ >> CNTRLBIT_ENABLE_RAMTRIG) & 1) == 1;
+}
+
+
+void ttc::LTC::EnableRAMTrig(bool enable)
+{
+  SetBit(control_, CNTRLBIT_ENABLE_RAMTRIG, enable);
+  SendControlWord();
+}
+
+
+void ttc::LTC::EnableL1A(const bool enable)
+{
+  L1Aenabled_ = enable;
+  SendControlWord();
+  StartRAMTrigs();
+}
+
+
+bool ttc::LTC::IsL1AEnabled() const
+{
+  return L1Aenabled_;
+}
+
+
+uint32_t ttc::LTC::BoardStatus() const
+{
+  return Read(LTCAdd::STATUS);
+}
+
+
+bool ttc::LTC::OrbitInSync() const
+{
+  return (((BoardStatus() >> 31) & 1) ? true : false);
+}
+
+
+uint32_t ttc::LTC::CancelledTriggers() const
+{
+  return (Read(LTCAdd::TRR_CANC, "(CancelledTriggers())") & 0xffff);
+}
+
+
+void ttc::LTC::SetQPLLExternal(bool external)
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  const uint32_t oldqpll = qpll;
+  SetBit(qpll, QPLLEXTERNAL_BIT, !external);
+  if (oldqpll != qpll)
+  {
+    Write(LTCAdd::QPLLCTRL, qpll, "(SetQPLLExternal())");
+  }
+}
+
+
+void ttc::LTC::ResetQPLL(bool doReset)
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  const uint32_t oldqpll = qpll;
+
+  SetBit(qpll, QPLLRESET_BIT, !doReset);
+  if (oldqpll != qpll)
+    Write(LTCAdd::QPLLCTRL, qpll, "(ResetQPLL())");
+
+  if (doReset)
+  {
+    // Clear the reset state automatically after a while remark: for
+    // the TTCci, it looks to me like the firmware is clearing the
+    // reset state by itself..
+    ttc::wait(100); // wait 0.1 seconds
+    ResetQPLL(false); // then set it back to 0 again
+  }
+}
+
+
+void ttc::LTC::AutoRestartQPLL(bool enable)
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  const uint32_t oldqpll = qpll;
+  SetBit(qpll, QPLLAUTORESTART_BIT, enable);
+  if (oldqpll != qpll)
+  {
+    Write(LTCAdd::QPLLCTRL, qpll, "(AutoRestartQPLL())");
+  }
+}
+
+
+void ttc::LTC::SetQPLLFrequencyBits(uint32_t freq, bool only4LSBs)
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  const uint32_t oldqpll = qpll;
+  for (size_t i = 0; i < (only4LSBs ? 4 : 6); ++i)
+  {
+    SetBit_off(qpll, i);
+  }
+  qpll |= ((freq) & (only4LSBs ? 0xf : 0x3f));
+  if (oldqpll != qpll)
+  {
+    Write(LTCAdd::QPLLCTRL, (qpll), "(SetQPLLFrequencyBits())");
+  }
+}
+
+
+uint32_t ttc::LTC::GetQPLLFrequencyBits() const
+{
+  bool only4LSBs = IsQPLLExternal();
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL, "(GetQPLLFrequencyBits)");
+  return (qpll & (only4LSBs ? 0xf : 0x3f));
+}
+
+
+bool ttc::LTC::PeriodicSequenceEnabled() const
+{
+  return ThreadParameters.Periodic.enabled;
+}
+
+
+double ttc::LTC::Periodicity() const
+{
+  return ThreadParameters.Periodic.waitNsec;
+}
+
+
+size_t ttc::LTC::NCyclicTrigger() const
+{
+  return _n_ctg;
+}
+
+
+size_t ttc::LTC::NCyclicBGO() const
+{
+  return _n_cbg;
+}
+
+
+bool ttc::LTC::IsQPLLExternal() const
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  return (((qpll >> QPLLEXTERNAL_BIT) & 1) == 0);
+}
+
+
+bool ttc::LTC::Is_ResetQPLL() const
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  return (((qpll >> QPLLRESET_BIT) & 1) == 0);
+}
+
+
+bool ttc::LTC::Is_AutoRestartQPLL() const
+{
+  uint32_t qpll = Read(LTCAdd::QPLLCTRL);
+  return (((qpll >> QPLLAUTORESTART_BIT) & 1) == 1);
+}
+
+
+void ttc::LTC::ExecuteVMEBGO(const int8_t ibgo, const int32_t BX)
+{
+  if (ibgo > 0xf)
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::ExecuteVMEBGO(): argument ibgo=" << ibgo << " out of range. (rangeg is [0, 15])");
+  }
+  uint32_t realbx = RollOver(int32_t(BX >= 0 ? BX : VMEbx) - int32_t(BTimeCorrection_));
+  Write(LTCAdd::VMEBGO, ((realbx << 16) | (ibgo & 0xf)), "(VME-BGO)");
+
+  if (ibgo == bgo_map->Get_OCntReset_BGOCh() || ibgo == bgo_map->Get_HardReset_BGOCh()
+      || ibgo == bgo_map->Get_Resynch_BGOCh())
+  {
+    orb0 = ReadOrbitCounter();
+    evt0 = ReadTriggerCounter();
+    blockedevt0 = ReadBlockedTriggersCounter();
+    can0 = CancelledTriggers();
+    bgo0 = ReadStrobeCounter();
+  }
+}
+
+
+void ttc::LTC::ExecuteVMETrigger()
+{
+  Write(LTCAdd::VMEBGO, 0x10, "(VME-Trigger)");
+}
+
+
+void ttc::LTC::StartCyclicGenerators()
+{
+  // Set L1A and BGO generator start bit.
+  SetBit_on(control_, CNTRLBIT_ENABLE_CYLIC);
+  if (CyclicTrigOn)
+    SetBit_on(control_, CNTRLBIT_STARTBIT_L1A);
+  SetBit_on(control_, CNTRLBIT_STARTBIT_BGO);
+
+  SendControlWord(); // write control word to LTC register
+
+  // Clear the L1A and BGO generator start bits again.
+  SetBit_off(control_, CNTRLBIT_STARTBIT_L1A);
+  SetBit_off(control_, CNTRLBIT_STARTBIT_BGO);
+
+  SendControlWord(); // write control word to LTC register
+}
+
+
+void ttc::LTC::StopCyclicGenerators()
+{
+  SetBit_off(control_, CNTRLBIT_STARTBIT_L1A);
+  SetBit_off(control_, CNTRLBIT_STARTBIT_BGO);
+  SetBit_off(control_, CNTRLBIT_ENABLE_CYLIC);
+  SendControlWord();
+}
+
+
+void ttc::LTC::StopAllCyclicGenerators()
+{
+  StopCyclicGenerators();
+  ResetInternalTrigsAndAllCyclicGenerators();
+}
+
+
+void ttc::LTC::StartPermanentCyclicGenerators()
+{
+  uint32_t dum = Read(LTCAdd::CONTROL, "(StartPermanentCyclic)");
+  if (((dum >> CNTRLBIT_ENABLE_CYLIC) & 1) == 0)
+  {
+    SetBit_on(dum, CNTRLBIT_ENABLE_CYLIC);
+    Write(LTCAdd::CONTROL, dum, "(StartPermanentCyclic)");
+    SetBit_off(dum, CNTRLBIT_ENABLE_CYLIC);
+    Write(LTCAdd::CONTROL, dum, "(StartPermanentCyclic)");
+  }
+}
+
+
+void ttc::LTC::Configure(istream& in)
+{
+  LTCConfiguration config(*this);
+
+  try {
+    config.Configure(in);
+  }
+  catch (xcept::Exception& e)
+  {
+    XCEPT_RETHROW(
+        xcept::Exception,
+        "LTCConfiguration::Configure failed", e);
+  }
+}
+
+
+void ttc::LTC::WriteConfiguration(ostream& out, const string& comment)
+{
+  out << "###########################################################" << endl;
+  out << "#" << endl;
+  out << "# LTC configuration." << endl;
+  out << "#" << endl;
+  if (comment.size() > 0)
+  {
+    out << "# " << comment << endl;
+    out << "#" << endl;
+  }
+  out << "# Automatically created with LTC::WriteConfiguration() " << endl;
+  out << "# from current configuration on " << CurrentTime() << "" << endl;
+  out << "# with LTC software version " << TTCLTC_VERSION_MAJOR
+  << "." << TTCLTC_VERSION_MINOR
+  << "." << TTCLTC_VERSION_PATCH <<endl;
+  out << "# " << endl;
+  out << "# (Comments (will be ignored) are indicated by \"#\". Lines" << endl
+      << "#  can be split using the '\\' character at end of 1st line.)" << endl;
+  out << "# " << endl;
+  out << "###########################################################" << endl;
+  out << endl;
+  out << "# QPLL Clock Control: " << endl;
+  out << "# parameters: EXTERNAL|INTERNAL" << endl;
+  out << "#             " << WORD_QPLLRESET << "YES|NO" << endl;
+  out << "#             " << WORD_QPLLAUTORESTART << "YES|NO" << endl;
+  out << "#             " << WORD_QPLLFREQBITS << "0x??" << " (4 (6) bits for EXTERNAL (INTERNAL) mode)" << endl;
+  out << "# e.g." << endl;
+  out << "# " << WORD_QPLL << " EXTERNAL " << WORD_QPLLAUTORESTART << "YES " << WORD_QPLLFREQBITS << "0x0"
+      << "\t# for external clock" << endl;
+  out << "# " << WORD_QPLL << " INTERNAL " << WORD_QPLLFREQBITS << "0x20" << endl;
+  out << WORD_QPLL << " " << (IsQPLLExternal() ? WORD_QPLLEXTERNAL : WORD_QPLLINTERNAL) << " " << WORD_QPLLRESET
+      << (Is_ResetQPLL() ? "YES" : "NO") << " " << WORD_QPLLAUTORESTART << (Is_AutoRestartQPLL() ? "YES" : "NO") << " "
+      << WORD_QPLLFREQBITS << "0x" << hex << GetQPLLFrequencyBits() << dec << endl;
+  out << "" << endl;
+
+  // Trigger selection.
+  out << "# Trigger Selection (key word: " << WORD_TRIGGERS << "):" << endl;
+  out << "# parameters are: 0..5 for external triggers, " << WORD_TRIGGERS_RAM << " for RAM-Trigger," << endl;
+  out << "# and " << WORD_TRIGGERS_CYCLIC << " to enable cyclic triggers" << endl;
+  out << "# E.G.: " << endl;
+  out << "# " << WORD_TRIGGERS << " 0 2 5 " << WORD_TRIGGERS_RAM << " " << WORD_TRIGGERS_CYCLIC
+      << " # enables RAM, CYCLIC and ext. " << "triggers 0,2, & 5" << endl;
+  out << WORD_TRIGGERS;
+  for (size_t i = 0; i < Nextern(); ++i)
+    if (IsExternalTriggerEnabled(i))
+      out << " " << i;
+  if (IsCyclicTrigEnabled())
+    out << " " << WORD_TRIGGERS_CYCLIC;
+  if (IsRAMTrigEnabled())
+    out << " " << WORD_TRIGGERS_RAM;
+  out << endl << endl;
+
+  // Trigger Names:
+  out << "# GIVE EXTERNAL TRIGGERS A RECOGNIZABLE NAME:" << endl;
+  out << "# e.g.: " << WORD_TRIGGERNAME << " i Cosmic_Trigger # i out of [0," << Nextern() - 1 << ")" << endl
+      << "# (don't use blanks or symbols like <,>,#,\\)" << endl;
+  for (size_t i = 0; i < Nextern(); ++i)
+  {
+    out << WORD_TRIGGERNAME << " " << i << " " << GetTriggerName(i) << "\t# Name of " << i + 1 << "-th HW trigger ("
+        << (i < 2 ? "nim" : "lvds") << ")" << endl;
+  }
+  out << endl;
+
+  // EXTERNAL TRIGGER DELAYS:
+  out << "# EXTERNAL TRIGGER DELAYS" << endl;
+  out << "# Set delays (between 0 and " << (ReadFirmwareVersion() < 0x14 ? "15.5" : "31.5")
+      << " in steps of 0.5 clocks) for" << endl;
+  out << "# external triggers using e.g.: " << endl;
+  out << "# " << WORD_TRIGGER_DELAY << " 3 5.5\t# 5.5 clock delay for " << "ext. trig. no. 3";
+  vector<float> delays = GetHWInputDelays();
+  for (size_t i = 0; i < delays.size(); ++i)
+  {
+    if (delays[i] > 0.0)
+      out << endl << WORD_TRIGGER_DELAY << " " << i << " " << delays[i] << "\t# delay in BX for ext. trig. no. " << i;
+  }
+  out << endl << endl;
+
+  out << "# To enable triggers only for fixed size bursts\n" << "# L1ATICKET n         sets burst size to n\n"
+      << "# L1ATICKET 0 or OFF  disables burst mode\n" << WORD_TRIGTICKET << " " << GetL1ATicket() << endl << endl;
+
+  // RAM Trigger:
+  out << "# RAM TRIGGER SECTION (needs arg \"" << WORD_TRIGGERS_RAM << "\" in trigger selection \"" << WORD_TRIGGERS
+      << "\")" << endl;
+  out << "# Set (last) trigger to 1 to stop trigger sequence." << endl;
+  out << "# (last) trigger = 0 ==> repetitive sequence (default)" << endl;
+  out << "# e.g. with N>0 lines like: '" << WORD_TRIGGER_INTERVAL << " 0x20'" << endl;
+  out << "# or with '" << WORD_TRIGGER_FREQUENCY << " 1.5 " << WORD_TRIGGER_FREQUENCY_MODE << "XXXX'" << endl;
+  out << "# where 'XXXX' can be 'EQUI' (equidistant) or 'RANDOM'" << endl;
+  if (ram_triggers->triggerFrequency < 0.0)
+  {
+    for (size_t i = 0; i < ram_triggers->triggerdelay.size(); ++i)
+    {
+      out << WORD_TRIGGER_INTERVAL << "  0x" << hex << ram_triggers->triggerdelay[i] << dec << endl;
+      out << "# " << WORD_TRIGGER_FREQUENCY << " 10000" << " " << WORD_TRIGGER_FREQUENCY_MODE << "EQUI"
+          << "   # in Hz, " << WORD_TRIGGER_FREQUENCY_MODE << "EQUI or " << WORD_TRIGGER_FREQUENCY_MODE << "RANDOM"
+          << endl;
+    }
+  }
+  else
+  {
+    out << "# " << WORD_TRIGGER_INTERVAL << " 0x5784" << endl;
+    out << WORD_TRIGGER_FREQUENCY << " " << ram_triggers->triggerFrequency << " " << WORD_TRIGGER_FREQUENCY_MODE
+        << (ram_triggers->randomTrigger ? "RANDOM" : "EQUI") << "   # in Hz, " << WORD_TRIGGER_FREQUENCY_MODE
+        << "EQUI or " << WORD_TRIGGER_FREQUENCY_MODE << "RANDOM" << endl;
+  }
+  out << "" << endl;
+
+  //WORD_VMEBX
+  out << "# Timing of VME-BGOs (bunch crossing): e.g. \"" << WORD_VMEBX << " 150\"" << endl;
+  out << WORD_VMEBX << " " << GetVMEBGOBX() << endl;
+  out << "" << endl;
+
+  //MONITORING
+  out << "# LTC MONITORING (sampling through VME):" << endl;
+  out << "# usage: " << WORD_MONITORING << " enable|disable " << WORD_MONITORING_INTERVAL << "n" << endl;
+  out << "# where n is the interval between 2 reads in seconds." << endl;
+  out << WORD_MONITORING << " " << (IsMonitoringEnabled() ? "enable" : "disable") << " " << WORD_MONITORING_INTERVAL
+      << GetMonitoringInterval() << endl << endl;
+  out << endl;
+
+  //RUN LOG
+  out << "# Path where to store the runlog (optional):" << endl;
+  if (runlog.size() > 0)
+  {
+    out << WORD_RUNLOG << " " << runlog << endl;
+  }
+  else
+  {
+    out << "# " << WORD_RUNLOG << " /path/to/logfile" << endl;
+  }
+  out << endl;
+
+  //RUN LOG
+  out << "# Do you want to dump the event FIFO (optional):" << endl;
+  out << "# Usage: " << WORD_FIFODUMP << " ON|OFF /path/to/file # run no. will be appended to filename" << endl;
+  out << WORD_FIFODUMP << " " << (dumpevtstofile_setonenable ? "ON" : "OFF");
+  if (1 || dumpevtstofile_setonenable)
+  {
+    out << " " << dumpevtstofilepath_prefix;
+  }
+  out << endl << endl;
+
+  //BST vs VME GPS
+  out << "# BST (Beam Synchronous GPS Time):" << endl;
+  out << "# If no BST signal from the LHC is present, the LTC can take the network" << endl
+      << "# time instead (for option \"enable\") through VME:" << endl;
+  out << "# usage: " << WORD_BSTVME << " enable|disable " << endl;
+  out << "# where n is the interval between 2 time updates in seconds." << endl;
+  out << WORD_BSTVME << " " << (IsBSTGPSviaVME() ? "enable" : "disable") << endl;
+  out << "" << endl;
+
+  //BACKPRESSEURE FROM SLINK
+  out << "# HOW TO ACT UPON BACK-PRESSURE ON THE SLINK:" << endl;
+  out << "# If you want the triggers to stop (does not apply to VME " << endl
+      << "# triggers), then chose \"no\", otherwise \"yes\"" << endl;
+  out << WORD_SLINKBACKPRESSURE << " " << (IsSlinkBackpressureIgnored() ? "yes" : "no") << "  # yes|no" << endl;
+  out << "" << endl;
+
+  { // TTS MASK:
+    out << "#### TTS CONFIGURATION #########################################" << endl;
+    out << "# Enable TTS input using key word \"" << WORD_TTS_ENABLE << "\" " << endl
+        << "# with optional arguments sTTS0, sTTS1, ... , sTTS5, and aTTS, e.g.:" << endl << "# " << WORD_TTS_ENABLE
+        << " sTTS0 aTTS   # enables 1st sTTS partition and aTTS" << endl;
+    out << WORD_TTS_ENABLE;
+    for (size_t i = 0; i < NTTS(); ++i)
+    {
+      if (IsTTSEnabled(i))
+      {
+        out << " ";
+        if (i == NTTS() - 1)
+          out << "aTTS";
+        else
+          out << "sTTS" << i;
+      }
+    }
+    out << endl << endl;
+    out << "# TTS \"Warning\" Interval (e.g. " << WORD_TTS_WARNINT << " <N>) in BX:" << endl;
+    out << WORD_TTS_WARNINT << " " << dec << GetWarningInterval() << "  # [BX]" << endl << endl;
+  }
+
+  { //BX GAPS
+    out << "# ARTIFICIALLY IMPOSE BX GAPS (does NOT block internally generated triggers!):" << endl;
+    out << "# usage: " << endl;
+    out << "# " << WORD_BXGAP << " N0 [N1] # disables L1As for BX N0 (or range [N0,N1))" << endl;
+    out << "# (N0>0, N1<=" << NClocksPerOrbit() << ", N0>N1 or N1=0 (=until end of orbit))" << endl;
+    vector<size_t> begin, end;
+    GetBXGaps(begin, end);
+    for (size_t i = 0; i < begin.size(); ++i)
+    {
+      if (1 /*end[i]>begin[i]+1*/)
+        out << WORD_BXGAP << " " << begin[i] << " " << end[i] << endl;
+      else
+        out << WORD_BXGAP << " " << begin[i] << endl;
+    }
+    out << endl;
+  }
+
+  { // Sequences
+    out << "################################################################" << endl;
+    out << "# Configuration of sequences. Individual sequences can be " << "configured for " << endl
+        << "# 'coldReset', 'configure', 'enable', 'suspend', 'stop'," << endl
+        << "# 'resync', 'hardReset', and 'periodic' (predefined)" << endl;
+    out << "# or for any user-defined sequence (use \"" << WORD_SEQUENCE_ADDNEW << " ChooseName\" first)" << endl;
+    out << "# Example: " << endl << "#   " << WORD_SEQUENCE_BEGIN << " 'enable' \t# or 'configure', 'suspend', ..."
+        << endl << "#   ResetCounters \t\t# resets evt+orb cntrs. (on LTC only!)" << endl
+        << "#   ResetCounters all\t\t# resets evt+orb+trigger cntrs. (on LTC only!)" << endl
+        << "#   Cyclic StartPermanent \t# Start permanent (e.g.BC0) cyclic generators" << endl
+        << "#   Cyclic StopAll\t\t# Stop ALL (also permanent) cyclic generators" << endl
+        << "#   Cyclic Start\t\t# Start (all) cyclic generators" << endl
+        << "#   Cyclic Stop \t\t# Stop non-permanent cyclic generators" << endl << "#   Sleep 5 \t\t\t# sleep for 5 sec"
+        << endl << "#   mSleep 10 \t\t\t# sleep for 10 ms" << endl << "#   uSleep 100\t\t\t# sleep for 10 us" << endl
+        << "#   EnableL1A \t\t\t# or DisableL1A e.g. for 'Suspend' Sequence" << endl
+        << "#   BGO 5 \t\t\t# BGO-Channel 5 request through VME\t" << endl
+        << "#   BGO Start \t\t\t# BGO-Channel 9 request through VME\t" << endl
+        << "#   NewRun  \t\t\t# Increment the run number" << endl
+        << "#   Periodic On \t\t# (On|Off) Use Periodic seq. with care!!!" << endl
+        << "#   Periodic 60  \t\t# periodicity of Periodic sequence: 60 sec" << endl
+        << "#   Saveplots    \t\t# save monitoring plots, if available" << endl
+        << "#   Write [i] ADDRESS 0xfff \t# Write 0xffff to reg. ADDRESS (offset i)" << endl
+        << "#   Read [i] ADDRESS \t\t# Read from reg. ADDRESS (offset i)" << endl
+        << "#   EnableCyclicBgo <number>\t# enable a single cyclic BGO generator" << endl
+        << "#   EnableCyclicTrigger <number>\t# enable a single cyclic Trigger generator" << endl
+        << "#   DisableCyclicBgo <number>\t# disable a single cyclic BGO generator" << endl
+        << "#   DisableCyclicTrigger <number>\t# disable a single cyclic trigger generator" << endl << "#   "
+        << WORD_SEQUENCE_END << "\t\t\t# closes this sequence" << endl;
+
+    const vector<string> seqs = GetSequenceNames();
+
+    for (size_t k = 0; k < seqs.size(); ++k)
+    {
+      string sname = seqs[k];
+
+      Sequence* seq = 0;
+      try {
+        seq = GetSequence(sname);
+      }
+      catch(ttc::exception::UndeclaredSequence& e)
+      {
+        continue;
+      }
+
+      out << endl;
+
+      if (!seq->IsPermanent())
+      {
+        out << WORD_SEQUENCE_ADDNEW << " " << seq->GetName() << endl;
+      }
+
+      out << WORD_SEQUENCE_BEGIN << " " << sname << endl;
+      for (size_t j = 0; j < seq->N(); ++j)
+      {
+        out << "  " << seq->Get(j) << endl;
+      }
+      out << WORD_SEQUENCE_END << endl;
+    }
+
+    out << endl;
+  }
+
+  {
+    out << "################################################################" << endl;
+    out << "# Cyclic Trigger and BGO Generators" << endl;
+    out << "# Usage: " << WORD_CYCLICGEN_TRIGGER << " id [arguments]" << endl;
+    out << "#    or: " << WORD_CYCLICGEN_BGO << " id [arguments]" << endl;
+    out << "# where id denotes the generator, i.e. 0..2 for TRIGGER and " << endl << "# 0..4 for BGO generators."
+        << endl;
+    out << "# The following arguments can be appended to these commands:";
+    out << endl << "#   DISABLE \t\t# Allows set parameters without enabling" << endl << "#   "
+        << WORD_CYCLICGEN_STARTBX << "i \t\t# i=Offset in BX" << endl << "#   " << WORD_CYCLICGEN_PRESCALE
+        << "i \t\t# i=prescale" << endl << "#   " << WORD_CYCLICGEN_POSTSCALE << "i \t\t# i=postscale (# of times)"
+        << endl << "#   " << WORD_CYCLICGEN_INITPRECALE << "i \t\t# i=initial orbits to wait" << endl << "#   "
+        << WORD_CYCLICGEN_REPETITIVE << "y|n \t# repeat sequence" << endl << "#   " << WORD_CYCLICGEN_PAUSE
+        << "i \t\t# pause i orbits (for " << WORD_CYCLICGEN_REPETITIVE << "y)" << endl << "#   "
+        << WORD_CYCLICGEN_PERMANENT << "y|n \t# don't listen to BGO Start/Stop" << endl << "#   "
+        << WORD_CYCLICGEN_CHANNEL << "i|Name \t\t# BGO channel or name. For BGO only!" << endl
+        << "# The argument CH denotes the BGO channel to be requested." << endl
+        << "# Its value can either be a number (0..15) or the channel " << endl
+        << "# name, e.g. Resync, HardReset, EC0, OC0, Start, Stop, TestEnable, " << endl
+        << "# PrivateGap, or PrivateOrbit" << endl << "#" << endl;
+    for (size_t i = 0; i < 2; ++i)
+    {
+      const bool trigger = (i == 0);
+      for (size_t j = 0; j < (trigger ? NCyclicTrigger() : NCyclicBGO()); ++j)
+      {
+        CyclicTriggerOrBGO* cycl = GetCyclic(trigger, j);
+        if (!cycl->Changed())
+          continue;
+        out << (trigger ? WORD_CYCLICGEN_TRIGGER : WORD_CYCLICGEN_BGO) << " " << dec << j;
+        if (!trigger)
+        {
+          const size_t ch = cycl->GetBChannel();
+          string name = bgo[ch].GetName();
+          if (name[0] == 'C' && name[1] == 'h' && name[2] == 'a')
+          {
+            stringstream s;
+            s << ch;
+            name = s.str();
+          }
+          out << " " << WORD_CYCLICGEN_CHANNEL << name << dec;
+        }
+        if (cycl->GetStartBX() != 0)
+          out << " " << WORD_CYCLICGEN_STARTBX << dec << cycl->GetStartBX();
+        if (cycl->GetPrescale() != 0)
+          out << " " << WORD_CYCLICGEN_PRESCALE << cycl->GetPrescale();
+        if (cycl->GetPostscale() != 0)
+          out << " " << WORD_CYCLICGEN_POSTSCALE << cycl->GetPostscale();
+        if (cycl->GetInitialPrescale() != 0)
+          out << " " << WORD_CYCLICGEN_INITPRECALE << cycl->GetInitialPrescale();
+        if (cycl->GetPause() != 0)
+          out << " " << WORD_CYCLICGEN_PAUSE << cycl->GetPause();
+        //if (!cycl->IsRepetitive())
+        out << " " << WORD_CYCLICGEN_REPETITIVE << (cycl->IsRepetitive() ? "y" : "n");
+        if (1 || !cycl->IsPermanent())
+          out << " " << WORD_CYCLICGEN_PERMANENT << (cycl->IsPermanent() ? "y" : "n");
+        if (!cycl->IsEnabled())
+        {
+          out << " DISABLE ";
+        }
+        out << endl;
+      }
+    }
+    out << endl;
+  }
+
+  { // Trigger Rules:
+    out << "# TRIGGER RULE SETTINGS ###################################" << endl;
+    out << "# There are " << TriggerRuleSize() - FirstTriggerRule() << " that can be changed using e.g.:" << endl;
+    out << "# " << WORD_TRIGRULE << " i N_BX   # i = " << FirstTriggerRule() << "..." << TriggerRuleSize() - 1
+        << ", N_BX = Min no. of clocks for i triggers" << endl << endl;
+    for (size_t i = 0; i < TriggerRuleSize(); ++i)
+    {
+      out << WORD_TRIGRULE << " " << (i + FirstTriggerRule()) << " " << GetTriggerRule(i + FirstTriggerRule())
+          << " \t#No more than i trigs in j BX" << endl;
+    }
+  }
+
+  out << endl;
+  out << "########### CONFIGURATION END #############################" << endl;
+}
+
+
+void ttc::LTC::ExecuteSequence(const string& identifier)
+{
+  MutexHandler h(periodicmutex);
+
+  Sequence* mySeq = GetSequence(identifier);
+
+  LOG4CPLUS_INFO(logger_, "Sequence '" << identifier << "' has N(commands)=" << mySeq->N());
+
+  if (mySeq->IsPermanent() && (mySeq->GetName() != "periodic"))
+  {
+    // Save this in monitoring also.
+    monitor.NewState(identifier);
+  }
+
+  if (mySeq->GetName() == "enable" && DefaultFIFODumpEnabled())
+  {
+    stringstream g;
+    g << FIFODumpPrefix() << "_" << dec << GetRunNumber() << ".dat";
+    SetFilePathForFIFODump(true, g.str());
+  }
+
+  for (size_t i = 0; i < mySeq->N(); ++i)
+  {
+    ExecuteSequenceLine(mySeq->Get(i));
+  }
+}
+
+
+void ttc::LTC::ExecuteSequenceLine(const string& line)
+{
+  string string_val;
+  uint32_t ulong_val = 0;
+  double double_val = 0;
+  string command, parname;
+
+  // Convert everything to lower case so we don't have to do a case insensitive search.
+  string normline= to_lower(line);
+
+  if (FindString(normline, (command = "monitoring"), string_val))
+  {
+    if (GetDouble(normline, command, double_val))
+    {
+      ThreadParameters.Monitoring.newSetup = true;
+      ThreadParameters.Monitoring.waitNsec = double_val;
+
+      LOG4CPLUS_INFO(logger_,
+          "LTC: Setting Monitoring interval to " << double_val << "sec. " << (double_val<0.0? "< 0 --> NEVER" : ""));
+    }
+    else
+    {
+      if (string_val == "on")
+      {
+        ThreadParameters.Monitoring.newSetup = true;
+        ThreadParameters.Monitoring.enabled = true;
+        LOG4CPLUS_INFO(logger_, "LTC: Switching on monitoring");
+      }
+      else if (string_val == "off")
+      {
+        ThreadParameters.Monitoring.newSetup = true;
+        ThreadParameters.Monitoring.enabled = false;
+        LOG4CPLUS_INFO(logger_, "LTC: Switching off monitoring");
+      }
+      else
+      {
+        failParseSequenceLineInvalidParam(line, command, string_val);
+      }
+    }
+  }
+
+  else if (FindString(normline, (command = "newrun"), string_val))
+  {
+    IncrementRunNumber();
+  }
+
+  else if (FindString(normline, command = "enablecyclicbgo", string_val)
+      || FindString(normline, command = "enablecyclictrigger", string_val)
+      || FindString(normline, command = "disablecyclicbgo", string_val)
+      || FindString(normline, command = "disablecyclictrigger", string_val))
+  {
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      bool enable = command.find("enable") == 0;
+      bool is_trigger = command.find("cyclictrigger") != string::npos;
+
+      ostringstream cyclicName;
+      cyclicName << "cyclic " << (is_trigger ? "trigger" : "bgo") << " generator ";
+
+      bool outOfRange =
+          (is_trigger && ulong_val >= NCyclicTrigger()) ||
+          (!is_trigger && ulong_val >= NCyclicBGO());
+
+      if (outOfRange)
+      {
+        XCEPT_RAISE(
+            xcept::Exception,
+            "invalid " + cyclicName.str() + "number '" + string_val +
+            "' in sequence line '" + line + "'");
+      }
+      else
+      {
+        LOG4CPLUS_INFO(logger_,
+            "LTC: " << (enable ? "enabling" : "disabling") << " " << cyclicName.str() << ulong_val);
+
+        GetCyclic(is_trigger, ulong_val)->SetEnable(enable);
+        WriteCyclicGeneratorToLTC(is_trigger, ulong_val);
+      }
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "cyclic"), string_val))
+  {
+    if (string_val == "startpermanent")
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Starting permanent cyclic generators");
+      StartPermanentCyclicGenerators();
+    }
+    else if (string_val == "stopall")
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Stopping all cyclic generators (also permanent ones)");
+      StopAllCyclicGenerators();
+    }
+    else if (string_val == "start")
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Starting non-permanent cyclic generators");
+      StartCyclicGenerators();
+    }
+    else if (string_val == "stop")
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Stopping non-permanent cyclic generators");
+      StopCyclicGenerators();
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "l1aticket"), string_val))
+  {
+    SendL1ATicket();
+  }
+
+  else if (FindString(normline, (command = "periodic"), string_val))
+  {
+    if (GetDouble(normline, command, double_val))
+    {
+      ThreadParameters.Periodic.newSetup = true;
+      ThreadParameters.Periodic.waitNsec = double_val;
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC: "
+          << "Setting period of \"Periodic\" sequence to " << double_val << "sec. "
+          << (double_val<0.0 ? "< 0 --> NEVER" : ""));
+    }
+    else
+    {
+      if (string_val == "on")
+      {
+        ThreadParameters.Periodic.newSetup = true;
+        ThreadParameters.Periodic.enabled = true;
+        LOG4CPLUS_INFO(logger_, "LTC: Switching \"Periodic\" sequence on");
+      }
+      else if (string_val == "off")
+      {
+        ThreadParameters.Periodic.newSetup = true;
+        ThreadParameters.Periodic.enabled = false;
+        LOG4CPLUS_INFO(logger_, "LTC: Switching \"Periodic\" sequence off");
+      }
+      else
+      {
+        failParseSequenceLineInvalidParam(line, command, string_val);
+      }
+    }
+  }
+
+  else if (FindString(normline, (command = "sendlongbdata"), string_val))
+  {
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Sending long BDATA: 0x" << hex << ulong_val << dec);
+      Write(LTCAdd::VMEDATL, ulong_val, "(SendLongBDATA)");
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "sendshortbdata"), string_val))
+  {
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Sending short BDATA: 0x" << hex << ulong_val << dec);
+      Write(LTCAdd::VMEDATS, ulong_val, "(SendShortBDATA)");
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "usleep"), string_val))
+  {
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Sleeping for " << ulong_val << " microseconds");
+      usleep(ulong_val);
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "msleep"), string_val))
+  {
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Sleeping for " << ulong_val << " milliseconds");
+      usleep(ulong_val * 1000);
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "sleep"), string_val))
+  {
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      LOG4CPLUS_INFO(logger_, "LTC: Sleeping for " << ulong_val << " seconds");
+      sleep(ulong_val);
+    }
+    else
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+  }
+
+  else if (FindString(normline, (command = "enablel1a"), string_val))
+  {
+    EnableL1A();
+    LOG4CPLUS_INFO(logger_, "LTC: Enabling L1A");
+  }
+
+  else if (FindString(normline, (command = "disablel1a"), string_val))
+  {
+    EnableL1A(false);
+    LOG4CPLUS_INFO(logger_, "LTC: Disabling L1A");
+  }
+
+  else if (FindString(normline, (command = "bgo"), string_val))
+  {
+    bool foundch = false;
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      foundch = true;
+    }
+    else if (FindString(normline, command, string_val))
+    {
+      for (size_t ib = 0; ib < NChannels(); ++ib)
+      {
+        if (bgo[ib].MatchesNameOrAlternative(string_val, false))
+        {
+          foundch = true;
+          ulong_val = ib;
+          break;
+        }
+      } // loop over all BGO channels
+    }
+
+    if (!foundch)
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+
+    if (ulong_val >= 16)
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "BGO Channel must be <16 in line '" + line + "'");
+    }
+
+    LOG4CPLUS_INFO(logger_, "LTC: Sending BGO " << ulong_val);
+    ExecuteVMEBGO(ulong_val);
+  }
+
+  else if (FindString(normline, (command = "resetcounters"), string_val))
+  {
+    if (L1Aenabled_)
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "Invalid request to reset counters while L1A is enabled, in sequence line '" + line + "'");
+    }
+
+    LOG4CPLUS_INFO(logger_, "LTC: Resetting counters");
+    if (string_val == "all")
+    {
+      ResetCounters(LTC_RESET_ALLCOUNTERS);
+    }
+    else
+    {
+      ResetCounters();
+    }
+  }
+
+  else if (FindString(normline, (command = "write"), string_val))
+  {
+    bool addrarray = false;
+    uint32_t addroffset = 0;
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      addrarray = true;
+      addroffset = ulong_val;
+      string_val = GetNthWord(2, normline);
+    }
+    else
+    {
+      string_val = GetNthWord(1, normline);
+    }
+
+    if (!GetUnsignedLong(normline, string_val, ulong_val))
+    {
+      failParseSequenceLineInvalidParam(line, command, string_val);
+    }
+
+    if (!addrarray)
+    {
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC: Writing 0x" << hex << setfill('0') << setw(8) << ulong_val <<
+          " --> '" << string_val << "'" << "\t"
+          "(addr. 0x" << hex << setfill('0') << setw(8)
+          << Address::findByName(Address::LTC, string_val).VMEAddress(0).getAddress()
+          << ")" << dec);
+
+      Write(string_val, ulong_val, "(Exec.Seq.Line)");
+    }
+    else
+    {
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC: Writing 0x" << hex << setfill('0') << setw(8) << ulong_val <<
+          " --> '" << string_val << "'," << "\t"
+          "offset=" << dec << addroffset << " "
+          "(addr. 0x" << hex << setfill('0') << setw(8)
+          << Address::findByName(Address::LTC, string_val).VMEAddress(addroffset).getAddress()
+          << ")" << dec);
+
+      Write(string_val, addroffset, ulong_val, "(Exec.Seq.)");
+    }
+  }
+
+  else if (FindString(normline, (command = "read"), string_val))
+  {
+    bool addrarray = false;
+    uint32_t addroffset = 0;
+    if (GetUnsignedLong(normline, command, ulong_val))
+    {
+      addrarray = true;
+      addroffset = ulong_val;
+      string_val = GetNthWord(2, normline);
+    }
+    else
+    {
+      string_val = GetNthWord(1, normline);
+    }
+    if (!addrarray)
+    {
+      ulong_val = Read(string_val, "(Exec.Seq.)");
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC: "
+          << "Reading 0x" << hex << setfill('0') << setw(8) << ulong_val
+          << " <-- '" << string_val << "'" << "\t(addr. 0x" << hex << setfill('0') << setw(8) << Address::findByName(Address::LTC, string_val).VMEAddress(0).getAddress() << ")" << dec);
+    }
+    else
+    {
+      ulong_val = Read(string_val, addroffset, "(Exec.Seq.)");
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC: "
+          << "Reading 0x" << hex << setfill('0') << setw(8) << ulong_val
+          << " <-- '" << string_val << "',\toffset=" << dec << addroffset << " (addr. 0x" << hex << setfill('0') << setw(8) << Address::findByName(Address::LTC, string_val).VMEAddress(addroffset).getAddress() << ")" << dec);
+    }
+  }
+
+  else
+  {
+    XCEPT_RAISE(
+        xcept::Exception,
+        "Unknown command in sequence line '" + line + "'");
+  }
+}
+
+
+void ttc::LTC::failParseSequenceLineInvalidParam(
+    const string& line,
+    const string& command,
+    const string& param)
+{
+  XCEPT_RAISE(
+      xcept::Exception,
+      "Unknown value '" + param + "' "
+      "for command '" + command + "' "
+      "in sequence line '" + line + "'");
+}
+
+
+void ttc::LTC::DumpEventFIFO(ostream* oo, bool html)
+{
+  LTCEventFIFO evts;
+  bool ok = GetFIFOEvents(evts);
+  if (!IsMonitoringEnabled())
+  {
+    monitor.SetEventFIFO(evts);
+  }
+  if (!oo)
+    return;
+  if (ok)
+  {
+    evts.print(*oo, html);
+    if (dumpevtstofile && dumpevtstofilepath.size() > 0)
+    {
+      evts.tofile(dumpevtstofilepath);
+    }
+  }
+  else
+  {
+    *oo << "No Events" << endl;
+  }
+}
+
+
+void ttc::LTC::UpdateMonitoring()
+{
+  LTCEventFIFO evts;
+  GetFIFOEvents(evts);
+
+  monitor.SetEventFIFO(evts);
+
+  if (dumpevtstofile && dumpevtstofilepath.size() > 0)
+  {
+    evts.tofile(dumpevtstofilepath);
+  }
+
+  // Rate Monitoring:
+  // Time since last update:
+  time_t mont1;
+  time(&mont1);
+
+  //TTS Status:
+  mont0 = mont1;
+}
+
+
+void ttc::LTC::EnableMonitoring(const bool enable)
+{
+  ThreadParameters.Monitoring.enabled = enable;
+  ThreadParameters.Monitoring.newSetup = true;
+}
+
+
+bool ttc::LTC::IsMonitoringEnabled() const
+{
+  return ThreadParameters.Monitoring.enabled;
+}
+
+
+void ttc::LTC::SetMonitoringInterval(const double dt)
+{
+  ThreadParameters.Monitoring.waitNsec = dt;
+  ThreadParameters.Monitoring.newSetup = true;
+}
+
+
+double ttc::LTC::GetMonitoringInterval() const
+{
+  return ThreadParameters.Monitoring.waitNsec;
+}
+
+
+ttc::CyclicTriggerOrBGO*
+ttc::LTC::GetCyclic(const bool trigger, const size_t i)
+{
+  if (trigger)
+  {
+    if (i > NCyclicTrigger())
+    {
+      LOG4CPLUS_ERROR(logger_,
+          "LTC::GetCyclic(trigger=" << trigger << ", i=" << i << "): " << "i > NCyclicTrigger()=" << NCyclicTrigger());
+      return (CyclicTriggerOrBGO*) 0;
+    }
+    return &(_ctg[i]);
+  }
+  else
+  {
+    if (i > NCyclicBGO())
+    {
+      LOG4CPLUS_ERROR(logger_,
+          "LTC::GetCyclic(trigger=" << trigger << ", i=" << i << "): " << "i > NCyclicBGO()=" << NCyclicBGO());
+      return (CyclicTriggerOrBGO*) 0;
+    }
+    return &(_cbg[i]);
+  }
+}
+
+
+void ttc::LTC::ReadAllCyclicGeneratorsFromLTC()
+{
+  // Trigger generators.
+  for (size_t i = 0; i < NCyclicTrigger(); ++i)
+    ReadCyclicGeneratorFromLTC(true, i);
+
+  // BGO generators.
+  for (size_t i = 0; i < NCyclicBGO(); ++i)
+    ReadCyclicGeneratorFromLTC(false, i);
+}
+
+
+void ttc::LTC::WriteCyclicGeneratorToLTC(const bool trigger, const size_t i)
+{
+  CyclicTriggerOrBGO* cycl = GetCyclic(trigger, i);
+  if (!cycl)
+  {
+    LOG4CPLUS_ERROR(
+        logger_,
+        "LTC::WriteCyclicGeneratorToLTC(trigger=" << trigger << ", i=" << i << "): " << "GetCyclic(trigger, i) returns 0");
+    return;
+  }
+
+  // Determine address offset.
+  const size_t idx = i + (trigger ? 0 : _n_ctg);
+  string comment = string("(Cyclic ") + (trigger ? "Trig" : "BGO") + ")";
+
+  Write(LTCAdd::CTBG_IPRESC, idx, cycl->GetInitPrescaleWd(), comment);
+  Write(LTCAdd::CTBG_PRESC, idx, cycl->GetPrescaleWd(), comment);
+  Write(LTCAdd::CTBG_POSTSC, idx, cycl->GetPostscaleWd(), comment);
+  Write(LTCAdd::CTBG_PAUSE, idx, cycl->GetPauseWd(), comment);
+  Write(LTCAdd::CTBG_TYPE, idx, cycl->GetTypeWd(), comment);
+  if (!cycl->IsEnabled() && cycl->IsPermanent())
+  {
+    // Temporarily switch off the permanent bit for a few orbits.
+    cycl->SetPermanent(false);
+    Write(LTCAdd::CTBG_INH, idx, cycl->GetInhibitWd(), comment);
+    usleep(1000);
+    cycl->SetPermanent(true);
+  }
+  Write(LTCAdd::CTBG_INH, idx, cycl->GetInhibitWd(), comment);
+}
+
+
+void ttc::LTC::SetTriggerRule(size_t ntrig, uint32_t minDeltaBX)
+{
+  if (ntrig < FirstTriggerRule() || (ntrig > (TriggerRuleSize() + FirstTriggerRule() - 1)))
+  {
+    LOG4CPLUS_ERROR(
+        logger_,
+        "LTC::SetTriggerRule(ntrig=" << ntrig << ", minDeltaBX=" << minDeltaBX << "): Invalid value for arg. ntrig! [" << FirstTriggerRule() << "," << TriggerRuleSize() << "]");
+    return;
+  }
+  uint32_t rule = (minDeltaBX > 0 ? minDeltaBX - 1 : 0);
+  if (ntrig == 1 && rule < 4)
+    rule = 4;
+  if (ntrig == 9)
+  {
+    uint32_t max = 0;
+    for (size_t i = FirstTriggerRule(); i < FirstTriggerRule() + TriggerRuleSize() - 1; ++i)
+    {
+      uint32_t r = GetTriggerRule(i);
+      if (r > max)
+        max = r;
+    }
+    max--;
+    if (rule < max)
+      rule = max;
+  }
+  Write(LTCAdd::TRR_nT, ntrig - FirstTriggerRule(), rule, "(SetTriggerRule())");
+}
+
+
+uint32_t ttc::LTC::GetTriggerRule(size_t ntrig) const
+{
+  if (ntrig < FirstTriggerRule() || (ntrig > (TriggerRuleSize() + FirstTriggerRule() - 1)))
+  {
+    LOG4CPLUS_ERROR(
+        logger_,
+        "LTC::GetTriggerRule(ntrig=" << ntrig << "): Invalid value for arg. ntrig! [" << FirstTriggerRule() << "," << TriggerRuleSize() << "]");
+    return 0;
+  }
+  int32_t rule = Read(LTCAdd::TRR_nT, ntrig - FirstTriggerRule(), "(GetTriggerRule())");
+  return (rule > 0 ? rule + 1 : 0);
+}
+
+
+size_t ttc::LTC::FirstTriggerRule() const
+{
+  return LTC_NTRR_OFFSET;
+}
+
+
+size_t ttc::LTC::TriggerRuleSize() const
+{
+  return 9;
+}
+
+
+size_t ttc::LTC::Nextern() const
+{
+  return 6;
+}
+
+
+void ttc::LTC::ResetCyclicGenerators(const bool trigger, const bool bgo)
+{
+  if (trigger)
+  {
+    for (size_t i = 0; i < NCyclicTrigger(); ++i)
+    {
+      GetCyclic(true, i)->Reset();
+      WriteCyclicGeneratorToLTC(true, i);
+    }
+  }
+  if (bgo)
+  {
+    for (size_t i = 0; i < NCyclicBGO(); ++i)
+    {
+      GetCyclic(false, i)->Reset();
+      WriteCyclicGeneratorToLTC(false, i);
+    }
+  }
+}
+
+
+void ttc::LTC::CheckBXConflicts()
+{
+  int nerr = 0;
+  const int mindiff = 89;
+
+  vector<int> BXs;
+  BXs.push_back(int(GetVMEBGOBX()));
+
+  for (size_t i = 0; i < NCyclicBGO(); ++i)
+  {
+    if (GetCyclic(false, i)->IsEnabled())
+    {
+      BXs.push_back(int(GetCyclic(false, i)->GetStartBX()));
+    }
+  }
+
+  stringstream g;
+  bool first = true;
+
+  for (size_t i = 0; i < BXs.size() - 1; ++i)
+  {
+    for (size_t j = i + 1; j < BXs.size(); ++j)
+    {
+      if (abs(BXs[i] - BXs[j]) < mindiff)
+      {
+        ++nerr;
+        if (first)
+          g << "WARNING: Potential conflict of BXs from different sources (min diff: " << mindiff << " BX)!" << endl;
+
+        first = false;
+
+        bool foundj = false;
+        bool foundi = false;
+
+        if (!foundi && int(GetVMEBGOBX()) == BXs[i])
+        {
+          g << " VMEBGO timing (BX=" << BXs[i] << ") too close to";
+          foundi = true;
+        }
+        else if (int(GetVMEBGOBX()) == BXs[j])
+        {
+          g << " VMEBGO timing (BX=" << BXs[j] << ");";
+          foundj = true;
+        }
+
+        for (size_t k = 0; k < NCyclicBGO(); ++k)
+        {
+          if (!GetCyclic(false, k)->IsEnabled())
+            continue;
+
+          int mybx = int(GetCyclic(false, k)->GetStartBX());
+
+          if (!foundj && mybx == BXs[j])
+          {
+            g << " CyclicBGO #" << k << " timing (BX=" << BXs[j] << ");";
+            foundj = true;
+          }
+          else if (!foundi && mybx == BXs[i])
+          {
+            g << " CyclicBGO #" << k << " timing (BX=" << BXs[i] << ") too close to";
+            foundi = true;
+          }
+        }
+
+        g << endl;
+      }
+    }
+  }
+
+  if (nerr != 0)
+  {
+    XCEPT_RAISE(ttc::exception::BXConflictsDetected, g.str());
+  }
+}
+
+
+unsigned int ttc::LTC::GetFIFOLevel() const
+{
+  uint32_t wd = Read(LTCAdd::TTS_FIFLG, "(GetFIFOLevel)");
+  return MaskOut(wd, 9, 0) / 8;
+}
+
+
+bool ttc::LTC::GetFIFOEvents(LTCEventFIFO& ret)
+{
+  vector<uint32_t> fifoword;
+  bool newalign = false;
+  const size_t NN = MaskOut(Read(LTCAdd::TTS_FIFLG), 9, 0);
+  if (NN == 0)
+    return false;
+  fifoword.reserve(NN + 2);
+  for (size_t n = 0; n < NN; ++n)
+  {
+    fifoword.push_back(Read(LTCAdd::TTS_FIFO, "(GetFIFOEvents)"));
+    if (!newalign && ((*(fifoword.end() - 1) >> 28) & 0xf) == 0xc)
+    {
+      newalign = true;
+      size_t last = fifoword.size() - 1;
+      if (last > 2 && (fifoword[last - 1] & 0xf0000000) == 0 && (fifoword[last - 2] & 0xc000ff00) == 0)
+      {
+        fifoword.erase(fifoword.begin(), fifoword.begin() + last - 2);
+      }
+      else if (last < 2)
+      {
+        for (size_t jj = 0; jj < (2 - last); ++jj)
+          fifoword.insert(fifoword.begin(), 0);
+      }
+    }
+  }
+  ResetEventFIFO();
+  ret = LTCEventFIFO(fifoword, *this);
+  return true;
+}
+
+
+uint32_t ttc::LTC::ReadTTSStatus() const
+{
+  return Read(LTCAdd::TTS_STAT, "(LTC::ReadTTSStatus())");
+}
+
+
+size_t ttc::LTC::NTTS() const
+{
+  return 7;
+}
+
+
+bool ttc::LTC::IsTTSEnabled(const size_t idx) const
+{
+  if (idx >= NTTS())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::IsTTSEnabled(idx=" << idx << "): arg idx out of range");
+    return false;
+  }
+  size_t pat = GetTTSStatus_Pattern(idx);
+  return (pat == 0x0);
+}
+
+
+void ttc::LTC::EnableTTS(const size_t idx, const bool Enable)
+{
+  if (idx >= NTTS())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::EnableTTS(idx=" << idx << "): arg idx out of range");
+    return;
+  }
+  uint32_t TTSmask = Read(LTCAdd::TTS_MASK);
+  for (size_t i = 0; i < 4; ++i)
+  {
+    SetBit(TTSmask, idx + i * 8, !Enable);
+  }
+  Write(LTCAdd::TTS_MASK, TTSmask, "(EnableTTS)");
+}
+
+
+void ttc::LTC::EnableBSTGPSviaVME(bool Enable)
+{
+  SetBit(control_, 19, Enable);
+  SendControlWord();
+  ThreadParameters.GPS.enabled = Enable;
+  ThreadParameters.GPS.newSetup = true;
+}
+
+
+bool ttc::LTC::IsBSTGPSviaVME() const
+{
+  return ThreadParameters.GPS.enabled;
+}
+
+
+void ttc::LTC::IgnoreSlinkBackpressure(bool Ignore)
+{
+  SetBit(control_, CNTRLBIT_SLINKBACKPRESSURE, !Ignore);
+  SendControlWord();
+}
+
+
+bool ttc::LTC::IsSlinkBackpressureIgnored() const
+{
+  return (((control_ >> CNTRLBIT_SLINKBACKPRESSURE) & 1) == 0);
+}
+
+
+double ttc::LTC::GetBSTGPSInterval() const
+{
+  return ThreadParameters.GPS.waitNsec;
+}
+
+
+void ttc::LTC::SetBSTGPS(const uint32_t GPSlow, const uint32_t GPShigh)
+{
+  if (!IsBSTGPSviaVME())
+  {
+    LOG4CPLUS_WARN(logger_, "LTC::SetBSTGPS(): unable, since BSTGPSviaVME()=" << IsBSTGPSviaVME());
+    return;
+  }
+  Write(LTCAdd::GPS_LO, GPSlow, "(GPS-BST)");
+  Write(LTCAdd::GPS_HI, GPShigh, "(GPS-BST)");
+}
+
+
+uint32_t ttc::LTC::IncrementRunNumber(bool dontIncrement)
+{
+  uint32_t runno = GetRunNumber();
+  if (overwriteRunNo)
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::IncrementRunNumber(): "
+    "Unable to increment run number since it has "
+    "been set externally");
+    return runno;
+  }
+  const string file = getEnvWithDefault("HOME", "/tmp") + "/" + "LTC_run_number";
+  uint32_t Run;
+  ifstream fp(file.c_str());
+  if (fp)
+  {
+    if (fp >> Run)
+    {
+      runno = Run;
+      if (!dontIncrement)
+        runno += 1;
+    }
+    else
+    {
+      if (!dontIncrement)
+        runno += 1;
+      LOG4CPLUS_ERROR(
+          logger_,
+          "Unable to retreive run number from file '" << file << "'" << " --> create new file and start counting from " << runno);
+    }
+    fp.close();
+  }
+  else
+  {
+    if (!dontIncrement)
+      runno += 1;
+  }
+  ofstream ofp(file.c_str());
+  if (!ofp)
+  {
+    LOG4CPLUS_ERROR(logger_, "Unable to write new run number to file '" << file << "'");
+  }
+  else
+  {
+    ofp << dec << runno;
+    ofp.close();
+  }LOG4CPLUS_INFO(logger_, "LTC::IncrementRunNumber(): "
+  "Switched to new run number: " << dec << runno);
+  SetRunNumber(runno);
+  overwriteRunNo = false;
+  monitor.SetRunNumber(runno);
+  return runno;
+}
+
+
+uint32_t ttc::LTC::GetRunNumber() const
+{
+  return Read(LTCAdd::SLINK_CONF2, "(Run Number)");
+}
+
+
+void ttc::LTC::SetRunNumber(const uint32_t run)
+{
+  Write(LTCAdd::SLINK_CONF2, run, "(Run Number)");
+  overwriteRunNo = true;
+  monitor.SetRunNumber(run);
+}
+
+
+ttc::Monitoring*
+ttc::LTC::GetMonitoring()
+{
+  return &monitor;
+}
+
+
+void ttc::LTC::SetBXMask(const bool enable, const size_t begin, const size_t end)
+{
+  size_t b0 = begin, b1 = end;
+  if ((b0 > NClocksPerOrbit()) || ((b1 > NClocksPerOrbit() + 1 && b1 != 9999)) || (b0 < 1))
+  {
+    LOG4CPLUS_ERROR(
+        logger_,
+        "LTC::SetBXMask(enable="<<(enable?"true":"false") << ", begin=" << dec << begin << ", end=" << end << "): Invalid argument(s)/range: [" << begin << ";" << end<<")");
+    return;
+  }
+  if (b1 == 0)
+    b1 = NClocksPerOrbit() + 1;
+  if (b1 == 9999)
+    b1 = b0 + 1;
+  uint32_t value = (enable ? 1 : 0);
+  if (b1 >= b0)
+  {
+    for (size_t i = b0; i < b1; ++i)
+    {
+      Write(LTCAdd::StartBDPRAM, i - 1, value, "(BX Mask)");
+      bxmask[i - 1] = enable;
+    }
+  }
+  else
+  {
+    for (size_t i = b0; i < NClocksPerOrbit() + 1; ++i)
+    {
+      Write(LTCAdd::StartBDPRAM, i - 1, value, "(BX Mask)");
+      bxmask[i - 1] = enable;
+    }
+    for (size_t i = 1; i < b1; ++i)
+    {
+      Write(LTCAdd::StartBDPRAM, i - 1, value, "(BX Mask)");
+      bxmask[i - 1] = enable;
+    }
+  }
+}
+
+
+void ttc::LTC::BXMaskReset()
+{
+  SetBXMask(true, 1, 0);
+}
+
+
+void ttc::LTC::GetBXGaps(vector<size_t>& begin, vector<size_t>& end) const
+{
+  begin.clear();
+  end.clear();
+  bool insideGap = false;
+  for (size_t i = 0; i < bxmask.size(); ++i)
+  {
+    if (!insideGap)
+    {
+      if (!bxmask[i])
+      {
+        begin.push_back(i + 1);
+        insideGap = true;
+      }
+    }
+    else
+    {
+      if (bxmask[i])
+      {
+        end.push_back(i + 1);
+        insideGap = false;
+      }
+    }
+  }
+  if (insideGap)
+    end.push_back(0);
+  if (begin.size() != end.size())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::GetBXGaps() unknown problem occurred");
+    begin.clear();
+    end.clear();
+  }
+}
+
+
+double ttc::LTC::GetActiveBXFraction() const
+{
+  size_t nactive = 0;
+  size_t nall = 0;
+  for (size_t i = 0; i < bxmask.size(); ++i)
+  {
+    ++nall;
+    if (bxmask[i])
+    {
+      ++nactive;
+    }
+  }
+  return (double(nactive) / double(nall));
+}
+
+
+uint32_t ttc::LTC::ReadSLinkStatus() const
+{
+  return Read(LTCAdd::SLINK_STAT, "(s-link status)");
+}
+
+
+uint32_t ttc::LTC::ReadSLinkStatus(string& status, const bool usehtmlstyle) const
+{
+  const uint32_t stat = ReadSLinkStatus();
+  stringstream o;
+  if ((stat & 0x3) == 3)
+  { // ready or o.k.
+    if (usehtmlstyle)
+      o << "<span style=\"color: rgb(51, 204, 0);\">";
+    o << "Ready (0x" << hex << stat << dec << ")";
+    if (usehtmlstyle)
+      o << "</span>";
+  }
+  else if ((stat & 0x3) == 1)
+  { // s-link full
+    if (usehtmlstyle)
+      o << "<span style=\"color: rgb(255, 0, 0);\">";
+    o << "FULL (0x" << hex << stat << dec << ")";
+    if (usehtmlstyle)
+      o << "</span>";
+  }
+  else if ((stat & 0x1) == 0)
+  { // link down
+    if (usehtmlstyle)
+      o << "<span style=\"color: rgb(255, 0, 0);\">";
+    o << "Link down (0x" << hex << stat << dec << ")";
+    if (usehtmlstyle)
+      o << "</span>";
+  }
+  else
+  {
+    if (usehtmlstyle)
+      o << "<span style=\"color: rgb(255, 0, 0);\">";
+    o << "UNKNOWN (0x" << hex << stat << dec << ")";
+    if (usehtmlstyle)
+      o << "</span>";
+  }
+  status = o.str();
+  return stat;
+}
+
+
+uint32_t ttc::LTC::GetWarningInterval() const
+{
+  return Read(LTCAdd::TTS_DELAY, "(TTS Warning Pause)");
+}
+
+
+void ttc::LTC::SetWarningInterval(const uint32_t pause)
+{
+  Write(LTCAdd::TTS_DELAY, pause, "(TTS Warning Pause)");
+}
+
+
+void ttc::LTC::SetHWInputDelays(const vector<float> &delays)
+{
+  uint32_t delword = 0;
+  if (ReadFirmwareVersion() < 0x14)
+  {
+    for (size_t i = 0; (i < delays.size() && i < 6); ++i)
+    {
+      delword |= ((unsigned(delays[i] * 2.0) & 0x1f) << (5 * i));
+    }
+    Write(LTCAdd::HWI_SKEW, delword, "(HW delays)");
+  }
+  else
+  {
+    for (size_t i = 0; (i < delays.size() && i < 5); ++i)
+    {
+      delword |= ((unsigned(delays[i] * 2.0) & 0x3f) << (6 * i));
+    }
+    Write(LTCAdd::HWI_SKEW, delword, "(HW delays)");
+    delword = (unsigned(delays[5] * 2.0) & 0x3f);
+    Write(LTCAdd::HWI_SKEW1, delword, "(HW delays)");
+  }
+}
+
+
+vector<float>
+ttc::LTC::GetHWInputDelays() const
+{
+  vector<float> vec;
+  uint32_t delword = Read(LTCAdd::HWI_SKEW, "(HW delays)");
+  if (ReadFirmwareVersion() < 0x14)
+  {
+    for (size_t i = 0; i < 6; ++i)
+    {
+      vec.push_back(float(((delword >> (i * 5)) & 0x1f) / 2.));
+    }
+  }
+  else
+  {
+    for (size_t i = 0; i < 5; ++i)
+    {
+      vec.push_back(float((delword >> (i * 6)) & 0x3f) / 2.);
+    }
+    delword = Read(LTCAdd::HWI_SKEW1, "(HW delays)");
+    vec.push_back(float(delword & 0x3f) / 2.);
+  }
+  return vec;
+}
+
+
+string ttc::LTC::TTSStatusSummary(size_t& mask) const
+{
+  string state = "Ignored";
+  mask = 0;
+  TTSInfo mytts(ReadTTSStatus());
+  int is = -1; //5=ERR 4=outofsync 3=full/busy 2=warning 1=ready 0=disconnected 6=unkwn
+
+  for (int j = 0; j < int(mytts.NPartitions()); ++j)
+  {
+    if (!IsTTSEnabled(j))
+      continue;
+    mask |= (1 << j);
+    if (mytts.IsError(j))
+      is = 5;
+    else if (mytts.IsOutOfSync(j))
+      is = max(4, is);
+    else if (mytts.IsBusy(j))
+      is = max(3, is);
+    else if (mytts.IsWarning(j))
+      is = max(2, is);
+    else if (mytts.IsDisconnected(j))
+      is = max(1, is);
+    else if (mytts.IsReady(j))
+      is = max(0, is);
+    else
+      is = max(6, is);
+  } // loop over all partitions
+
+  if (mask > 0)
+  {
+    switch (is)
+    {
+      case 5:
+        state = "Error";
+        break;
+      case 4:
+        state = "OutOfSync";
+        break;
+      case 3:
+        state = "Busy";
+        break;
+      case 2:
+        state = "Warning";
+        break;
+      case 1:
+        state = "Disconnected";
+        break;
+      case 0:
+        state = "Ready";
+        break;
+      default:
+        state = "Unknown";
+        break;
+    }
+  }
+  return state;
+}
+
+
+string ttc::LTC::GetTriggerName(const size_t i) const
+{
+  if (i >= trigname.size())
+  {
+    LOG4CPLUS_ERROR(logger_,
+        "LTC::GetTriggerName(index=" << i << "): index our of range" << " range is [0, " << trigname.size()-1 << "]");
+    return string("");
+  }
+  return trigname[i];
+}
+
+
+void ttc::LTC::SetTriggerName(const size_t i, const string& name)
+{
+  if (i >= trigname.size())
+  {
+    LOG4CPLUS_ERROR(
+        logger_,
+        "LTC::SetTriggerName(index=" << i << ",'" << name << "'): index our of range" << " range is [0, " << trigname.size()-1 << "]");
+    return;
+  }
+  string thisname = name;
+  if (name.size() >= 49)
+    thisname.erase(thisname.begin() + 49, thisname.end());
+  for (size_t j = 0; j < thisname.size(); ++j)
+  {
+    if (thisname[j] == ' ')
+      thisname[j] = '_';
+    else if (thisname[j] == '>' || thisname[j] == '<' || thisname[j] == '#')
+      thisname[j] = '*';
+  }
+  trigname[i] = thisname;
+}
+
+
+bool ttc::LTC::IsClockLocked() const
+{
+  // QPLLLOCKEDBIT
+  return (((Read(LTCAdd::QPLLCTRL) >> QPLLLOCKEDBIT) & 1) == 1);
+}
+
+
+uint32_t ttc::LTC::GetBTimeCorrection() const
+{
+  return BTimeCorrection_;
+}
+
+
+const ttc::LTCStatusInfo*
+ttc::LTC::GetLTCStatusInfo() const
+{
+  return (const LTCStatusInfo*) &CurrentRates;
+}
+
+
+void ttc::LTC::UpdateLTCStatusInfo()
+{
+  CurrentRates.Set(ReadOrbitCounter(), ReadTriggerCounter(), ReadBlockedTriggersCounter(), ReadStrobeCounter(),
+      CancelledTriggers());
+  CurrentRates.SetTriggerComposition(GetMonitoring()->GetTriggerComposition());
+}
+
+
+bool ttc::LTC::DumpEventFIFOToFile() const
+{
+  return dumpevtstofile;
+}
+
+
+bool ttc::LTC::DefaultFIFODumpEnabled() const
+{
+  return dumpevtstofile_setonenable;
+}
+
+
+string ttc::LTC::FIFODumpPrefix() const
+{
+  return dumpevtstofilepath_prefix;
+}
+
+
+string ttc::LTC::EventFIFOToFilePath() const
+{
+  return dumpevtstofilepath;
+}
+
+
+void ttc::LTC::SetFilePathForFIFODump(const bool enable, const string& newpath)
+{
+  string path = newpath;
+  size_t pos = path.find_first_of(" \t");
+  if (pos < path.size())
+    path.erase(pos, path.size());
+  dumpevtstofilepath = path;
+  if (!dumpevtstofile && enable)
+  {
+    FILE *fp = fopen(dumpevtstofilepath.c_str(), "w");
+    if (fp)
+      fclose(fp);
+  }
+  dumpevtstofile = enable;
+}
+
+
+void ttc::LTC::SetExternalCrystalTo160MHz(bool externalQuarzIs160MHz)
+{
+  uint32_t old_content = Read(LTCAdd::QPLLCTRL);
+  uint32_t new_content = old_content;
+
+  const uint32_t bitnum = 7;
+
+  SetBit(new_content, bitnum, externalQuarzIs160MHz);
+  if (old_content != new_content)
+    Write(LTCAdd::QPLLCTRL, new_content, "(SetExternalCrystal())");
+}
+
+
+void ttc::LTC::SetSlinkSrcId(uint32_t id)
+{
+  uint32_t temp = Read(LTCAdd::SLINK_CONF);
+  temp &= ~(0xfff << 20);
+  temp |= id << 20;
+  Write(LTCAdd::SLINK_CONF, temp);
+}
+
+
+void ttc::LTC::SetInternalTriggerFrequency(const double frequency, bool random)
+{
+  ram_triggers->SetInternalTriggerFrequencyLTC(frequency, random);
+}
+
+
+void ttc::LTC::CreateParallelThread()
+{
+  // Initialize the Parallel Thread
+  ThreadParameters.myLTC = this;
+  // Init Monitoring pars:
+  SetMonitoringInterval(10.0);
+  EnableMonitoring(false);
+  // Init Periodic pars:
+  ThreadParameters.Periodic.newSetup = true;
+  ThreadParameters.Periodic.waitNsec = -99.0;
+  ThreadParameters.Periodic.enabled = false;
+  // Init GPS/BST pars:
+  ThreadParameters.GPS.newSetup = true;
+  SetBSTGPSInterval(3.0);
+  // Init LTC Status Parameters (like current frequency and such):
+  ThreadParameters.Parameters.newSetup = false;
+  ThreadParameters.Parameters.waitNsec = 4;
+  ThreadParameters.Parameters.enabled = true;
+
+  stop_thread_flag = false;
+
+  // Create the parallel thread.
+  LOG4CPLUS_INFO(logger_, "LTC::CreateParallelThread(): creating thread");
+  pthread_create(&thethread, NULL, ParallelThread, (void *) &ThreadParameters);
+  LOG4CPLUS_INFO(logger_, "LTC::CreateParallelThread(): thread created");
+}
+
+
+size_t ttc::LTC::GetTTSStatus_Pattern(size_t idx) const
+{
+  if (idx >= NTTS())
+  {
+    LOG4CPLUS_ERROR(logger_, "LTC::GetTTSStatus_Pattern(): " << "idx=" << idx << " out of range");
+    return 0;
+  }
+  uint32_t TTSmask = Read(LTCAdd::TTS_MASK);
+  uint32_t stat = 0;
+  for (size_t i = 0; i < 4; ++i)
+  {
+    stat |= (((TTSmask >> (idx + i * 8)) & 1) << i);
+  }
+  return stat;
+}
+
+
+uint32_t ttc::LTC::GetFirmwareBuiltNumber() const
+{
+  return (ReadFirmwareVersion() >> 16) & 0xffff;
+}
+
+
+void ttc::LTC::PrintBoardStatus() const
+{
+  uint32_t boardStatus = BoardStatus();
+  LOG4CPLUS_INFO(
+      logger_,
+      "Status: 0x" << hex << boardStatus << dec << " i.e.: " << "external orbit " << (((boardStatus>>31)&1)?"in sync":"out of sync") << " with clock counter");
+}
+
+
+void ttc::LTC::ResetInternalTrigsAndAllCyclicGenerators()
+{
+  Write(LTCAdd::CNTRST, CNTRST_RESET_ALL_INTERNAL_TRIGSANDBGOS, "(Reset internals)");
+}
+
+
+void ttc::LTC::SetBChannelNames()
+{
+  vector<string> channel_names = bgo_map->getChannelNames();
+  assert(channel_names.size() == NChannels());
+  assert(channel_names.size() == bgo.size());
+
+  for (size_t i = 0; i < NChannels(); ++i)
+  {
+    bgo[i].SetName(channel_names[i]);
+    bgo[i].AddAlternativeNames(bgo_map->getChannelNameAlternatives(i));
+  }
+}
+
+
+void ttc::LTC::ReadChannelStatus(
+    const size_t channel,
+    uint32_t &signalcounter,
+    bool &anycancelled,
+    uint32_t &cancelcounter,
+    bool &ramempty) const
+{
+  if (channel >= NChannels())
+  {
+    stringstream my;
+    my << "ERROR: LTC::ReadChannelStatus(channel=" << dec << channel << "): Invalid Channel (should be 0...15)!";
+    throw std::invalid_argument(my.str());
+  }
+  uint32_t stat = Read(LTCAdd::CHRMC, channel, "(CHRMC)");
+  signalcounter = (stat & 0xffff);
+  cancelcounter = ((stat >> 16) & 0x3ff);
+  anycancelled = ((stat >> 26) & 0x1) == 1;
+  ramempty = ((stat > 27) & 0x1) == 1;
+}
+
+
+ttc::CyclicTriggerOrBGO*
+ttc::LTC::ReadCyclicGeneratorFromLTC(const bool trigger, const size_t i)
+{
+  CyclicTriggerOrBGO* cycl = GetCyclic(trigger, i);
+  if (!cycl)
+  {
+    LOG4CPLUS_ERROR(
+        logger_,
+        "LTC::ReadCyclicGeneratorFromLTC(trigger=" << trigger << ", i=" << i << "): " << "GetCyclic(trigger, i) returns 0");
+    return cycl;
+  }
+  // Determine address offset.
+  const size_t idx = i + (trigger ? 0 : _n_ctg);
+  string comment = string("(Cyclic ") + (trigger ? "Trig" : "BGO") + ")";
+  uint32_t ihb = Read(LTCAdd::CTBG_INH, idx, comment);
+  uint32_t ipres = Read(LTCAdd::CTBG_IPRESC, idx, comment);
+  uint32_t pres = Read(LTCAdd::CTBG_PRESC, idx, comment);
+  uint32_t post = Read(LTCAdd::CTBG_POSTSC, idx, comment);
+  uint32_t pause = Read(LTCAdd::CTBG_PAUSE, idx, comment);
+  uint32_t type = Read(LTCAdd::CTBG_TYPE, idx, comment);
+  if (trigger)
+  {
+    if (type != 0x1)
+    {
+      LOG4CPLUS_WARN(
+          logger_,
+          "LTC::ReadCyclicGeneratorFromLTC(trigger=" << trigger << ", i=" << i << "): " << "read type=0x" << hex << type << dec << "! --> setting type to 1" << endl << "(N.B.: type=0 is o.k. for DUMMY(64X) VME bus " << "adapter.)");
+      type = 1;
+    }
+  }
+  else
+  {
+    if (type != 0x10)
+    {
+      LOG4CPLUS_WARN(
+          logger_,
+          "LTC::ReadCyclicGeneratorFromLTC(trigger=" << trigger << ", i=" << i << "): " << "read type=0x" << hex << type << dec << "! --> setting type to 0x10" << endl << "(N.B.: type=0 is o.k. for DUMMY(64X) VME bus " << "adapter.)");
+      type = 0x10;
+    }
+  }
+  cycl->SetPrescaleWd(pres);
+  cycl->SetPostscaleWd(post);
+  cycl->SetPauseWd(pause);
+  cycl->SetTypeWd(type);
+  cycl->SetInhibitWd(ihb);
+  cycl->SetInitPrescaleWd(ipres);
+  return cycl;
+}
+
+
+string ttc::LTC::TTSStatusSummary() const
+{
+  size_t mask;
+  return TTSStatusSummary(mask);
+}
+
+
+void ttc::LTC::SetBSTGPSInterval(const double dt)
+{
+  ThreadParameters.GPS.waitNsec = dt;
+  ThreadParameters.GPS.newSetup = true;
+}
+
+
+uint64_t ttc::LTC::GetBSTGPSTime() const
+{
+  uint32_t GPSlow, GPShigh;
+  ReadBSTGPS(GPSlow, GPShigh);
+
+  uint64_t retval = GPSlow;
+  retval |= ((uint64_t) GPShigh) << 32;
+
+  return retval;
+}
+
+
+unsigned ttc::LTC::GetBSTGPSTimeSeconds() const
+{
+  uint64_t buf = GetBSTGPSTime();
+
+  return (unsigned) ((buf + 500000) / 1000000);
+}
+
+
+void ttc::LTC::ReadBSTGPS(uint32_t& GPSlow, uint32_t& GPShigh) const
+{
+  GPSlow = Read(LTCAdd::GPS_LO);
+  GPShigh = Read(LTCAdd::GPS_HI);
+}
+
+
+bool ttc::LTC::HasSlinkBackPressure() const
+{
+  const uint32_t stat = ReadSLinkStatus();
+  return (stat & 0x3) == 1;
+}
+
+
+void ttc::LTC::EnableGPSFromVME(const bool enable)
+{
+  ThreadParameters.GPS.enabled = enable;
+  ThreadParameters.GPS.newSetup = true;
+}
+
+
+void ttc::LTC::EnableCurrentRatesUpdate(bool enable)
+{
+  ThreadParameters.Parameters.enabled = enable;
+  ThreadParameters.Parameters.newSetup = true;
+}
+
+
+void ttc::LTC::EnablePeriodicSequence(bool enable)
+{
+  ThreadParameters.Periodic.enabled = enable;
+  ThreadParameters.Periodic.newSetup = true;
+}
+
+
+const ttc::Monitoring*
+ttc::LTC::GetMonitoring() const
+{
+  return (const Monitoring *) &monitor;
+}
+
+
+string ttc::LTC::GetRunLogPath() const
+{
+  return runlog;
+}
+
+
+void ttc::LTC::WriteRunLog() const
+{
+  string path = GetRunLogPath();
+  if (path.size() == 0)
+  {
+    path = "/tmp/runlist.txt";
+  }
+  ofstream fp(path.c_str(), fstream::app);
+  if (fp)
+  {
+    int32_t dur = int32_t(GetMonitoring()->RunDuration());
+    stringstream duration;
+    duration << dur / 3600 << "h";
+    dur -= (dur / 3600) * 3600;
+    duration << (dur / 60 < 10 ? "0" : "") << dur / 60 << "m";
+    dur = dur % 60;
+    duration << (dur < 10 ? "0" : "") << dur;
+
+    if (dur > 360.0)
+      dur /= 60;
+    fp << "R=" << dec << GetRunNumber() << " L=" << ReadTriggerCounter() << " B=" << ReadBlockedTriggersCounter()
+        << " D=" << duration.str();
+    for (size_t i = 0; i < Nextern(); ++i)
+    {
+      if (IsExternalTriggerEnabled(i))
+      {
+        fp << " T" << i << "=" << GetTriggerName(i) << "(" << i << ")";
+      }
+    }
+    if (IsRAMTrigEnabled())
+    {
+      if (ram_triggers->GetInternalTriggerRandom())
+      {
+        fp << " TRAM=RND-" << ram_triggers->GetInternalTriggerFrequency() << "Hz";
+      }
+      else
+      {
+        fp << " TRAM=UNIFORM-" << ram_triggers->GetInternalTriggerFrequency() << "Hz" << endl;
+      }
+    }
+    //TIME:
+    time_t tt;
+    time(&tt);
+    char timestring1[100];
+    sprintf(timestring1, "%s", ctime(&tt));
+    char timestring2[100];
+    size_t i = 0;
+    for (size_t k = 0; k < strlen(timestring1) && k < 99; ++k)
+    {
+      if (timestring1[k] == '\0' || timestring1[k] == '\n')
+        continue;
+      if (timestring1[k] == ' ')
+      {
+        timestring2[i++] = '_';
+      }
+      else
+      {
+        timestring2[i++] = timestring1[k];
+      }
+    }
+    timestring2[i++] = '\0';
+    fp << " TIME=" << timestring2 << endl;
+  }
+  fp.close();
+}
+
+
+// functions in namespace ttc
+
+void*
+ttc::ParallelThread(void* arg)
+{
+  LTCThreadPars* pars = (LTCThreadPars*) arg;
+
+  LTC* myLTC = pars->myLTC;
+  // In miliseconds!
+  const double tstep = 1.0;
+  time(&(pars->Monitoring.t0));
+  pars->Monitoring.t1 = pars->Monitoring.t0;
+  time(&(pars->GPS.t0));
+  pars->GPS.t1 = pars->GPS.t0;
+  time(&(pars->Periodic.t0));
+  pars->Periodic.t1 = pars->Periodic.t0;
+  time(&(pars->Parameters.t0));
+  pars->Parameters.t1 = pars->Parameters.t0;
+
+  try
+  {
+    do
+    {
+      usleep(int(tstep * 1000.0));
+
+      //----------------------------------------
+      // the CurrentRates part:
+      //----------------------------------------
+      {
+        StatusParameters *p = &(pars->Parameters);
+        time(&(p->t1));
+        if (p->newSetup)
+        {
+          // new setup:
+          p->newSetup = false;
+          time(&(p->t0));
+          p->t1 = p->t0;
+        }
+        else
+        {
+          if (p->waitNsec > 0.0 && difftime(p->t1, p->t0) > p->waitNsec)
+          {
+            time(&(p->t0));
+            p->t1 = p->t0;
+            if (p->enabled && myLTC)
+              myLTC->UpdateLTCStatusInfo();
+          }
+        }
+      }
+
+      //----------------------------------------
+      // The Monitoring Part:
+      //----------------------------------------
+      {
+        MonitoringThreadPars* p = &(pars->Monitoring);
+        time(&(p->t1));
+        if (p->newSetup)
+        {
+          // New setup.
+          p->newSetup = false;
+          time(&(p->t0));
+          p->t1 = p->t0;
+        }
+        else
+        {
+          if ((p->waitNsec > 0.0) && (difftime(p->t1, p->t0) > p->waitNsec))
+          {
+            time(&(p->t0));
+            p->t1 = p->t0;
+            if (p->enabled && myLTC)
+            {
+              myLTC->UpdateMonitoring();
+            }
+            else
+            {
+              ; // error?
+            }
+          }
+        }
+      }
+
+      //----------------------------------------
+      // The Periodic Part:
+      //----------------------------------------
+      {
+        PeriodicThreadPars *p = &pars->Periodic;
+        time(&(p->t1));
+        if (p->newSetup)
+        {
+          // new setup:
+          p->newSetup = false;
+          //twait = pars->waitNsec;
+          time(&(p->t0));
+          p->t1 = p->t0;
+        }
+        else
+        {
+          if (p->waitNsec > 0.0 && difftime(p->t1, p->t0) > p->waitNsec)
+          {
+            time(&(p->t0));
+            p->t1 = p->t0;
+            if (p->enabled && myLTC)
+            {
+              myLTC->ExecuteSequence("periodic");
+            }
+          }
+        }
+      }
+
+      //----------------------------------------
+      // The GPS/BST Part:
+      //----------------------------------------
+      {
+        GPSTimeThreadPars *p = &(pars->GPS);
+        time(&(p->t1));
+        if (p->newSetup)
+        {
+          // new setup:
+          p->newSetup = false;
+          time(&(p->t0));
+          p->t1 = p->t0;
+        }
+        else
+        {
+          if (p->waitNsec > 0.0 && difftime(p->t1, p->t0) > p->waitNsec)
+          {
+            time(&(p->t0));
+            p->t1 = p->t0;
+            if (p->enabled && myLTC)
+            {
+              timeval tv;
+              gettimeofday(&tv, 0);
+              uint64_t t = tv.tv_sec * 1000000ULL + tv.tv_usec;
+              uint32_t lo = (t & 0xffffffff);
+              uint32_t hi = (t >> 32) & 0xffffffff;
+              myLTC->SetBSTGPS(lo, hi);
+            }
+          }
+        }
+      }
+    } while (!myLTC->stop_thread_flag);
+
+    // stop this thread
+
+    // this seems to throw an exception...
+    // pthread_exit(NULL);
+    return ((void*) 0);
+
+  }
+  catch (xcept::Exception& e)
+  {
+    log4cplus::Logger l = log4cplus::Logger::getInstance("ttc-unknown-host.LTC.ParallelThread");
+    LOG4CPLUS_FATAL(l, xcept::stdformat_exception_history(e));
+  }
+  catch (std::exception& e)
+  {
+    log4cplus::Logger l = log4cplus::Logger::getInstance("ttc-unknown-host.LTC.ParallelThread");
+    LOG4CPLUS_FATAL(l, e.what());
+  }
+  catch (...)
+  {
+    log4cplus::Logger l = log4cplus::Logger::getInstance("ttc-unknown-host.LTC.ParallelThread");
+    LOG4CPLUS_FATAL(l, "Unknown excpetion caught in parallel thread");
+  }
+
+  return ((void *) 0);
+}
diff --git a/ttc/ltc/src/common/LTCAddresses.cc b/ttc/ltc/src/common/LTCAddresses.cc
new file mode 100644
index 000000000..c5517fd2e
--- /dev/null
+++ b/ttc/ltc/src/common/LTCAddresses.cc
@@ -0,0 +1,22 @@
+// #define MAKE_ADDRESS(name, add, am, rw)
+// extern const LTCAddressHelper name;
+// const        LTCAddressHelper name(#name, add, am, Address::rw, 4)
+
+#define MAKE_REGISTER(name, add, write) \
+extern const Address name;        \
+const        Address name(Address::LTC,#name, add, 0x39, (write ? Address::RW : Address::RO), 4)
+
+#define MAKE_RAM(name, add, write, num) \
+extern const Address name;        \
+const        Address name(Address::LTC,#name, add, 0x39, (write ? Address::RW : Address::RO), 4, num)
+
+#define MAKE_SUBREG(name, reg, offs, num, step) \
+extern const Address name;                \
+const        Address name(Address::LTC,#name, reg, offs, num, step)
+
+#define MAKE_REGCOPY(name, reg)  \
+extern const Address name; \
+const        Address name(Address::LTC,#name, reg)
+
+
+#include "ttc/ltc/LTCAddresses.hh"
diff --git a/ttc/ltc/src/common/LTCConfiguration.cc b/ttc/ltc/src/common/LTCConfiguration.cc
new file mode 100644
index 000000000..b76218c0d
--- /dev/null
+++ b/ttc/ltc/src/common/LTCConfiguration.cc
@@ -0,0 +1,1311 @@
+#include "ttc/ltc/LTCConfiguration.hh"
+
+#include "ttc/ltc/LTC.hh"
+#include "ttc/utils/ConfigurationItem.hh"
+#include "ttc/utils/LockMutex.hh"
+#include "ttc/utils/RAMTriggers.hh"
+
+
+using namespace std;
+
+
+// classes to represent LTC configuration items
+
+
+namespace ttc
+{
+
+//! The 'mother' of all LTCConfigurationItems
+class LTCConfigurationItem : public ConfigurationItem
+{
+public:
+  LTCConfigurationItem(LTC &_ltc) : ltc(_ltc)
+  {
+    logger_ = log4cplus::Logger::getInstance("LTCConfigurationItem");
+  }
+protected:
+  LTC& ltc;
+};
+
+
+class LTCConfigurationItem_QPLL : public ttc::LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_QPLL(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = NumberOfWords(current_line) - 1;
+    int Npars_ok = 0;
+    bool externalclock = false;
+
+    string parname;
+    if (FindString(current_line, (parname = WORD_QPLLEXTERNAL), string_val))
+    {
+      ++Npars_ok;
+      externalclock = true;
+    }
+    else if (FindString(current_line, (parname = WORD_QPLLINTERNAL), string_val))
+    {
+      ++Npars_ok;
+    }
+
+    ltc.SetQPLLExternal(externalclock);
+
+    if (FindString(current_line, (parname = WORD_QPLLRESET), string_val))
+    {
+      ++Npars_ok;
+      if (string_val == "YES" || string_val == "Yes" || string_val == "yes")
+      {
+        ltc.ResetQPLL(true);
+      }
+      else if (string_val == "NO" || string_val == "No" || string_val == "no")
+      {
+        ltc.ResetQPLL(false);
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Unknown parameter '" << string_val << "' for " << parname << " in line " << line_number + 1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+
+    if (FindString(current_line, (parname = WORD_QPLLAUTORESTART), string_val))
+    {
+      ++Npars_ok;
+      if (string_val == "YES" || string_val == "Yes" || string_val == "yes" || string_val == "on" || string_val == "ON"
+          || string_val == "On")
+      {
+        ltc.AutoRestartQPLL(true);
+      }
+      else if (string_val == "NO" || string_val == "No" || string_val == "no" || string_val == "off"
+          || string_val == "OFF" || string_val == "Off")
+      {
+        ltc.AutoRestartQPLL(false);
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Unknown parameter '" << string_val << "' for " << parname << " in line " << line_number + 1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+
+    if (FindString(current_line, (parname = WORD_QPLLFREQBITS), string_val))
+    {
+      uint32_t ulong_val;
+
+      if (GetUnsignedLong(current_line, parname, ulong_val))
+      {
+        LOG4CPLUS_INFO(
+            logger_,
+            "LTC::Configure(): " << "line" << line_number + 1 << " setting QPLL freq-bits to 0x" << hex << ulong_val);
+
+        ++Npars_ok;
+        ulong_val = (ulong_val & (externalclock ? 0xf : 0x3f));
+        ltc.SetQPLLFrequencyBits(ulong_val, externalclock);
+      }
+    }
+
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number + 1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot << " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_VMEBGOBX : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_VMEBGOBX(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    uint32_t ulong_val;
+
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+      ltc.SetVMEBX(ulong_val);
+    else
+    {
+      ostringstream msg;
+      msg << "Unknown/invalid value '" << string_val << "' for " << varname << " in line " << line_number + 1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_RunLog : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_RunLog(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    if (string_val.size() > 0)
+    {
+      ltc.runlog = string_val;
+    }
+  }
+};
+
+
+class LTCConfigurationItem_FifoDump : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_FifoDump(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    ltc.dumpevtstofile_setonenable = false;
+    if (string_val.size() > 0)
+    {
+      ++Npars_ok;
+      if (string_val == "YES" || string_val == "yes" || string_val == "Yes" || string_val == "ON" || string_val == "on"
+          || string_val == "On")
+      {
+        ltc.dumpevtstofile_setonenable = true;
+      }
+      else if (string_val == "NO" || string_val == "no" || string_val == "No" || string_val == "OFF"
+          || string_val == "off" || string_val == "Off")
+      {
+        ltc.dumpevtstofile_setonenable = false;
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Invalid value '" << string_val << "' for " << varname << " in line " << line_number + 1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+    if (ltc.dumpevtstofile_setonenable)
+    {
+      string_val = GetNthWord(2, current_line);
+      ltc.SetFilePathForFIFODump(false, "dummy");
+      if (string_val.size() > 0)
+      {
+        ltc.dumpevtstofilepath_prefix = string_val;
+        ++Npars_ok;
+      }
+      if (Npars_tot != Npars_ok)
+      {
+        ostringstream msg;
+        msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number + 1
+            << " (Recognized only " << Npars_ok << " out of " << Npars_tot << " parameters)";
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+  }
+};
+
+
+class LTCConfigurationItem_TriggerName : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_TriggerName(LTC &_ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+    {
+      ++Npars_ok;
+      if (ulong_val >= ltc.Nextern())
+      {
+        ostringstream msg;
+        msg << "value '" << string_val << "' for " << varname << " in line " << line_number + 1
+            << " is out of range [0, " << ltc.Nextern()-1 << "]";
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+      else
+      {
+        string_val = GetNthWord(2, current_line);
+        ++Npars_ok;
+        if (string_val.empty())
+        {
+          ostringstream msg;
+          msg << "value '" << string_val << "' for " << varname << " in line " << line_number+1
+              << " is of length " << string_val.size();
+          XCEPT_RAISE(xcept::Exception, msg.str());
+        }
+
+        ltc.SetTriggerName(size_t(ulong_val), string_val);
+      }
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unknown/invalid value '" << string_val << "' for " << varname << " in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot << " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_CyclicTriggerOrBgo : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_CyclicTriggerOrBgo(LTC &_ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+
+    // Cyclic Generators
+    bool trigger = false;
+    if (FindString(current_line, (varname = WORD_CYCLICGEN_TRIGGER), string_val))
+    {
+      trigger = true;
+    }
+    else
+    {
+      varname = WORD_CYCLICGEN_BGO;
+      trigger = false;
+    }
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 1;
+    size_t id = 0;
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+    {
+      id = size_t(ulong_val);
+      if ((trigger && id >= ltc.NCyclicTrigger()) || (!trigger && id >= ltc.NCyclicBGO()))
+      {
+        ostringstream msg;
+        msg << "Invalid value '" << ulong_val << "' for " << varname << " in line " << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unknown/invalid value '" << string_val << "' for " << varname << " in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    CyclicTriggerOrBGO* cycl = ltc.GetCyclic(trigger, id);
+    string parname;
+
+    // Start BX.
+    cycl->SetStartBX(0);
+    if (GetUnsignedLong(current_line, (parname = WORD_CYCLICGEN_STARTBX), ulong_val))
+    {
+      cycl->SetStartBX(ulong_val);
+      ++Npars_ok;
+    }
+
+    // Prescale value.
+    cycl->SetPrescale(0);
+    if (GetUnsignedLong(current_line, (parname = WORD_CYCLICGEN_PRESCALE), ulong_val))
+    {
+      cycl->SetPrescale(ulong_val);
+      ++Npars_ok;
+    }
+
+    // Initial prescale.
+    cycl->SetInitialPrescale(0);
+    if (GetUnsignedLong(current_line, (parname = WORD_CYCLICGEN_INITPRECALE), ulong_val))
+    {
+      cycl->SetInitialPrescale(ulong_val);
+      ++Npars_ok;
+    }
+
+    // Postscale.
+    cycl->SetPostscale(0);
+    if (GetUnsignedLong(current_line, (parname = WORD_CYCLICGEN_POSTSCALE), ulong_val))
+    {
+      cycl->SetPostscale(ulong_val);
+      ++Npars_ok;
+    }
+
+    // Pause.
+    cycl->SetPause(0);
+    if (GetUnsignedLong(current_line, (parname = WORD_CYCLICGEN_PAUSE), ulong_val))
+    {
+      cycl->SetPause(ulong_val);
+      ++Npars_ok;
+    }
+
+    // Repetitive yes/no?
+    cycl->SetRepetitive(true);
+    if (FindString(current_line, (parname = WORD_CYCLICGEN_REPETITIVE), string_val))
+    {
+      ++Npars_ok;
+      if (string_val == "y" || string_val == "Y" || string_val == "yes" || string_val == "YES" || string_val == "Yes")
+      {
+        cycl->SetRepetitive(true);
+
+      }
+      else if (string_val == "n" || string_val == "N" || string_val == "no" || string_val == "NO" || string_val == "No")
+      {
+        cycl->SetRepetitive(false);
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Unknown/invalid value '" << parname << string_val << "' for " << varname << " in line " << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+
+    // Permanent yes/no.
+    cycl->SetPermanent(false);
+    if (FindString(current_line, (parname = WORD_CYCLICGEN_PERMANENT), string_val))
+    {
+      ++Npars_ok;
+      if (string_val == "y" || string_val == "Y" || string_val == "yes" || string_val == "YES" || string_val == "Yes")
+      {
+        cycl->SetPermanent(true);
+
+      }
+      else if (string_val == "n" || string_val == "N" || string_val == "no" || string_val == "NO" || string_val == "No")
+      {
+        cycl->SetPermanent(false);
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Unknown/invalid value '" << parname << string_val << "' for " << varname << " in line " << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+
+    // Channel (for BGOs only).
+    if (FindString(current_line, (parname = WORD_CYCLICGEN_CHANNEL), string_val))
+    {
+      ++Npars_ok;
+      if (trigger)
+      {
+        ostringstream msg;
+        msg << "Invalid parameter '" << parname << string_val << " in line " << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+      else
+      {
+        bool foundch = false;
+        for (size_t ib = 0; ib < ltc.NChannels(); ++ib)
+        {
+          if (ltc.bgo[ib].MatchesNameOrAlternative(string_val, true))
+          {
+            foundch = true;
+            cycl->SetBChannel(ib);
+            break;
+          }
+        }
+
+        if (!foundch && GetUnsignedLong(current_line, (parname = WORD_CYCLICGEN_CHANNEL), ulong_val))
+        {
+          if (ulong_val < ltc.NChannels())
+          {
+            cycl->SetBChannel(ulong_val);
+            foundch = true;
+          }
+        }
+
+        if (!foundch)
+        {
+          ostringstream msg;
+          msg << "Unknown/invalid value '" << parname << string_val << "' for " << varname << " in line " << line_number+1;
+          XCEPT_RAISE(xcept::Exception, msg.str());
+        }
+      }
+    }
+
+    string dummy;
+    if (!FindString(current_line, "DISABLE", dummy) && !FindString(current_line, "Disable", dummy)
+        && !FindString(current_line, "disable", dummy))
+    {
+      cycl->SetEnable();
+    }
+    else
+    {
+      cycl->SetEnable(false);
+      ++Npars_ok;
+    }
+
+    ltc.WriteCyclicGeneratorToLTC(trigger, id);
+
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot << " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_EnableTTS : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_EnableTTS(LTC &_ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    // TTS MASK
+    for (size_t k = 1; k < NumberOfWords(current_line); ++k)
+    {
+      string arg = GetNthWord(k, current_line);
+      uint32_t dum = 0;
+      if (FindString(arg, "aTTS", string_val) || FindString(arg, "atts", string_val)
+          || FindString(arg, "ATTS", string_val))
+      {
+        ltc.EnableTTS(6);
+      }
+      else if (GetUnsignedLong(arg, "TTS", dum))
+      {
+        ltc.EnableTTS(size_t(dum));
+      }
+      else if (GetUnsignedLong(arg, "tts", dum))
+      {
+        ltc.EnableTTS(size_t(dum));
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Unable to decipher arg " << k << " '" << arg << "' of keyword '" << varname << "' "
+            << "in line " << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+  }
+};
+
+
+class LTCConfigurationItem_TTSWarningInterval : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_TTSWarningInterval(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+    {
+      ++Npars_ok;
+      ltc.SetWarningInterval(ulong_val);
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Corrupted/missing parameter '" << string_val << "'for keyword '" << varname << "' "
+          << "in line " << dec << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+    if (Npars_tot != 1)
+    {
+      ostringstream msg;
+      msg << "Missing parameter for keyword '" << varname << "' in line " << dec << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_TriggerTicket : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_TriggerTicket(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+    {
+      ++Npars_ok;
+      ltc.SetL1ATicket((unsigned) ulong_val);
+    }
+    else if (string_val == "OFF" || string_val == "Off" || string_val == "off" || string_val == "disable"
+        || string_val == "DISABLE" || string_val == "Disable")
+    {
+      ++Npars_ok;
+      ltc.SetL1ATicket(0);
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unable to decipher arg 1 ('" << string_val << "') of keyword '" << varname << "' "
+          << "in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << " in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_Monitoring : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_Monitoring(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+    string parname;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (string_val == "ON" || string_val == "On" || string_val == "on" || string_val == "enable"
+        || string_val == "ENABLE" || string_val == "Enable")
+    {
+      ++Npars_ok;
+      ltc.EnableMonitoring();
+    }
+    else if (string_val == "OFF" || string_val == "Off" || string_val == "off" || string_val == "disable"
+        || string_val == "DISABLE" || string_val == "Disable")
+    {
+      ++Npars_ok;
+      ltc.EnableMonitoring(false);
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unable to decipher arg 1 ('" << string_val << "') of keyword '" << varname << "' "
+          << "in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    if (Npars_tot > 1)
+    {
+      if (GetUnsignedLong(current_line, (parname = WORD_MONITORING_INTERVAL), ulong_val))
+      {
+        ++Npars_ok;
+        ltc.SetMonitoringInterval(double(ulong_val));
+      }
+    }
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_VMEGPSTIME : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_VMEGPSTIME(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (string_val == "ON" || string_val == "On" || string_val == "on" || string_val == "enable"
+        || string_val == "ENABLE" || string_val == "Enable")
+    {
+      ++Npars_ok;
+      ltc.EnableBSTGPSviaVME(); // ????
+    }
+    else if (string_val == "OFF" || string_val == "Off" || string_val == "off" || string_val == "disable"
+        || string_val == "DISABLE" || string_val == "Disable")
+    {
+      ++Npars_ok;
+      ltc.EnableBSTGPSviaVME(false); // ????
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unable to decipher arg 1 ('" << string_val << "') of keyword '" << varname << "' "
+          << "in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_SlinkBackPressure : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_SlinkBackPressure(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (string_val == "YES" || string_val == "Yes" || string_val == "yes")
+    {
+      ++Npars_ok;
+      ltc.IgnoreSlinkBackpressure();
+    }
+    else if (string_val == "NO" || string_val == "No" || string_val == "no")
+    {
+      ++Npars_ok;
+      ltc.IgnoreSlinkBackpressure(false);
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unable to decipher arg 1 ('" << string_val << "') of keyword '" << varname << "' "
+          << "in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_BXGap : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_BXGap(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+
+    // BX GAPS
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    size_t begin = 99999, end = 99999;
+    if (Npars_tot > 0)
+    {
+      string dum = GetNthWord(1, current_line);
+      if (1 != sscanf(dum.c_str(), "%zu", &begin))
+      {
+        ostringstream msg;
+        msg << "Unrecognized parameter '" << dum << "' for keyword '" << varname << "' in line " << dec << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+      ++Npars_ok;
+    }
+    if (Npars_tot > 1)
+    {
+      string dum = GetNthWord(2, current_line);
+      if (1 != sscanf(dum.c_str(), "%zu", &end))
+      {
+        ostringstream msg;
+        msg << "Unrecognized parameter '" << dum << "' for keyword '" << varname << "' in line " << dec << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+      ++Npars_ok;
+    }
+    else
+    {
+      end = begin + 1;
+    }
+
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot << " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    ltc.SetBXMask(false, begin, end);
+  }
+};
+
+
+class LTCConfigurationItem_Triggers : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_Triggers(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+
+    // Triggers.
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    for (size_t kk = 1; kk < NumberOfWords(current_line); ++kk)
+    {
+      string dum = GetNthWord(kk, current_line);
+      if (dum == WORD_TRIGGERS_RAM)
+      {
+        ++Npars_ok;
+        ltc.EnableRAMTrig();
+      }
+      else if (dum == WORD_TRIGGERS_CYCLIC)
+      {
+        ++Npars_ok;
+        ltc.EnableCyclicTrig();
+      }
+      else
+      {
+        int ii = atoi(dum.c_str());
+        if (ii < 0 || ii >= int(ltc.Nextern()))
+        {
+          ostringstream msg;
+          msg << "Invalid " << kk-1 << "th parameter '" << dum << "' for keyword '" << varname << "' in line " << dec << line_number+1;
+          XCEPT_RAISE(xcept::Exception, msg.str());
+        }
+        ++Npars_ok;
+        ltc.EnableExternalTrigger(size_t(ii));
+      }
+    }
+    ltc.SendControlWord();
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_TriggerDelay : public LTCConfigurationItem
+{
+protected:
+  vector<float> &extdelays;
+
+public:
+  LTCConfigurationItem_TriggerDelay(LTC& _ltc, vector<float>& _extdelays) :
+      LTCConfigurationItem(_ltc), extdelays(_extdelays)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+
+    // Triggers.
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+    {
+      ++Npars_ok;
+      if (ulong_val < extdelays.size())
+      {
+        string wd = GetNthWord(2, current_line);
+        float delay;
+        if (1 != sscanf(wd.c_str(), "%f", &delay))
+        {
+          ostringstream msg;
+          msg << "Line " << line_number+1 << ": "
+              << "Unable to extract ext. trig. delay " << "from arg 2='" << wd << "'";
+          XCEPT_RAISE(xcept::Exception, msg.str());
+        }
+        else
+        {
+          ++Npars_ok;
+          extdelays[ulong_val] = delay;
+        }
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Invalid no. for ext. trigger " << ulong_val << " (should be 0...5) in line " << dec << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Invalid 1st parameter '" << string_val << "' (ext.trig.no.) for keyword '" << varname << "' "
+          << "in line " << dec << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+
+protected:
+
+};
+
+
+class LTCConfigurationItem_TriggerInterval : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_TriggerInterval(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_tot = 0;
+    int Npars_ok = 0;
+    uint32_t ulong_val;
+
+    // Trigger delays for internal trigger.
+    Npars_tot = NumberOfWords(current_line) - 1;
+    Npars_ok = 0;
+
+    if (GetUnsignedLong(current_line, varname, ulong_val))
+    {
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC::Configure(): " << "Line " << line_number+1 << ":\t " << varname << " will be set to '" << string_val << "'");
+
+      ++Npars_ok;
+      ltc.GetRAMTriggers()->triggerdelay.push_back((ulong_val & 0x3ffff));
+      ltc.GetRAMTriggers()->DirectlyWriteTriggerDPRAM = true;
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unknown value '" << string_val << "' for " << varname << " in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    if (Npars_tot != Npars_ok)
+    {
+      ostringstream msg;
+      msg << "Unrecognized parameters for keyword '" << varname << "' in line " << dec << line_number+1
+          << " (Recognized only " << Npars_ok << " out of " << Npars_tot<< " parameters)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+};
+
+
+class LTCConfigurationItem_TriggerFrequency : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_TriggerFrequency(LTC& _ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    int Npars_ok = 0;
+    double double_val;
+
+    // Fixed trigger frequency.
+    double frequency = -1.0;
+    bool random = false;
+    Npars_ok = 0;
+
+    if (GetDouble(current_line, varname, double_val))
+    {
+      LOG4CPLUS_INFO(
+          logger_,
+          "LTC::Configure(): " << "Line " << line_number+1 << ":\t " << varname << " will be set to " << double_val<< " Hz");
+
+      ++Npars_ok;
+      frequency = double_val;
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Unknown value '" << string_val << "' for " << varname << " in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    string parname;
+    if (FindString(current_line, (parname = WORD_TRIGGER_FREQUENCY_MODE), string_val))
+    {
+      ++Npars_ok;
+      if (string_val == "RANDOM" || string_val == "Random" || string_val == "random")
+      {
+        random = true;
+      }
+      else if (string_val == "EQUI" || string_val == "equi" || string_val == "Equi")
+      {
+        random = false;
+      }
+      else
+      {
+        ostringstream msg;
+        msg << "Unknown parameter '" << string_val << "' for " << parname << " in line " << line_number+1;
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+
+    if (!ltc.GetRAMTriggers()->CanSetInternalTriggerFrequency())
+    {
+      ostringstream msg;
+      msg << "Trying to set INTERNAL trigger freq. in line " << dec << line_number+1 << ", "
+          << "but conflict with keyword " << WORD_TRIGGER_INTERVAL << ". "
+          << "(You can EITHER set the internal trigger with a fixed freq. using the keyword " << WORD_TRIGGER_FREQUENCY
+          << " or you can configure it directly through intervals using " << WORD_TRIGGER_INTERVAL << ".)";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    ltc.GetRAMTriggers()->SetInternalTriggerFrequencyLTC(frequency, random);
+  }
+};
+
+
+class LTCConfigurationItem_TriggerRules : public LTCConfigurationItem
+{
+public:
+  LTCConfigurationItem_TriggerRules(LTC&_ltc) :
+      LTCConfigurationItem(_ltc)
+  {
+  }
+
+  void configure(
+      size_t line_number,
+      const string& current_line,
+      string varname,
+      string string_val)
+  {
+    if (NumberOfWords(current_line) != 3)
+    {
+      ostringstream msg;
+      msg << "Found " << NumberOfWords(current_line)-1 << " arguments "
+          << "while expecting 2 for keyword '" << varname << "' in line " << line_number+1;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    string wd = GetNthWord(1, current_line);
+    uint32_t irule;
+    //if (1!=sscanf(wd.c_str(),"%lu",&irule)){
+    stringstream g(wd);
+    if (wd.size() > 1 && wd[0] == '0' && (wd[1] == 'x' || wd[1] == 'X'))
+    {
+      if (!(g >> hex >> irule))
+      {
+        ostringstream msg;
+        msg << "Line " << line_number+1 << ": Unable to extract int(trig) from arg 1='" << wd << "'";
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+    else
+    {
+      if (!(g >> irule))
+      {
+        ostringstream msg;
+        msg << "Line " << line_number+1 << ": Unable to extract int(trig) from arg 1='" << wd << "'";
+        XCEPT_RAISE(xcept::Exception, msg.str());
+      }
+    }
+
+    wd = GetNthWord(2, current_line);
+    uint32_t ibx;
+    if (!String2UnsignedLong(wd, ibx))
+    {
+      ostringstream msg;
+      msg << "Line " << line_number+1 << ": Unable to extract int(N_BX) from arg 2='" << wd << "'";
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    if (size_t(irule) < ltc.FirstTriggerRule() ||
+        size_t(irule) > (ltc.TriggerRuleSize() + ltc.FirstTriggerRule()))
+    {
+      ostringstream msg;
+      msg << "Line " << line_number+1 << ": invalid trigger rule number: " << irule;
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+
+    ltc.SetTriggerRule(size_t(irule), ibx);
+  }
+};
+
+}
+
+
+// class ttc::LTCConfiguration
+
+ttc::LTCConfiguration::LTCConfiguration(ttc::LTC &_ltc)
+:
+  GenericTTCModuleConfiguration(&_ltc),
+  ltc(_ltc)
+{
+  registerConfigurationCommands();
+}
+
+
+void ttc::LTCConfiguration::Configure(istream &in)
+{
+  MutexHandler h(ltc.periodicmutex);
+
+  readLinesAndJoinContinuedLines(in);
+
+  try {
+    extractSequences();
+  }
+  catch(xcept::Exception& e)
+  {
+    XCEPT_RETHROW(
+        xcept::Exception,
+        "GenericTTCModuleConfiguration::extractSequences failed", e);
+  }
+
+  // a few necessary resets:
+  ltc.MainReset();
+  ltc.GetRAMTriggers()->ClearTriggerDelays();
+  ltc.GetRAMTriggers()->triggerFrequency = -1.0;
+  ltc.GetRAMTriggers()->DirectlyWriteTriggerDPRAM = false;
+
+  // reset the CONTROL register
+  ltc.EnableRAMTrig(false);
+  ltc.EnableCyclicTrig(false);
+  for (size_t ii = 0; ii < ltc.Nextern(); ++ii)
+  {
+    ltc.EnableExternalTrigger(ii, false);
+  }
+  ltc.SendControlWord();
+
+  ltc.SetVMEBX(99);
+
+  // Reset the BX Gaps:
+  ltc.BXMaskReset();
+
+  // Reset the bgo channels: 
+  for (size_t i = 0; i < ltc.bgo.size(); ++i)
+    ltc.bgo[i].Reset();
+
+  // Reset the cylic generators
+  ltc.ResetCyclicGenerators(true, true);
+
+  // Reset the TTS mask: disable all:
+  for (size_t i = 0; i < ltc.NTTS(); ++i)
+  {
+    ltc.EnableTTS(i, false);
+  }
+
+  extdelays = ltc.GetHWInputDelays();
+  for (size_t i = 0; i < extdelays.size(); ++i)
+  {
+    extdelays[i] = 0.0;
+  }
+  ltc.SetHWInputDelays(extdelays);
+
+  // The actual configuration
+
+  for (line_number = 0; line_number < config.size(); ++line_number)
+  {
+    const string& config_line = config[line_number];
+
+    if (config_line.empty())
+      continue;
+
+    try {
+      processSingleLine(config_line);
+    }
+    catch(xcept::Exception& e)
+    {
+      XCEPT_RETHROW(
+          xcept::Exception,
+          "GenericTTCModuleConfiguration::processSingleLine failed "
+          "for line '" + config_line + "'", e);
+    }
+  }
+
+  // Uploading of the trigger delays.
+  ltc.GetRAMTriggers()->WriteTriggerDelaysToLTC();
+
+  // Writing external trigger delays.
+  ltc.SetHWInputDelays(extdelays);
+
+  try {
+    ltc.CheckBXConflicts();
+  }
+  catch(ttc::exception::BXConflictsDetected& e)
+  {
+    LOG4CPLUS_WARN(logger_, "BX conflicts detected: " << e.what());
+  }
+}
+
+
+void ttc::LTCConfiguration::registerConfigurationCommands()
+{
+  configuration_items[WORD_QPLL] = new LTCConfigurationItem_QPLL(ltc);
+  configuration_items[WORD_VMEBX] = new LTCConfigurationItem_VMEBGOBX(ltc);
+  configuration_items[WORD_RUNLOG] = new LTCConfigurationItem_RunLog(ltc);
+  configuration_items[WORD_FIFODUMP] = new LTCConfigurationItem_FifoDump(ltc);
+  configuration_items[WORD_TRIGGERNAME] = new LTCConfigurationItem_TriggerName(ltc);
+  configuration_items[WORD_CYCLICGEN_TRIGGER] = new LTCConfigurationItem_CyclicTriggerOrBgo(ltc);
+  configuration_items[WORD_CYCLICGEN_BGO] = new LTCConfigurationItem_CyclicTriggerOrBgo(ltc);
+  configuration_items[WORD_TTS_ENABLE] = new LTCConfigurationItem_EnableTTS(ltc);
+  configuration_items[WORD_TTS_WARNINT] = new LTCConfigurationItem_TTSWarningInterval(ltc);
+  configuration_items[WORD_TRIGTICKET] = new LTCConfigurationItem_TriggerTicket(ltc);
+  configuration_items[WORD_MONITORING] = new LTCConfigurationItem_Monitoring(ltc);
+  configuration_items[WORD_BSTVME] = new LTCConfigurationItem_VMEGPSTIME(ltc);
+  configuration_items[WORD_SLINKBACKPRESSURE] = new LTCConfigurationItem_SlinkBackPressure(ltc);
+  configuration_items[WORD_BXGAP] = new LTCConfigurationItem_BXGap(ltc);
+  configuration_items[WORD_TRIGGERS] = new LTCConfigurationItem_Triggers(ltc);
+  configuration_items[WORD_TRIGGER_DELAY] = new LTCConfigurationItem_TriggerDelay(ltc, extdelays);
+  configuration_items[WORD_TRIGGER_INTERVAL] = new LTCConfigurationItem_TriggerInterval(ltc);
+  configuration_items[WORD_TRIGGER_FREQUENCY] = new LTCConfigurationItem_TriggerFrequency(ltc);
+  configuration_items[WORD_TRIGRULE] = new LTCConfigurationItem_TriggerRules(ltc);
+}
diff --git a/ttc/ltc/src/common/LTCControl.cc b/ttc/ltc/src/common/LTCControl.cc
new file mode 100755
index 000000000..6a7fcbee4
--- /dev/null
+++ b/ttc/ltc/src/common/LTCControl.cc
@@ -0,0 +1,3844 @@
+#include "ttc/ltc/LTCControl.hh"
+
+#include "ttc/ltc/LTC.hh"
+#include "ttc/ltc/LTCAddresses.hh"
+#include "ttc/ltc/LTCControlSoapHandler.hh"
+#include "ttc/ltc/version.h"
+#include "ttc/utils/TTSInfo.hh"
+#include "ttc/utils/CgiUtils.hh"
+#include "ttc/utils/HTMLTable.hh"
+#include "ttc/utils/HTMLMacros.hh"
+#include "ttc/utils/Utils.hh"
+#include "ttc/utils/RAMTriggers.hh"
+
+#include "xgi/Utils.h"
+#include "cgicc/Cgicc.h"
+#include "cgicc/HTMLClasses.h"
+#include "cgicc/HTTPHTMLHeader.h"
+
+#include "toolbox/fsm/exception/Exception.h"
+#include "toolbox/regex.h"
+#include "xcept/Exception.h"
+#include "xcept/tools.h"
+
+#include <boost/lexical_cast.hpp>
+#include <cstdlib>
+#include <cstdio>
+#include <unistd.h>
+
+
+using namespace std;
+
+
+// class ttc::LTCProxy
+
+ttc::LTCProxy::LTCProxy()
+:
+    bTimeCorrection_(0),
+    sLinkSrcId_(0)
+{}
+
+
+ttc::BoardTempLocker<ttc::LTC> ttc::LTCProxy::operator->()
+{
+  return BoardTempLocker<LTC>(*this);
+}
+
+
+void ttc::LTCProxy::initAdditionalParams(
+    const uint32_t& bTimeCorrection,
+    const uint32_t& sLinkSrcId)
+{
+  bTimeCorrection_ = bTimeCorrection;
+  sLinkSrcId_ = sLinkSrcId;
+}
+
+
+ttc::LTC* ttc::LTCProxy::createPtr(HAL::VMEBusAdapterInterface* busAdapter)
+{
+  return new ttc::LTC(
+        *busAdapter,
+        boardSlot_,
+        bTimeCorrection_,
+        enableVMEWrite_,
+        sLinkSrcId_);
+}
+
+
+// class ttc::LTCControl
+
+XDAQ_INSTANTIATOR_IMPL(ttc::LTCControl);
+
+
+ttc::LTCControl::LTCControl(xdaq::ApplicationStub* stub)
+:
+    TTCXDAQBase(stub, "LTCControl", "LTC"),
+    // info space items
+    FractionOfActiveBunches_(1.),
+    BTimeCorrection_(DEFAULT_LTC_BTC),
+    SlinkSrcId_(815),
+    TTSStatus_("Unknown"),
+    SLinkStatus_("Unknown"),
+    TriggerCounter_(0),
+    EventCounter_(0),
+    TriggerInputs_("Undefined"),
+    Efficiency_(0.),
+    AvEfficiency_(0.),
+    L1ARate_(0.),
+    AvL1ARate_(0.),
+    RawL1ARate_(0.),
+    AvRawL1ARate_(0.),
+    UptimeSec_(0),
+    HWTriggerFraction_(6, 0.),
+    HWTriggerName_(6),
+    HWTriggerEnable_(6, false),
+    HWTriggerDelay_(6, -999.),
+    ClockSource_("Undefined"),
+    ClockFrequency_(0),
+    RunNumber_(0),
+    // other members
+    resetbits_(LTC_RESET_BGOS | LTC_RESET_ORBIT | LTC_RESET_EVENT | LTC_RESET_BLOCKED),
+    OverwriteRunNumber_(false),
+    soapHandler_(0)
+{
+  // info space items and listeners
+
+  addItem("TimeOfLastStateChange",   TimeOfLastStateChange_); //< updated in push mode
+  addItem("FractionOfActiveBunches", FractionOfActiveBunches_); //< updated in push mode
+
+  addItem("BTimeCorrection",         BTimeCorrection_);
+  addItem("SlinkSrcId",              SlinkSrcId_, true);  //< retrievable for backward compatibility
+
+  addItemRetrievable("TTSStatus",          TTSStatus_);
+  addItemRetrievable("SLinkStatus",        SLinkStatus_);
+  addItemRetrievable("ClockSignal",        ClockSignal_);
+  addItemRetrievable("OrbitSignal",        OrbitSignal_);
+
+  addItemRetrievable("TriggerCounter",     TriggerCounter_);
+  addItemRetrievable("EventID",            EventCounter_);
+  addItemRetrievable("OrbitCounter",       OrbitCounter_);
+  addItemRetrievable("StrobeCounter",      StrobeCounter_);
+  addItemRetrievable("BlockedTriggers",    BlockedL1ACntr_);
+  addItemRetrievable("BoardStatus",        BoardStatus_);
+
+  addItemRetrievable("TriggerInputs",      TriggerInputs_);
+  addItemRetrievable("TotalEfficiency",    TotalEfficiency_);
+  addItemRetrievable("Efficiency",         Efficiency_);
+  addItemRetrievable("AveragedEfficiency", AvEfficiency_);
+  addItemRetrievable("L1ARate",            L1ARate_);
+  addItemRetrievable("AveragedL1ARate",    AvL1ARate_);
+  addItemRetrievable("RawL1ARate",         RawL1ARate_);
+  addItemRetrievable("AveragedRawL1ARate", AvRawL1ARate_);
+  addItemRetrievable("BlockedL1ARate",     BlockedL1ARate_);
+
+  addItemRetrievable("DeltaT",             DeltaT_);
+  addItemRetrievable("UptimeSec",          UptimeSec_);
+
+  for (size_t i = 0; i<6; ++i)
+  {
+    string s = boost::lexical_cast<string>(i);
+    addItemRetrievable          ("TriggerFraction"+s, HWTriggerFraction_[i]);
+    addItemRetrievableChangeable("TriggerName"+s,     HWTriggerName_[i]);
+    addItemRetrievableChangeable("TriggerEnable"+s,   HWTriggerEnable_[i]);
+    addItemRetrievableChangeable("TriggerDelay"+s,    HWTriggerDelay_[i]);
+  }
+
+  addItemRetrievableChangeable("ClockSource",    ClockSource_);
+  addItemRetrievableChangeable("ClockFrequency", ClockFrequency_);
+
+  addItem("RunNumber", RunNumber_, false, true); //< no ItemRetrieveEvent listener, updated in ItemChangeEvent only
+
+  // Bind SOAP callbacks for control messages
+  soapHandler_ = new LTCControlSoapHandler(this);
+
+  // CGI bindings
+  cgi_bind(this, &LTCControl::HTMLPageMainConfiguration,                "MainConfiguration", "Main Config");
+  cgi_bind(this, &LTCControl::HTMLPageBGOConfiguration,                 "BGOConfiguration",  "VME");
+  cgi_bind(this, &LTCControl::HTMLPageSequences,                        "Sequences",         "Sequences");
+  cgi_bind(this, &LTCControl::HTMLPageCyclicGenerators,                 "CyclicGenerators",  "Cyclic Gen.");
+  cgi_bind(this, &LTCControl::HTMLPageSummary,                          "SummaryPage",       "Summary");
+  cgi_bind(this, &LTCControl::HTMLPageRegisterAccess,                   "RegisterAccess",    "Registers");
+  cgi_bind(this, &LTCControl::HTMLPageRatesPopup,                       "ShowRatesPopup");
+  cgi_bind(this, &LTCControl::HTMLPageCommandNewConfigFile,             "NewConfigurationFile");
+  cgi_bind(this, &LTCControl::HTMLPageCommandWriteConfigFile,           "WriteConfigurationFile");
+  cgi_bind(this, &LTCControl::HTMLPageCommandMainConfig,                "MainConfigCommand");
+  cgi_bind(this, &LTCControl::HTMLPageCommandTriggerRulesDelays,        "TriggerRules");
+  cgi_bind(this, &LTCControl::HTMLPageCommandVMEBGOTiming,              "BGOSelectCommand");
+  cgi_bind(this, &LTCControl::HTMLPageCommandConfigureCyclicGenerator,  "CyclicConfigCommand");
+  cgi_bind(this, &LTCControl::HTMLPageCommandReadCyclicGeneratorConfig, "ReadCyclicGeneratorsFromLTC");
+  cgi_bind(this, &LTCControl::HTMLPageCommandConfigureTTS,              "TTSConfigure");
+  cgi_bind(this, &LTCControl::HTMLPageCommandRegisterAccess,            "RegisterAccessCommand");
+  cgi_bind(this, &LTCControl::HTMLPageSetControlRegisterBits,           "SetControlRegisterBits");
+  cgi_bind(this, &LTCControl::HTMLPageCommandSequenceAction,            "SequenceSelectCommand");
+  cgi_bind(this, &LTCControl::HTMLPageCommandEditSequence,              "SequenceEditCommand");
+}
+
+
+ttc::LTCControl::~LTCControl()
+{
+  if (soapHandler_)
+  {
+    delete soapHandler_;
+  }
+  soapHandler_ = 0;
+}
+
+
+ttc::LTCProxy& ttc::LTCControl::boardLockingProxy()
+{
+  return ltcProxy_;
+}
+
+
+string ttc::LTCControl::softwareVersion()
+{
+  ostringstream oss;
+  oss << TTCLTC_VERSION_MAJOR << "." << TTCLTC_VERSION_MINOR << "." << TTCLTC_VERSION_PATCH;
+  return oss.str();
+}
+
+
+void ttc::LTCControl::itemRetrieveAction(xdata::ItemRetrieveEvent& e)
+{
+  TTCXDAQBase::itemRetrieveAction(e);
+
+  string itemName = e.itemName();
+
+  if (itemName == "SlinkSrcId")
+  {
+    SlinkSrcId_ = boardLockingProxy()->GetSlinkSrcId();
+  }
+
+  else if (itemName == "TTSStatus")
+  {
+    size_t ttsmask;
+    string statusSummary = boardLockingProxy()->TTSStatusSummary(ttsmask);
+    TTSStatus_ = statusSummary + "(0x" + ttc::to_string(ttsmask, true) + ")";
+  }
+
+  else if (itemName == "SLinkStatus")
+  {
+    uint32_t stat = boardLockingProxy()->ReadSLinkStatus() & 0x3;
+    SLinkStatus_ = (stat == 3 ? "Ready" : (stat == 1 ? "Full" : "LinkDown"));
+    if (boardLockingProxy()->IsSlinkBackpressureIgnored())
+    {
+      SLinkStatus_ = string(SLinkStatus_.toString() + "(ignored)");
+    }
+  }
+
+  else if (itemName == "ClockSignal")
+  {
+    stringstream mys;
+    if (boardLockingProxy()->IsQPLLExternal())
+    {
+      mys << "EXTERN_";
+      if (boardLockingProxy()->IsClockLocked())
+        mys << "LOCKED";
+      else
+        mys << "NOT_LOCKED";
+    }
+    else
+    {
+      mys << "INTERN_0x" << hex << boardLockingProxy()->GetQPLLFrequencyBits() << dec;
+    }
+    ClockSignal_ = mys.str();
+  }
+
+  else if (itemName == "OrbitSignal")
+  {
+    OrbitSignal_ = (boardLockingProxy()->OrbitInSync() ? "OK" : "OutOfSync");
+  }
+
+  else if (itemName == "TriggerCounter")
+  {
+    TriggerCounter_ = boardLockingProxy()->ReadTriggerCounter();
+  }
+  else if (itemName == "EventID")
+  {
+    EventCounter_ = boardLockingProxy()->ReadEventCounter();
+  }
+  else if (itemName == "OrbitCounter")
+  {
+    OrbitCounter_ = boardLockingProxy()->ReadOrbitCounter();
+  }
+  else if (itemName == "StrobeCounter")
+  {
+    StrobeCounter_ = boardLockingProxy()->ReadStrobeCounter();
+  }
+  else if (itemName == "BlockedTriggers")
+  {
+    BlockedL1ACntr_ = boardLockingProxy()->ReadBlockedTriggersCounter();
+  }
+  else if (itemName == "BoardStatus")
+  {
+    BoardStatus_ = boardLockingProxy()->BoardStatus();
+  }
+
+  else if (itemName == "TriggerInputs")
+  {
+    TriggerInputs_ = "";
+    size_t n = 0;
+    stringstream t;
+    for (size_t i = 0; i < boardLockingProxy()->Nextern(); ++i)
+    {
+      if (boardLockingProxy()->IsExternalTriggerEnabled(i))
+      {
+        ++n;
+        if (n > 1)
+        {
+          t << ".or.";
+        }
+        t << boardLockingProxy()->GetTriggerName(i);
+        t << "(HW" << i << ")";
+      }
+    }
+    if (boardLockingProxy()->IsRAMTrigEnabled())
+    {
+      ++n;
+      if (n > 1)
+      {
+        t << ".or.";
+      }
+      t << "Internal(";
+      if (boardLockingProxy()->GetRAMTriggers()->CanSetInternalTriggerFrequency())
+      {
+        t << boardLockingProxy()->GetRAMTriggers()->GetInternalTriggerFrequency() << "Hz ";
+        t << (boardLockingProxy()->GetRAMTriggers()->GetInternalTriggerRandom() ? "rndm" : "equi-dist");
+      }
+      else
+      {
+        t << "direct trig-RAM config.";
+      }
+      t << ")";
+    }
+    if (boardLockingProxy()->IsCyclicTrigEnabled())
+    {
+      ++n;
+      if (n > 1)
+      {
+        t << ".or.";
+      }
+      t << "Internal(Cyclic)";
+    }
+    TriggerInputs_ = t.str();
+  }
+
+  else if (itemName == "TotalEfficiency")
+  {
+    TriggerCounter_ = boardLockingProxy()->ReadTriggerCounter();
+    BlockedL1ACntr_ = boardLockingProxy()->ReadBlockedTriggersCounter();
+    if (TriggerCounter_ + BlockedL1ACntr_ > 0)
+    {
+      TotalEfficiency_ = double(TriggerCounter_) / double(TriggerCounter_ + BlockedL1ACntr_);
+    }
+    else
+    {
+      TotalEfficiency_ = 0.0;
+    }
+  }
+  else if (itemName == "Efficiency")
+  {
+    Efficiency_ = boardLockingProxy()->GetLTCStatusInfo()->Efficiency();
+  }
+  else if (itemName == "AveragedEfficiency")
+  {
+    AvEfficiency_ = boardLockingProxy()->GetLTCStatusInfo()->Efficiency_Accumulated();
+  }
+  else if (itemName == "L1ARate")
+  {
+    L1ARate_ = boardLockingProxy()->GetLTCStatusInfo()->L1ARate();
+  }
+  else if (itemName == "AveragedL1ARate")
+  {
+    AvL1ARate_ = boardLockingProxy()->GetLTCStatusInfo()->L1ARate_Accumulated();
+  }
+  else if (itemName == "RawL1ARate")
+  {
+    RawL1ARate_ = boardLockingProxy()->GetLTCStatusInfo()->RawTriggerRate();
+  }
+  else if (itemName == "AveragedRawL1ARate")
+  {
+    AvRawL1ARate_ = boardLockingProxy()->GetLTCStatusInfo()->RawTriggerRate_Accumulated();
+  }
+  else if (itemName == "BlockedL1ARate")
+  {
+    BlockedL1ARate_ = boardLockingProxy()->GetLTCStatusInfo()->BlockedTriggerRate();
+  }
+
+  else if (itemName == "DeltaT")
+  {
+    DeltaT_ = boardLockingProxy()->GetLTCStatusInfo()->DeltaT();
+  }
+  else if (itemName == "UptimeSec")
+  {
+    UptimeSec_ = boardLockingProxy()->GetMonitoring()->RunDuration();
+  }
+
+  else
+  {
+    for (size_t i = 0; i<6; ++i)
+    {
+      string s = boost::lexical_cast<string>(i);
+
+      if (itemName == "TriggerFraction"+s)
+      {
+        HWTriggerFraction_[i] = 0.0;
+        const size_t i = 0;
+        if (boardLockingProxy()->IsExternalTriggerEnabled(i))
+        {
+          const double frac = boardLockingProxy()->GetLTCStatusInfo()->GetTriggerComposition()->GetTriggerFraction(i);
+          if (frac >= 0.0)
+            HWTriggerFraction_[i] = frac;
+        }
+      }
+      else if (itemName == "TriggerName"+s)
+      {
+        HWTriggerName_[i] = boardLockingProxy()->GetTriggerName(i);
+      }
+      else if (itemName == "TriggerEnable"+s)
+      {
+        HWTriggerEnable_[i] = boardLockingProxy()->IsExternalTriggerEnabled(i);
+      }
+      else if (itemName == "TriggerDelay"+s)
+      {
+        vector<float> delays = boardLockingProxy()->GetHWInputDelays();
+        HWTriggerDelay_[i] = delays[i];
+      }
+      else continue;
+
+      break;
+    }
+  }
+
+  if (itemName == "ClockSource")
+  {
+    ClockSource_ = (boardLockingProxy()->IsQPLLExternal() ? "External" : "Internal");
+  }
+  else if (itemName == "ClockFrequency")
+  {
+    ClockFrequency_ = boardLockingProxy()->GetQPLLFrequencyBits();
+  }
+}
+
+
+void ttc::LTCControl::itemChangedAction(xdata::ItemChangedEvent& e)
+{
+  TTCXDAQBase::itemChangedAction(e);
+
+  string itemName = e.itemName();
+
+  for (size_t i = 0; i<6; ++i)
+  {
+    string s = boost::lexical_cast<string>(i);
+    if (itemName == "TriggerName"+s)
+    {
+      boardLockingProxy()->SetTriggerName(i, HWTriggerName_[i]);
+    }
+    else if (itemName == "TriggerEnable"+s)
+    {
+      boardLockingProxy()->EnableExternalTrigger(i, HWTriggerEnable_[i]);
+    }
+    else if (itemName == "TriggerDelay"+s)
+    {
+      vector<float> delays = boardLockingProxy()->GetHWInputDelays();
+      delays[i] = HWTriggerDelay_[i];
+      boardLockingProxy()->SetHWInputDelays(delays);
+    }
+    else continue;
+
+    break;
+  }
+
+  if (itemName == "ClockFrequency")
+  {
+    boardLockingProxy()->SetQPLLFrequencyBits(ClockFrequency_, false);
+  }
+  else if (itemName == "ClockSource")
+  {
+    if (ClockSource_ == "Internal")
+    {
+      boardLockingProxy()->SetQPLLExternal(false);
+    }
+    else if (ClockSource_ == "External")
+    {
+      boardLockingProxy()->SetQPLLExternal(true);
+    }
+    else
+    {
+      ostringstream msg;
+      msg << "Invalid value '" << ClockSource_.toString() << " for parameter '" << itemName << "'.";
+
+      ClockSource_ = (boardLockingProxy()->IsQPLLExternal() ? "External" : "Internal");
+
+      XCEPT_RAISE(xcept::Exception, msg.str());
+    }
+  }
+
+  else if (itemName == "RunNumber")
+  {
+    OverwriteRunNumber_ = true;
+    boardLockingProxy()->SetRunNumber(RunNumber_);
+  }
+}
+
+
+void ttc::LTCControl::setDefaultValuesAction()
+{
+  boardLockingProxy().initAdditionalParams(BTimeCorrection_, SlinkSrcId_);
+  TTCXDAQBase::setDefaultValuesAction();
+}
+
+
+void ttc::LTCControl::ConfigureAction(toolbox::Event::Reference ev)
+{
+  for (size_t i = 0; i < boardLockingProxy()->Nextern(); ++i)
+  {
+    char dum[100];
+    sprintf(dum, "External trigger %zu (%s): %s",
+        i,
+        (i < 2 ? "nim" : "lvds"),
+        boardLockingProxy()->GetTriggerName(i).c_str());
+
+    Trigselector.SetTitle(i, string(dum));
+  }
+
+  if (ReadConfigFromFile_)
+  {
+    string filePath = asciConfigurationFilePath_.toString();
+
+    LOG4CPLUS_INFO(
+        logger_,
+        "LTCControl::ConfigureAction(): Input file = '" + filePath + "'");
+
+    ifstream in(filePath.c_str(), ios_base::in);
+    if (!in)
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "Cannot open input file '" + filePath + "' for reading");
+    }
+
+    try {
+      boardLockingProxy()->Configure(in); // TODO check
+    }
+    catch(xcept::Exception& e)
+    {
+      XCEPT_RETHROW(
+          xcept::Exception,
+          "LTC::Configure with configuration from file'" + filePath + "' failed", e);
+    }
+  }
+  else
+  {
+    LOG4CPLUS_INFO(
+        logger_,
+        "LTCControl::ConfigureAction(): Reading configuration from XML parameter 'Configuration'");
+
+    stringstream input;
+    input << ConfigurationString_.toString() << endl;
+
+    try {
+      boardLockingProxy()->Configure(input);
+    }
+    catch(xcept::Exception& e)
+    {
+      XCEPT_RETHROW(
+          xcept::Exception,
+          "LTC::Configure with configuration from XML parameter 'Configuration' failed", e);
+    }
+  }
+
+  // Set the run number if necessary.
+  if (OverwriteRunNumber_)
+  {
+    boardLockingProxy()->SetRunNumber(RunNumber_);
+  }
+
+  boardLockingProxy()->ExecuteSequence("configure");
+
+  if (boardLockingProxy()->IsL1AEnabled())
+  {
+    string msg =
+        "L1A is enabled after 'configure'. "
+        "Please enable L1A only in the 'enable' sequence.";
+
+    error_messages.add("WARNING") << msg;
+    LOG4CPLUS_WARN(logger_, msg);
+  }
+
+  FractionOfActiveBunches_ = boardLockingProxy()->GetActiveBXFraction();
+  TimeOfLastStateChange_ = ttc::GetCurrentTime();
+}
+
+
+void ttc::LTCControl::EnableAction(toolbox::Event::Reference e)
+{
+  boardLockingProxy()->ExecuteSequence("enable");
+
+  TimeOfLastStateChange_ = ttc::GetCurrentTime();
+
+  if (!boardLockingProxy()->IsL1AEnabled())
+  {
+    string msg =
+        "L1A is disabled after 'enable'. "
+        "Please enable L1A in the 'enable' sequence.";
+
+    error_messages.add("WARNING") << msg;
+    LOG4CPLUS_WARN(logger_, msg);
+  }
+}
+
+
+void ttc::LTCControl::StopAction(toolbox::Event::Reference e)
+{
+  boardLockingProxy()->ExecuteSequence("stop");
+
+  TimeOfLastStateChange_ = ttc::GetCurrentTime();
+
+  if (boardLockingProxy()->IsL1AEnabled())
+  {
+    string msg =
+        "L1A is enabled after 'stop'. "
+        "Please disable L1A in the 'stop' and 'suspend' sequences.";
+
+    error_messages.add("WARNING") << msg;
+    LOG4CPLUS_WARN(logger_, msg);
+  }
+}
+
+
+void ttc::LTCControl::SuspendAction(toolbox::Event::Reference e)
+{
+  boardLockingProxy()->ExecuteSequence("suspend");
+
+  TimeOfLastStateChange_ = ttc::GetCurrentTime();
+
+  if (boardLockingProxy()->IsL1AEnabled())
+  {
+    string msg =
+        "L1A is enabled after 'Suspend'. "
+        "Please disable L1A in the 'stop' and 'suspend' sequences.";
+
+    error_messages.add("WARNING") << msg;
+    LOG4CPLUS_WARN(logger_, msg);
+  }
+}
+
+
+void ttc::LTCControl::CommandImpl(cgicc::Cgicc& cgi, const string& command)
+{
+  LOG4CPLUS_INFO(
+      logger_,
+      "LTCControl::CommandImpl: Executing CGI command '" + command + "'");
+
+  if (command == "ResetCounters")
+  {
+    if (fsm_.getCurrentState() != 'E')
+    {
+      resetbits_ = 0;
+      if (cgi.queryCheckbox("orbitcounter"))
+      {
+        resetbits_ |= LTC_RESET_ORBIT;
+      }
+      if (cgi.queryCheckbox("strobecounter"))
+      {
+        resetbits_ |= LTC_RESET_BGOS;
+      }
+      if (cgi.queryCheckbox("eventcounter"))
+      {
+        resetbits_ |= LTC_RESET_EVENT;
+      }
+      if (cgi.queryCheckbox("triggercounter"))
+      {
+        resetbits_ |= LTC_RESET_TRIGGER;
+      }
+      if (cgi.queryCheckbox("btcounter"))
+      {
+        resetbits_ |= LTC_RESET_BLOCKED;
+      }
+
+      boardLockingProxy()->ResetCounters(resetbits_);
+    }
+  }
+  else
+  {
+    XCEPT_RAISE(xcept::Exception, "Unknown LTC CGI command '" + command + "'");
+  }
+}
+
+
+void ttc::LTCControl::HTMLPageMain(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageMain");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh
+      << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl
+      << "<html>" << endl
+      << "<head>" << endl
+      << cgicc::title("LTC &quot;" + name_.toString() + "&quot;") << endl;
+
+  if (autoRefresh_)
+  {
+    xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"5; URL=" << lastPage_ << "\">" << endl;
+  }
+
+  WriteJavascriptPopupCode(xoh);
+
+  xoh
+      << "</head>" << endl
+      << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ReadLTCCounters();
+
+  ErrorStatement(xoh);
+
+  PrintFSMTable(xoh);
+  PrintSequenceTable(xoh);
+
+  // The trigger ticket button.
+  {
+    HTMLTable tab(xoh, 1, 10, 0, "", "center");
+    tab.NewCell();
+    xoh << "<b>Issue a trigger burst</b><br>" << "(Number of triggers configured on Main Config page.)";
+    tab.NewCell();
+    xoh
+        << cgicc::form().set("method", "get").set("action",
+            "/" + getApplicationDescriptor()->getURN() + "/SoapCommand").set("enctype", "multipart/form-data")
+        << endl;
+    if (fsm_.getCurrentState() == 'E' && boardLockingProxy()->GetL1ATicket() > 0 && boardLockingProxy()->GetFirmwareVersion() >= 12)
+    {
+      xoh << cgicc::input().set("type", "submit").set("name", "Command").set("value", "L1ATicket") << "<br>"
+          << SMALLER
+          << "(request " << boardLockingProxy()->GetL1ATicket() << " L1As)" << NOSMALLER;
+    }
+    else
+    {
+      xoh
+          << cgicc::input().set("type", "submit").set("name", "Command").set("value", "L1ATicket").set("disabled",
+              "true");
+    }
+    xoh << cgicc::form();
+    tab.Close();
+  }
+
+  // The status table.
+  HTMLTable tab(xoh, 1, 10, 0, "", "center");
+  tab.NewRow();
+  tab.NewCell();
+  xoh << "<b>Status</b>";
+  tab.NewCell();
+
+  // Run number.
+  xoh << "Run no: " << dec << (RunNumber_ = boardLockingProxy()->GetRunNumber());
+
+  // Trigger ticket information.
+  tab.NewCell();
+  xoh << "Trigger ticket: ";
+  if (boardLockingProxy()->GetFirmwareVersion() < 12)
+  {
+    xoh << "<br>(Requires FW Ver 12+)";
+  }
+  else if (boardLockingProxy()->GetL1ATicket() > 0)
+  {
+    xoh << boardLockingProxy()->GetL1ATicket() << "<br>";
+    if (boardLockingProxy()->ReadTriggerCounter() >= boardLockingProxy()->GetMaxTrigger())
+    {
+      xoh << RED<< BOLD << "Blocked" << NOBOLD << NOCOL << endl;
+    }
+    else
+    {
+      xoh << GREEN << (boardLockingProxy()->GetMaxTrigger() - boardLockingProxy()->ReadTriggerCounter()) << " remaining" << NOCOL << endl;
+    }
+  }
+  else
+  {
+    xoh << GREY << "Off" << NOCOL;
+  }
+
+    // Periodic sequence status.
+  tab.NewCell();
+  if (!boardLockingProxy()->PeriodicSequenceEnabled() || (boardLockingProxy()->Periodicity() < 0.0))
+  {
+    xoh << "Periodic seq.: " << GREY << "Off" << endl;
+    xoh << NOCOL << endl;
+  }
+  else
+  {
+    xoh << "Periodic seq.: " << RED << "On (" << boardLockingProxy()->Periodicity() << " s)" << NOCOL;
+  }
+
+  // Detailed board status.
+  string defaultcol = GREEN;
+  string alertcol = RED;
+  tab.NewRow();
+  tab.NewCell("", 4);
+
+  xoh
+      << UNDERL << "Board status:" << NOUNDERL
+      << MONO << BLUE << hex << " 0x" << BoardStatus_ << NOCOL << NOMONO << dec << endl;
+
+  {
+    // Clock sync.
+    xoh << "<br>Clock: ";
+    if (boardLockingProxy()->IsQPLLExternal())
+    {
+      xoh << "external ";
+      if (boardLockingProxy()->IsClockLocked())
+      {
+        xoh << "(" << defaultcol << "locked" << NOCOL << ")";
+      }
+      else
+      {
+        xoh << "(" << alertcol << "not locked!" << NOCOL << ")";
+      }
+    }
+    else
+    {
+      xoh << alertcol << "internal" << NOCOL << " (0x" << hex << boardLockingProxy()->GetQPLLFrequencyBits() << dec << ")";
+    }
+
+    // Orbit sync.
+    bool isok = boardLockingProxy()->OrbitInSync();
+    string col = (isok ? defaultcol : alertcol);
+    xoh << "<br>" << "Orbit in sync.? " << col << (isok ? "yes" : "no") << NOCOL << endl;
+
+    // Cancel counter.
+    uint32_t ncan = boardLockingProxy()->CancelledTriggers();
+    isok = (ncan == 0);
+    col = (isok ? defaultcol : alertcol);
+    xoh << "<br>" << "Triggers cancelled by rules: " << col << ncan << NOCOL << endl;
+
+    // TTS status.
+    string select_url = "/";
+    select_url += getApplicationDescriptor()->getURN();
+    select_url += "/TTSConfigure";
+    xoh << cgicc::form().set("method", "post").set("action", select_url).set("enctype", "multipart/form-data")
+        << endl;
+    xoh << cgicc::fieldset() << endl;
+    xoh << cgicc::legend("TTS &amp; S-Link Status") << endl;
+    xoh << "<center>";
+    HTMLTable ttstab(xoh, 1, 2, 2, "", "center");
+    ttstab.NewRow();
+
+    TTSInfo mytts(boardLockingProxy()->ReadTTSStatus());
+
+    for (int j = 0; j < int(mytts.NPartitions()) + 1; ++j)
+    {
+      if (j == 1)
+      {
+        ttstab.NewCell("white");
+        // S-link status.
+        if (!boardLockingProxy()->IsSlinkBackpressureIgnored())
+        {
+          xoh << cgicc::input().set("type", "checkbox").set("name", "slinkbackpressure").set("checked", "checked")
+              << BLACK << endl;
+        }
+        else
+        {
+          xoh << cgicc::input().set("type", "checkbox").set("name", "slinkbackpressure") << GREY << endl;
+        }
+        string slstat;
+        boardLockingProxy()->ReadSLinkStatus(slstat, true);
+        xoh << "S-Link: " << NOCOL << "<br>" << slstat << endl;
+
+        continue;
+      }
+
+      int i = 0;
+      // Map the position in the HTML table to the number of the TTS
+      // input in the LTC firmware?
+      switch (j)
+      {
+        case 0:
+          i = 6;
+          break;
+        case 2:
+          i = 4;
+          break;
+        case 3:
+          i = 5;
+          break;
+        case 4:
+          i = 2;
+          break;
+        case 5:
+          i = 3;
+          break;
+        case 6:
+          i = 0;
+          break;
+        case 7:
+          i = 1;
+          break;
+        default:
+          xoh << "TTS ERROR!" << endl;
+          j = 99;
+          continue;
+      }
+      if ((j > 0) && ((j % 2) == 0))
+      {
+        ttstab.NewRow();
+      }
+      string cellcol = "grey";
+      bool enabled = boardLockingProxy()->IsTTSEnabled(i);
+
+      if (!enabled)
+        cellcol = "grey";
+      else if (mytts.IsReady(i))
+        cellcol = "green";
+      else if (mytts.IsDisconnected(i))
+        cellcol = "lightgrey";
+      else if (mytts.IsOutOfSync(i))
+        cellcol = "red";
+      else if (mytts.IsWarning(i))
+        cellcol = "orange";
+      else if (mytts.IsError(i))
+        cellcol = "red";
+      else
+        cellcol = "red";
+
+      ttstab.NewCell(cellcol);
+
+      // Checkbox.
+      stringstream stm;
+      stm << "TTS " << i;
+      if (enabled)
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", stm.str()).set("checked", "checked") << endl;
+      }
+      else
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", stm.str()) << endl;
+      }
+
+      if (i == 6)
+      {
+        // aTTS
+        xoh << "aTTS<br>" << endl;
+      }
+      else
+      {
+        // sTTS
+        xoh << "sTTS(" << i << ")<br>" << endl;
+      }
+
+      xoh << BOLD << mytts.GetStatus_String(i, !enabled) << NOBOLD;
+    }
+    ttstab.Close();
+    xoh << "</center>";
+
+    {
+      xoh << "Wait " << endl;
+      stringstream dum;
+      dum << boardLockingProxy()->GetWarningInterval();
+      xoh
+          << cgicc::input().set("type", "text").set("name", "warningpause").set("size", "3").set("value",
+              dum.str().c_str()) << endl;
+      xoh << " BX for &quot;Warning&quot;" << endl;
+    }
+
+    // End of fieldset.
+    xoh << cgicc::fieldset() << endl;
+    xoh << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Apply");
+    xoh << cgicc::form() << endl;
+
+    const uint32_t ttswd = mytts.GetStatusWord();
+    xoh << "(TTS: 0x" << hex << ttswd << dec << " = <br>";
+
+    for (int i = 4 * int(mytts.NPartitions()) - 1; i >= 0; --i)
+    {
+      xoh << (((ttswd >> i) & 1) ? "1" : "0");
+      if (i % int(mytts.NPartitions()) == 0 && i > 0)
+        xoh << "-";
+    }
+    xoh << ")<br>" << endl;
+  }
+  tab.Close();
+
+  // Counters table.
+  string command_url = "/";
+  command_url += getApplicationDescriptor()->getURN();
+  command_url += "/Command";
+  tab.Set(1, 10, 0, "", "left");
+  tab.Open();
+
+  tab.NewRow();
+  tab.NewCell();
+  xoh << "<center>" << BOLD << "Counters" << NOBOLD
+  << "<br/>" << "<font size=\"-2\">" << "(<a href=\"ShowRatesPopup\"" << "target=\"rates_popup_frame\" "
+      << "onclick=\"return openPopup('" << getFullURL() << "/ShowRatesPopup',"
+      << "'rates_popup_frame',400,200);\">show rates popup</a>)" << endl << "</font>" << endl << "</center>";
+
+  // Print all values read.
+  tab.NewCell("", 1, 2);
+
+  xoh
+      << UNDERL << "Counters" << NOUNDERL << endl
+      << "<br>" << "Triggers: " << RED<<TriggerCounter_ << NOCOL << endl
+      << "<br>" << "Evt-ID: " << RED<<EventCounter_ << NOCOL << endl
+      << "<br>" << "Orbit: " << RED<< OrbitCounter_ << NOCOL << endl
+      << "(~ " << GenericTTCModule::OrbitCounterToSecondsString(OrbitCounter_) << ")" << endl
+      << "<br>" << "BGO Cntr: " << RED << StrobeCounter_ << NOCOL << endl
+      << "<br>" << "Blocked L1As: " << RED << BlockedL1ACntr_ << NOCOL << endl;
+
+  {
+    const LTCStatusInfo* S = boardLockingProxy()->GetLTCStatusInfo();
+    const double dt = S->DeltaT();
+
+    xoh << "<br><br>" << UNDERL << "L1A rate (after " << dt << " s):" << NOUNDERL << "<br>" << endl;
+    xoh << S->L1ADiff() << " L1As in " << S->OrbitDiff() << " orbits.<br>" << endl;
+    if (S->OrbitDiff() > 0)
+    {
+      xoh << RED << S->L1ARate() << " Hz" << NOCOL;
+      xoh << " (" << int(S->DeltaT_Accumulated() + 0.5) << " s avg.: " << ORANGE << S->L1ARate_Accumulated() << " Hz"
+          << NOCOL << ")";
+      xoh << "<br>" << endl;
+    }
+    else
+    {
+      xoh << RED << "unknown" << NOCOL << "<br>" << endl;
+    }
+    xoh << "Eff. e = ";
+    if (S->RawDiff() > 0)
+    {
+      xoh << RED<<(100. * S->Efficiency()) << " %" << NOCOL;
+      xoh << " (" << int(S->DeltaT_Accumulated() + 0.5) << " s avg.: " << ORANGE<<100. * S->Efficiency_Accumulated()
+          << " %" << NOCOL << ")";
+      xoh << "<br>" << endl;
+      xoh << " (1-e = ";
+      xoh << RED<<(100. * (1.0 - S->Efficiency())) << " %" << NOCOL << ")" << "<br>" << endl;
+    }
+    else
+    {
+      xoh << RED<< "unknown" << NOCOL
+      << "<br>" << endl << " (1-e = " << RED<< "unknown" << NOCOL << ")" << "<br>" << endl;
+    }
+    if (S->OrbitDiff() > 0)
+      xoh << S->L1AsPerOrbit() << " L1As/orbit <br>" << endl;
+    else
+      xoh << "unknown L1As/orbit <br>" << endl;
+    if (S->L1ADiff() > 0)
+      xoh << 1.0 / S->L1AsPerOrbit() << " orbits/L1A <br>" << endl;
+    else
+      xoh << "unknown orbits/L1A <br>" << endl;
+    xoh << "<br>" << UNDERL<< "BGO rate (after " << dt << " s):" << NOUNDERL<< "<br>" << endl;
+    xoh << S->BGODiff() << " BGOs in " << S->OrbitDiff() << " orbits.<br>" << endl;
+    if (S->OrbitDiff() > 0)
+      xoh << RED<<S->BGORate() << " Hz" << NOCOL << "<br>" << endl;
+    else
+      xoh << RED<< "unknown" << NOCOL << "<br>" << endl;
+    if (S->OrbitDiff() > 0)
+      xoh << S->BGOsPerOrbit() << " BGOs/orbit<br>" << endl;
+    else
+      xoh << "unknown BGOs/orbit<br>" << endl;
+    if (S->BGODiff() > 0)
+      xoh << 1.0 / S->BGOsPerOrbit() << " orbits/BGO<br>" << endl;
+    else
+      xoh << "unknown orbits/BGO <br>" << endl;
+
+    xoh << NOMONO;
+    tab.NewRow();
+    tab.NewCell();
+    // ResetCounters button.
+    xoh << BOLD << "Counters:" << NOBOLD << "<br>"
+        << cgicc::form().set("method", "get").set("action", command_url).set("enctype", "multipart/form-data") << endl
+        << "<input type=\"checkbox\" name =\"orbitcounter\"" << (resetbits_ & LTC_RESET_ORBIT ? " checked" : "")
+        << ">Orbits<br>" << "<input type=\"checkbox\" name =\"strobecounter\""
+        << (resetbits_ & LTC_RESET_BGOS ? " checked" : "") << ">BGOs<br>"
+        << "<input type=\"checkbox\" name =\"eventcounter\"" << (resetbits_ & LTC_RESET_EVENT ? " checked" : "")
+        << ">Event ID<br>" << "<input type=\"checkbox\" name =\"triggercounter\""
+        << (resetbits_ & LTC_RESET_TRIGGER ? " checked" : "") << ">Total triggers<br>"
+        << "<input type=\"checkbox\" name =\"btcounter\"" << (resetbits_ & LTC_RESET_BLOCKED ? " checked" : "")
+        << ">Blocked triggers<br>" << endl;
+
+    if (fsm_.getCurrentState() == 'E')
+    {
+      xoh
+          << cgicc::input()
+          .set("type", "submit")
+          .set("name", "Command")
+          .set("value", "ResetCounters")
+          .set("disabled", "true");
+    }
+    else
+    {
+      xoh << cgicc::input().set("type", "submit").set("name", "Command").set("value", "ResetCounters");
+    }
+    xoh << cgicc::form();
+  }
+  tab.Close();
+  xoh << "<p>" << endl;
+
+  // General LTC info.
+  uint32_t slinkSrcId = boardLockingProxy()->GetSlinkSrcId();
+  uint32_t bTimeCorrection = boardLockingProxy()->GetBTimeCorrection();
+  xoh
+      << "SLink Source ID: " << slinkSrcId << " (0x" << hex << slinkSrcId << dec << ")<br>" << endl
+      << "BTimeCorrection: " << bTimeCorrection << " BX " << "<br>" << endl;
+
+  { // Configuration file display and change.
+    string confurl = "/";
+    confurl += getApplicationDescriptor()->getURN();
+    confurl += "/NewConfigurationFile";
+
+    xoh << cgicc::form().set("method", "post").set("action", confurl).set("enctype", "multipart/form-data") << endl;
+
+    GetFileList();
+    xoh << cgicc::fieldset() << endl;
+    xoh << cgicc::legend("Configure LTC FROM file") << endl;
+    xoh << cgicc::label("Current configuration source: ");
+    if (ReadConfigFromFile_)
+    {
+      xoh << "File (" << MONO
+      <<asciConfigurationFilePath_.toString() << NOMONO<< ")" << endl;
+    }
+    else
+    {
+      xoh << "NOT from file but directly from the xml input-string &quot;Configuration&quot;" << endl;
+    }
+    xoh << "<br>" << endl;
+    InputFileList.Write(xoh);
+    xoh << cgicc::label("&nbsp;&nbsp;&nbsp;&nbsp;(enter absolute path): ") << endl;
+    xoh << cgicc::input().set("type", "text").set("name", "ConfigurationFile").set("size", "60").set("value", "")
+        << cgicc::p() << endl;
+    xoh << "<p>" << endl;
+    xoh << SMALLER
+    << "N.B.: 'Submit' will only change path " << "to the configuration file, the "
+        << "configuration itself (i.e. opening the file and " << "reading in the "
+        << "configuration) will happen when requesting 'Configure' " << "in the State Machine." << NOSMALLER << "<br>"
+        << endl;
+    xoh << cgicc::fieldset() << endl;
+    xoh << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Submit");
+    xoh << "<p>" << endl;
+    xoh << cgicc::form() << endl;
+
+    // Write configration to new file.
+    confurl = "/";
+    confurl += getApplicationDescriptor()->getURN();
+    confurl += "/WriteConfigurationFile";
+
+    xoh << cgicc::form().set("method", "post").set("action", confurl).set("enctype", "multipart/form-data") << endl;
+
+    xoh << cgicc::fieldset() << endl;
+    char s[1024];
+    gethostname(s, sizeof s);
+    string machine = s;
+    size_t pos = machine.find_first_of(".");
+    if (pos < machine.size())
+      machine.erase(machine.begin() + pos, machine.end());
+    machine = string(" (on ") + MONO + machine + NOMONO + ")";
+    xoh << cgicc::legend((string("Write current configuration TO file") + machine).c_str()) << endl;
+    xoh << cgicc::label("Destination (enter absolute path): ") << endl;
+    xoh
+        << cgicc::input().set("type", "text").set("name", "ConfigurationFile").set("size", "60").set("value",
+            (ReadConfigFromFile_ ? asciConfigurationFilePath_.toString() : "")) << cgicc::p() << endl;
+    xoh << "<p>" << endl;
+
+    xoh << cgicc::input().set("type", "checkbox").set("name", "overwrite") << endl;
+    xoh << "force overwrite (if file exists)" << endl;
+
+    xoh << cgicc::fieldset() << endl;
+    xoh << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Write");
+    xoh << "<p>" << endl;
+    xoh << cgicc::form() << endl;
+  }
+
+  PrintHTMLFooter(xoh);
+
+  xoh << "</body>" << "</html>" << endl;
+}
+
+
+void ttc::LTCControl::HTMLPageMainConfiguration(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageMainConfiguration");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl;
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << cgicc::title("LTC \"" + name_.toString() + "\"") << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ErrorStatement(xoh);
+
+  xoh << "Finite State Machine: ";
+  PrintFSMState(xoh);
+  xoh << cgicc::p() << cgicc::p() << endl;
+
+  string command_url = "/";
+  command_url += getApplicationDescriptor()->getURN();
+  command_url += "/MainConfigCommand";
+
+  xoh
+      << cgicc::form()
+      .set("method", "post")
+      .set("action", command_url)
+      .set("enctype", "multipart/form-data") << endl
+      << cgicc::fieldset() << endl;
+
+  stringstream my;
+  my << "Main Config / QPLL";
+  xoh << cgicc::legend(my.str().c_str()) << endl;
+
+  // Table
+  HTMLTable tab(xoh, 0, 2, 2, "", "", 100);
+  tab.NewRow();
+
+  // INPUTS
+  {
+    tab.NewCell();
+    xoh << BOLD<< "Trigger Selection:" << NOBOLD<< "<br>" << endl;
+    for (size_t i = 0; i < Trigselector.size(); ++i)
+    {
+      int ii = atoi(Trigselector.GetValue(i).c_str());
+      if (ii == int(boardLockingProxy()->Nextern()))
+      {
+        Trigselector.SetCheck(i, boardLockingProxy()->IsCyclicTrigEnabled());
+      }
+      else if (ii == 1 + int(boardLockingProxy()->Nextern()))
+      {
+        Trigselector.SetCheck(i, boardLockingProxy()->IsRAMTrigEnabled());
+      }
+      else if (ii < 0 || ii > 1 + int(boardLockingProxy()->Nextern()))
+      {
+        LOG4CPLUS_ERROR(logger_, "LTCControl::MainConfiguration(): "
+        "invalid trigger selection value: " << Trigselector.GetValue(i));
+      }
+      else
+      {
+        Trigselector.SetCheck(i, boardLockingProxy()->IsExternalTriggerEnabled(size_t(ii)));
+      }
+      if (i < boardLockingProxy()->Nextern())
+      {
+        char dum2[100];
+        sprintf(dum2, "External trigger %zu (%s): %s", i, (i < 2 ? "nim" : "lvds"),
+            boardLockingProxy()->GetTriggerName(i).c_str());
+        Trigselector.SetTitle(i, string(dum2));
+      }
+    }
+    Trigselector.Write(xoh);
+    if (boardLockingProxy()->GetRAMTriggers()->CanSetInternalTriggerFrequency())
+    { // Trigger Frequency
+      xoh << cgicc::label("&nbsp;&nbsp;&nbsp;&nbsp;Freq.: ");
+      char freq[20];
+      double trigfreq = boardLockingProxy()->GetRAMTriggers()->GetInternalTriggerFrequency();
+      if (trigfreq < 0)
+        sprintf(freq, "1");
+      else if (trigfreq == double(int(trigfreq)))
+        sprintf(freq, "%.0f", trigfreq);
+      else
+        sprintf(freq, "%.2f", trigfreq);
+      xoh
+          << cgicc::input().set("type", "text").set("name", "TriggerFrequency").set("size", "6").set("value",
+              string(freq)) << " Hz" << endl;
+      if (boardLockingProxy()->GetRAMTriggers()->GetInternalTriggerRandom())
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", "TriggerRandom").set("checked", "checked")
+            << GREEN << " Random" << NOCOL << endl;
+      }
+      else
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", "TriggerRandom") << " Random" << endl;
+      }
+
+    }
+    else
+    {
+      xoh << GREY<< "&nbsp;&nbsp;&nbsp;&nbsp;Freq.: " << "not applicable.<br>";
+      xoh << "&nbsp;&nbsp;&nbsp;&nbsp;(\"" << MONO << "TRIGGER_INTERVAL x" << NOMONO
+      << "\" in config. file)" << NOCOL << endl;
+    }
+
+    xoh << "<br>" << endl;
+
+    xoh << SMALLER << "CONTROL = " << MONO<< BLUE << "0x" << hex
+    << boardLockingProxy()->GetControlWord()
+    << NOCOL << NOMONO << " (" << MONO << BLUE << "0x" << boardLockingProxy()->ReadControlWord()
+    << NOCOL << NOMONO << " on board)<br>" << endl
+    << NOSMALLER << endl;
+
+    xoh << BOLD<< "Trigger Status: " << NOBOLD;
+
+    if (boardLockingProxy()->IsL1AEnabled())
+    {
+      xoh << GREEN<<BOLD<< "L1A Enabled" <<NOBOLD<< NOCOL << endl;
+    }
+    else
+    {
+      xoh << RED<<BOLD<< "L1A Disabled" <<NOBOLD<< NOCOL << endl;
+    }
+
+    // Trigger Burst
+    xoh << "<br>" << BOLD << "L1A/Trigger Ticket:" << NOBOLD;
+    if (boardLockingProxy()->GetFirmwareVersion() < 12)
+    {
+      xoh << " (Requires Firmware V. 12+)";
+    }
+    else if (boardLockingProxy()->GetL1ATicket() != 0 && boardLockingProxy()->ReadTriggerCounter() >= boardLockingProxy()->GetMaxTrigger())
+    {
+      xoh << RED<<BOLD<< " (Triggers Blocked)" << NOBOLD << NOCOL;
+    }
+    else if (boardLockingProxy()->GetL1ATicket() != 0)
+    {
+      xoh << GREEN<< (boardLockingProxy()->GetMaxTrigger() - boardLockingProxy()->ReadTriggerCounter()) << " remaining" << NOCOL;
+    }
+    xoh << "<br>\n";
+    if (boardLockingProxy()->GetL1ATicket() != 0)
+    {
+      xoh << cgicc::input().set("type", "checkbox").set("name", "bursten").set("checked", "checked")
+          << GREEN << " Enable" << NOCOL << endl;
+    }
+    else
+    {
+      xoh << cgicc::input().set("type", "checkbox").set("name", "bursten") << " Enable" << endl;
+    }
+
+    {
+      char dum[30];
+      sprintf(dum, "%u", boardLockingProxy()->GetL1ATicket());
+      xoh << " - No. of L1As: "
+          << cgicc::input().set("type", "text").set("name", "trigburst").set("size", "6").set("value", dum) << endl;
+    }
+    xoh << "<br>" << endl << SMALLER << "MAXTRIG = " << MONO<<BLUE<<dec
+    <<boardLockingProxy()->GetMaxTrigger()
+    << NOCOL <<NOMONO<<NOSMALLER<< endl;
+
+    tab.NewCell();
+
+    // QPLL
+    {
+      //xoh<< "<br>" << endl;
+      string sel = UNDERL, unsel = NOUNDERL;
+      xoh << BOLD<< "QPLL Control:" << NOBOLD<< "<br>" << endl;
+      xoh << "QPLLCTRL Bit 6" << ":<br> " << endl;
+
+      bool qpll_external_mode = boardLockingProxy()->IsQPLLExternal();
+
+      WriteBinaryRadioButton(xoh, "QPLLext", "External (0)", "Internal (1)", "YES", "NO",
+          (qpll_external_mode ? 0 : 1), false // not disabled
+          );
+      xoh << " clock" << endl;
+      xoh << "<br>" << endl;
+
+      if (!qpll_external_mode)
+        xoh << "<span style=\"color: grey\";>";
+
+      xoh << "QPLLCTRL Bit 5" << SMALLER << " (ignored for internal clock)" << NOSMALLER
+      << ":<br> " << endl;
+
+      WriteBinaryRadioButton(xoh, "QPLLReset", "Reset (0)", "No Reset (1)", "YES", "NO",
+          boardLockingProxy()->Is_ResetQPLL() ? 0 : 1, !qpll_external_mode // disabled in internal mode
+          );
+      xoh << "<br>" << endl;
+
+      //--------------------
+
+      xoh << "QPLLCTRL Bit 4" << SMALLER << " (ignored for internal clock)" << NOSMALLER
+      ":<br> " << endl;
+
+      {
+        if (boardLockingProxy()->IsQPLLExternal())
+        {
+          if (boardLockingProxy()->Is_AutoRestartQPLL())
+            xoh << GREEN;
+          else
+            xoh << RED;
+        }
+
+        xoh << "AutoRestart";
+
+        if (boardLockingProxy()->IsQPLLExternal())
+          xoh << NOCOL;
+
+        xoh << ": " << endl;
+      }
+
+      WriteBinaryRadioButton(xoh, "QPLLAutoRestart", "ON (1)", "OFF (0)", "ON", "OFF",
+          boardLockingProxy()->Is_AutoRestartQPLL() ? 0 : 1, !qpll_external_mode // disabled in internal mode
+          );
+
+      xoh << "<br>" << endl;
+
+      if (!qpll_external_mode)
+        xoh << "</span>";
+
+      // QPLL Frequency bits
+      {
+        // This control is ignored when on external clock.
+        if (qpll_external_mode)
+        {
+          xoh << "<span style=\"color: grey\";>";
+        }
+
+        stringstream dum;
+        dum << hex << boardLockingProxy()->GetQPLLFrequencyBits();
+        xoh << "QPLL Freq. bits: <br>" << MONO<< "0x" << NOMONO;
+
+        xoh << "<input type=\"text\" name=\"freqbits\" size=\"3\" value=\"" << dum.str() << "\"";
+
+        if (qpll_external_mode)
+          xoh << " disabled";
+
+        xoh << "/>" << endl;
+        xoh << SMALLER << " (0x00..0x3F for internal clock, ignored for external clock)" << NOSMALLER<< endl;
+
+        if (qpll_external_mode)
+          xoh << "</span>";
+      }
+
+      xoh << "<br>" << SMALLER<< "(QPLLCTRL = " << MONO<<BLUE<< "0x"
+      <<hex<<boardLockingProxy()->Read(LTCAdd::QPLLCTRL)<< NOCOL <<NOMONO
+      <<dec<< ")" <<NOSMALLER<< endl;
+
+      // GPS Time
+      xoh << "<br>" << BOLD<< "BST GPS Time Signal" << NOBOLD<< "<br>" << endl;
+      if (boardLockingProxy()->IsBSTGPSviaVME())
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", "gpsfromvme").set("checked", "checked")
+            << GREEN << " GPS/BST through VME" << NOCOL << endl;
+
+      }
+      else
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", "gpsfromvme") << " GPS/BST through VME" << endl;
+      }
+      xoh << " (every " << boardLockingProxy()->GetBSTGPSInterval() << " sec)" << endl;
+    }
+
+    // Monitoring:
+    xoh << "<br>" << BOLD<< "Monitoring/Sampling:" << NOBOLD;
+    xoh << "<br>" << endl;
+    if (boardLockingProxy()->IsMonitoringEnabled())
+    {
+      xoh << cgicc::input().set("type", "checkbox").set("name", "domonitoring").set("checked", "checked")
+          << GREEN << " Enable" << NOCOL << endl;
+    }
+    else
+    {
+      xoh << cgicc::input().set("type", "checkbox").set("name", "domonitoring") << " Enable" << endl;
+    }
+
+    xoh << " (Interval: " << endl;
+    char dum[20];
+    sprintf(dum, "%.0f", boardLockingProxy()->GetMonitoringInterval());
+    xoh << cgicc::input().set("type", "text").set("name", "monitoringintv").set("size", "2").set("value", dum)
+        << " sec)" << endl;
+
+    if (!boardLockingProxy()->DefaultFIFODumpEnabled())
+    {
+      xoh << "<br>" << endl;
+      if (boardLockingProxy()->DumpEventFIFOToFile())
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", "dofifodump").set("checked", "checked") << endl;
+
+      }
+      else
+      {
+        xoh << cgicc::input().set("type", "checkbox").set("name", "dofifodump") << endl;
+      }
+      xoh << " ASCII file for FIFO dump: " << endl;
+      xoh
+          << cgicc::input().set("type", "text").set("name", "fifodumpfile").set("size", "25").set("value",
+              boardLockingProxy()->EventFIFOToFilePath().c_str()) << endl;
+    }
+    else
+    {
+      xoh << "<br>" << endl;
+      xoh << "Automatic FIFO dump enabled (to " << boardLockingProxy()->FIFODumpPrefix() << "*)" << endl;
+    }
+  }
+
+  tab.Close();
+  // End of fieldset.
+  xoh << cgicc::fieldset() << endl;
+
+  xoh
+      << cgicc::input()
+      .set("type", "submit")
+      .set("name", "submit")
+      .set("value", "Apply");
+
+  xoh << cgicc::form() << endl;
+
+  // Trigger rules and hardware delays.
+  string myurl = "/";
+  myurl += getApplicationDescriptor()->getURN();
+  myurl += "/TriggerRules";
+
+  xoh
+      << cgicc::form().set("method", "post").set("action", myurl).set("enctype", "multipart/form-data") << endl
+      << cgicc::fieldset() << endl
+      << cgicc::legend("Trigger Rules & HW Trigger Delays") << endl;
+
+  HTMLTable trigtab(xoh, 1, 2, 0, "", "", 100);
+  trigtab.NewRow();
+  // Trigger Rules
+  trigtab.NewCell();
+  for (size_t i = 0; i < boardLockingProxy()->TriggerRuleSize(); ++i)
+  {
+    if (i > 0)
+      xoh << "<br> ";
+
+    xoh
+        << "No more than " << (i + boardLockingProxy()->FirstTriggerRule()) << " triggers in "
+        << cgicc::input()
+        .set("type", "text")
+        .set("name", (string("trigrule") + UnsignedLong2String(i + boardLockingProxy()->FirstTriggerRule())).c_str())
+        .set("size", "6")
+        .set("value", UnsignedLong2String(boardLockingProxy()->GetTriggerRule(i + boardLockingProxy()->FirstTriggerRule())).c_str()) << endl
+        << " consecutive BXs" << endl;
+  }
+
+  // HW Delays
+  trigtab.NewCell();
+  vector<float> delays = boardLockingProxy()->GetHWInputDelays();
+  if (boardLockingProxy()->ReadFirmwareVersion() >= 0x14)
+  {
+    xoh << UNDERL << "HW Delays" << " (0.0, 0.5,... 31.5 BX):" << NOUNDERL << endl;
+  }
+  else
+  {
+    xoh << UNDERL << "HW Delays" << " (0.0, 0.5,... 15.5 BX):" << NOUNDERL << endl;
+  }
+  for (size_t i = 0; i < boardLockingProxy()->Nextern(); ++i)
+  {
+    if (delays[i] > 0)
+      xoh << RED<< endl;
+    xoh << "<br>Ext. trig. " << i << ") ";
+    char dum1[50], dum2[20], dum3[50];
+    sprintf(dum1, "trigdelay %zu", i);
+    sprintf(dum3, "trigname %zu", i);
+    if ((delays[i] - (1.0 * int(delays[i]))) > 0.1)
+    {
+      sprintf(dum2, "%.1f", delays[i]);
+    }
+    else
+    {
+      sprintf(dum2, "%.0f", delays[i]);
+    }
+    xoh << cgicc::input().set("type", "text").set("name", dum1).set("size", "3").set("value", dum2) << endl;
+    xoh << " BX" << endl;
+    if (i < 2)
+      xoh << " (nim)" << endl;
+    else
+      xoh << " (lvds)" << endl;
+    if (delays[i] > 0)
+      xoh << NOCOL << endl;
+    xoh
+        << cgicc::input().set("type", "text").set("name", dum3).set("size", "15").set("value",
+            boardLockingProxy()->GetTriggerName(i).c_str()) << endl;
+  }
+
+  trigtab.Close();
+  // End fieldset.
+  xoh << cgicc::fieldset() << endl;
+
+  xoh
+      << cgicc::input()
+      .set("type", "submit")
+      .set("name", "submit")
+      .set("value", "Apply");
+
+  xoh << cgicc::form() << endl;
+
+  PrintHTMLFooter(xoh);
+  xoh << "</body>" << "</html>" << endl;
+}
+
+
+void ttc::LTCControl::HTMLPageBGOConfiguration(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageBGOConfiguration");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl;
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << cgicc::title("LTC \"" + name_.toString() + "\"") << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ErrorStatement(xoh);
+
+  {
+    HTMLTable tab0(xoh, 1, 1, 0, "", "left", 100);
+    string cmd_url = "/";
+    cmd_url += getApplicationDescriptor()->getURN();
+    cmd_url += "/SoapCommand";
+    for (size_t i = 1; i < boardLockingProxy()->NChannels(); ++i)
+    { // VME BGO Button
+      if ((i - 1) % 3 == 0)
+        tab0.NewRow();
+      tab0.NewCell();
+
+      xoh
+          << "" << boardLockingProxy()->GetBGOChannel(i)->GetName() << "<br>" << endl
+          << cgicc::form().set("method", "get").set("action", cmd_url).set("enctype", "multipart/form-data") << endl
+          << cgicc::input().set("type", "hidden").set("name", "Command").set("value", "VMEBGO") << endl
+          << cgicc::input().set("type", "hidden").set("name", "Param").set("value", to_string(i)) << endl
+          << cgicc::input().set("type", "submit").set("value", "BGO " + to_string(i))
+          << cgicc::form();
+    }
+    // VME Trigger Button:
+    tab0.NewRow();
+    tab0.NewCell("", 3, 1);
+
+    xoh
+        << "" << RED<<BOLD<< "L1A" <<NOBOLD<< NOCOL << "<br>" << endl
+        << cgicc::form().set("method", "get").set("action", cmd_url).set("enctype", "multipart/form-data") << endl
+        << cgicc::input().set("type", "submit").set("name", "Command").set("value", "VMETrigger")
+        << cgicc::form();
+
+    tab0.Close();
+  }
+
+  { // BX selection
+    xoh << "<br>" << endl;
+
+    string cmd_url = "/";
+    cmd_url += getApplicationDescriptor()->getURN();
+    cmd_url += "/BGOSelectCommand";
+
+    xoh
+        << cgicc::form().set("method", "post").set("action", cmd_url).set("enctype", "multipart/form-data") << endl
+        << cgicc::fieldset() << endl
+        << cgicc::legend("VME-BGO Timing") << endl
+        << "BX at which VME BGOs will be sent: " << endl
+        << cgicc::input().set("type", "text").set("name", "atbx").set("size", "6")
+        .set("value", UnsignedLong2String(boardLockingProxy()->GetVMEBGOBX()).c_str()) << endl
+        << cgicc::fieldset() << endl;
+
+    xoh << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Apply");
+    xoh << cgicc::form() << endl;
+  }
+  PrintHTMLFooter(xoh);
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageSequences(xgi::Input* /*in*/, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageSequences");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl;
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << cgicc::title("LTC \"" + name_.toString() + "\"") << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ErrorStatement(xoh);
+
+  xoh << "Finite State Machine: ";
+  PrintFSMState(xoh);
+  xoh << cgicc::p() << cgicc::p() << endl;
+
+  string SeqTitle = SequenceSelector.GetDefaultTitle();
+
+  const vector<string> newseqvalues = boardLockingProxy()->GetSequenceNames();
+  SequenceSelector.Set(ttc::HTMLFieldElement::DROPDOWNMENU, 0, "sequenceselect", newseqvalues, newseqvalues);
+
+  if (!SequenceSelector.HasValue(SeqTitle))
+  {
+    SeqTitle = newseqvalues.size() ? newseqvalues[0] : "";
+  }
+
+  SequenceSelector.SetDefault(SeqTitle);
+
+  xoh << BIGGER<<BOLD<<"LTC Sequence \""
+  << BLUE<<SeqTitle<<NOCOL <<"\""<<NOBOLD<<NOBIGGER
+  <<"<br>"<<endl;
+  {
+
+    // The First Table with 2 cells:
+    HTMLTable tab(xoh, 0, 0, 0, "", "", 100);
+    tab.NewCell();
+
+    // Select sequence to be displayed.
+    string select_url = "/";
+    select_url += getApplicationDescriptor()->getURN();
+    select_url += "/SequenceSelectCommand";
+    xoh << cgicc::form().set("method", "post").set("action", select_url).set("enctype", "multipart/form-data")
+        << endl;
+    xoh << cgicc::fieldset() << endl; // Begin Fieldset
+    xoh << cgicc::legend(SeqTitle + " Sequence") << endl;
+    xoh << "Select sequence: " << endl;
+    SequenceSelector.Write(xoh);
+    vector<string> seqchce, seqchce_tit;
+    seqchce.push_back("display");
+    seqchce_tit.push_back("display");
+    seqchce.push_back("remove");
+    seqchce_tit.push_back("remove");
+    seqchce.push_back("exec");
+    seqchce_tit.push_back("execute");
+    seqchce.push_back("add");
+    seqchce_tit.push_back("add new:");
+    HTMLFieldElement seqchoice(ttc::HTMLFieldElement::RADIOBUTTON, 0, "seqchoice", seqchce,
+        seqchce_tit /*,"vertical green"*/);
+    seqchoice.Write(xoh);
+
+    xoh
+        << " " << cgicc::input()
+        .set("type", "text")
+        .set("name", "newsequence")
+        .set("size", "10")
+        .set("value", "") << endl
+        << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Go") << endl
+        << cgicc::fieldset() << endl
+        << cgicc::form() << endl;
+
+    tab.Close();
+  }
+
+  ttc::Sequence* myseq = boardLockingProxy()->GetSequence(SeqTitle);
+
+  { // Edit current sequence.
+    string select_url = "/";
+    select_url += getApplicationDescriptor()->getURN();
+    select_url += "/SequenceEditCommand";
+    xoh << cgicc::form().set("method", "post").set("action", select_url).set("enctype", "multipart/form-data")
+        << endl;
+    xoh << cgicc::fieldset() << endl; // Begin Fieldset
+    xoh << cgicc::legend("Edit " + SeqTitle + " Sequence") << endl;
+    // The Edit Table with 2 cells:
+    HTMLTable tab(xoh, 1, 1, 0, "", "", 100);
+    tab.NewCell();
+    // Show the currecnt content of this sequence as list of radio
+    // buttons.
+    vector<string> seqsel = myseq->Get();
+    seqsel.push_back("< Append >");
+    HTMLFieldElement sequence(ttc::HTMLFieldElement::RADIOBUTTON, 0, "sequenceline", seqsel, seqsel,
+        "vertical green");
+    sequence.SetDefault(seqsel[seqsel.size() - 1]);
+    if (seqsel.size() <= 1)
+      xoh << "empty sequence.<br>" << endl;
+    sequence.Write(xoh);
+
+    tab.NewCell(); // 2nd cell
+
+    xoh << "Edit action:<br>" << endl;
+    vector<string> edit, edit_tit;
+    edit.push_back("new");
+    edit_tit.push_back("New line (insert above)");
+    edit.push_back("modify");
+    edit_tit.push_back("Modify line");
+    edit.push_back("delete");
+    edit_tit.push_back("Delete line");
+    HTMLFieldElement edittab(ttc::HTMLFieldElement::RADIOBUTTON, 0, "edit", edit, edit_tit, "vertical");
+    edittab.SetDefault(edit[0]);
+    edittab.Write(xoh);
+    xoh << endl;
+    xoh << "Command: " << endl;
+    vector<string> edit2, edit2_tit;
+    edit2.push_back("Choose");
+    edit2_tit.push_back("< Choose >");
+    edit2.push_back("EnableL1A");
+    edit2_tit.push_back("EnableL1A");
+    edit2.push_back("DisableL1A");
+    edit2_tit.push_back("DisableL1A");
+    edit2.push_back("L1ATicket");
+    edit2_tit.push_back("L1ATicket");
+    edit2.push_back("Cyclic StartPermanent");
+    edit2_tit.push_back("Cyclic StartPermanent");
+    edit2.push_back("Cyclic StopAll");
+    edit2_tit.push_back("Cyclic StopAll");
+    edit2.push_back("Cyclic Start");
+    edit2_tit.push_back("Cyclic Start");
+    edit2.push_back("Cyclic Stop");
+    edit2_tit.push_back("Cyclic Stop");
+    edit2.push_back("Sleep");
+    edit2_tit.push_back("Sleep &lt;value&gt; seconds");
+    edit2.push_back("mSleep");
+    edit2_tit.push_back("mSleep &lt;value&gt; millissec.");
+    edit2.push_back("uSleep");
+    edit2_tit.push_back("uSleep &lt;value&gt; microsec.");
+    edit2.push_back("BGO");
+    edit2_tit.push_back("BGO &lt;value&gt; (&lt;value&gt;=Channel)");
+    edit2.push_back("ResetCounters");
+    edit2_tit.push_back("ResetCounters");
+    edit2.push_back("ResetCounters All");
+    edit2_tit.push_back("ResetCounters All");
+    edit2.push_back("NewRun");
+    edit2_tit.push_back("New Run Number (increment)");
+    edit2.push_back("Saveplots");
+    edit2_tit.push_back("Saveplots (monitoring)");
+    edit2.push_back("Periodic On");
+    edit2_tit.push_back("Periodic On");
+    edit2.push_back("Periodic Off");
+    edit2_tit.push_back("Periodic Off");
+    edit2.push_back("Periodic");
+    edit2_tit.push_back("Periodic interval &lt;value&gt; [sec]");
+
+    edit2.push_back("EnableCyclicBgo");
+    edit2_tit.push_back("Enable cyclic BGO generator");
+    edit2.push_back("EnableCyclicTrigger");
+    edit2_tit.push_back("Enable cyclic trigger generator");
+    edit2.push_back("DisableCyclicBgo");
+    edit2_tit.push_back("Disable cyclic BGO generator");
+    edit2.push_back("DisableCyclicTrigger");
+    edit2_tit.push_back("Disable cyclic trigger generator");
+
+    HTMLFieldElement edittab2(ttc::HTMLFieldElement::DROPDOWNMENU, 0, "edit2", edit2, edit2_tit);
+    edittab2.SetDefault(edit2[0]);
+    edittab2.Write(xoh);
+    xoh << endl << " &lt;value&gt; = ";
+    xoh << cgicc::input().set("type", "text").set("name", "x").set("size", "4").set("value", "") << endl;
+    xoh << "(hex values must start with 0x)" "<br>" << endl;
+    edit2.clear();
+    edit2_tit.clear();
+    edit2.push_back("Choose");
+    edit2_tit.push_back("< Choose >");
+    for (size_t k = 0; k < boardLockingProxy()->NChannels(); ++k)
+    {
+      string val = "BGO ", tit;
+      string dum = boardLockingProxy()->GetBGOChannel(k)->GetName();
+      if (dum[0] == 'C' && dum[1] == 'h' && dum[2] == 'a')
+      {
+        char si[3];
+        sprintf(si, "%zu", k);
+        val += string(si);
+      }
+      else
+      {
+        val += dum;
+      }
+      tit = val;
+      edit2.push_back(val);
+      edit2_tit.push_back(tit);
+    }
+    xoh << "&nbsp;&nbsp; or BGO: ";
+    HTMLFieldElement edittab3(ttc::HTMLFieldElement::DROPDOWNMENU, 0, "edit3", edit2, edit2_tit);
+    edittab3.SetDefault(edit2[0]);
+    edittab3.Write(xoh);
+
+    tab.Close();
+    xoh << "<p>" << endl;
+    // End of fieldset.
+    xoh << cgicc::fieldset() << endl;
+    xoh << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Apply");
+    xoh << cgicc::form() << endl;
+  }
+
+  PrintHTMLFooter(xoh);
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCyclicGenerators(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCyclicGenerators");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl;
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << cgicc::title("LTC \"" + name_.toString() + "\"") << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ErrorStatement(xoh);
+
+  { // Start & Stop Buttons
+    string cmd_url = "/";
+    cmd_url += getApplicationDescriptor()->getURN();
+    cmd_url += "/SoapCommand";
+    xoh << cgicc::form().set("method", "get").set("action", cmd_url).set("enctype", "multipart/form-data") << endl
+        << cgicc::input().set("type", "hidden").set("name", "Command").set("value", "Cyclic") << endl;
+    xoh << "Cyclic generator control: " << endl;
+    // VME Start Button:
+    xoh << cgicc::input().set("type", "submit").set("name", "Param").set("value", "Start") << endl;
+    // VME Stop Button:
+    xoh << cgicc::input().set("type", "submit").set("name", "Param").set("value", "Stop") << endl;
+    xoh << cgicc::input().set("type", "submit").set("name", "Param").set("value", "StartPermanent") << endl;
+    xoh << cgicc::input().set("type", "submit").set("name", "Param").set("value", "StopAll") << endl;
+    xoh << cgicc::form();
+  }
+
+  bool triggersource = boardLockingProxy()->IsCyclicTrigEnabled();
+  bool bgosource = true; //boardLockingProxy()->IsInternalBGOEnabled();
+
+  {
+    xoh << "Finite State Machine: ";
+    PrintFSMState(xoh);
+
+    xoh
+        << " - Source Selection: " << BOLD << "BGO=" << (bgosource ? GREEN : RED)
+        << (bgosource ? "selected" : "unselected") << NOCOL
+        << " Trigger=" << (triggersource ? GREEN : RED)
+        << (triggersource ? "selected" : "unselected") << NOCOL << NOBOLD << endl
+        << cgicc::p() << cgicc::p() << endl;
+  }
+
+  string command_url = "/";
+  command_url += getApplicationDescriptor()->getURN();
+  command_url += "/CyclicConfigCommand";
+
+  xoh << cgicc::form().set("method", "post").set("action", command_url).set("enctype", "multipart/form-data")
+      << endl;
+  xoh << cgicc::fieldset() << endl; // Begin Fieldset
+  xoh << cgicc::legend("Cyclic Generator Configuration") << endl;
+
+  { // The Table
+    HTMLTable maintab(xoh, 0);
+    // First row:
+    maintab.NewRow();
+    maintab.NewCell();
+    xoh << "Name";
+    maintab.NewCell();
+    xoh << "Configuration";
+    maintab.CloseRow();
+
+    vector<string> enable_val, enable_tit;
+    enable_val.push_back("enable");
+    enable_tit.push_back("enable");
+    enable_val.push_back("disable");
+    enable_tit.push_back("disable");
+
+    for (size_t ik = 0; ik < (boardLockingProxy()->NCyclicBGO() + boardLockingProxy()->NCyclicTrigger()); ++ik)
+    {
+      char genc[23];
+      sprintf(genc, "%zu__", ik);
+      const string sgen = string(genc);
+      bool trigger = (ik >= boardLockingProxy()->NCyclicBGO());
+      const size_t i = (!trigger ? ik : ik - boardLockingProxy()->NCyclicBGO());
+      const CyclicTriggerOrBGO* cycl = boardLockingProxy()->GetCyclic(trigger, i);
+      // New row
+      // First cell:
+      maintab.NewRow();
+      maintab.NewCell();
+      const bool enabled = cycl->IsEnabled();
+      xoh << cycl->GetName() << "<br>" << endl;
+      HTMLFieldElement enable(HTMLFieldElement::RADIOBUTTON, 0, sgen + "enable", enable_val, enable_tit,
+          "vertical bold blue");
+      enable.SetDefault((enabled ? 0 : 1));
+      enable.Write(xoh);
+
+      // Second Cell:
+      maintab.NewCell();
+      { // Configuration Cell
+        string bgdcol = "";
+        if (enabled)
+        {
+          if ((trigger && triggersource) || (!trigger && bgosource))
+            bgdcol = "lightgreen";
+          else
+            bgdcol = "green";
+        }
+        else if (!enabled)
+        {
+          if ((trigger && triggersource) || (!trigger && bgosource))
+            bgdcol = "lightgrey";
+          else
+            bgdcol = "grey";
+        }
+        HTMLTable inner(xoh, 1, 3, 0, bgdcol);
+        // first config row:
+        inner.NewRow();
+        // StartBX
+        inner.NewCell();
+        xoh << "StartBX: " << endl;
+        xoh
+            << cgicc::input().set("type", "text").set("name", sgen + "startbx").set("size", "3").set("value",
+                Long2String(cycl->GetStartBX()).c_str()) << endl;
+        // Prescale
+        inner.NewCell();
+        xoh << "Prescale: " << endl;
+        xoh
+            << cgicc::input().set("type", "text").set("name", sgen + "prescale").set("size", "3").set("value",
+                Long2String(cycl->GetPrescale()).c_str()) << endl;
+        // InitPrescale
+        inner.NewCell();
+        xoh << "InitWait [Orb]: " << endl;
+        xoh
+            << cgicc::input().set("type", "text").set("name", sgen + "initprescale").set("size", "3").set("value",
+                Long2String(cycl->GetInitialPrescale()).c_str()) << endl;
+        // B Channels:
+        inner.NewCell();
+        if (!trigger)
+        {
+          HTMLFieldElement BGOList = CurrentBGOList;
+          BGOList.SetName(sgen + "channelno");
+          BGOList.SetDefault(cycl->GetBChannel());
+          BGOList.Write(xoh);
+        }
+
+        // next config line
+        inner.NewRow();
+
+        // Postscale
+        inner.NewCell();
+        //sprintf(dum,"%ld",cycl->GetPostscale());
+        xoh
+            << cgicc::input().set("type", "text").set("name", sgen + "postscale").set("size", "3").set("value",
+                Long2String(cycl->GetPostscale()).c_str()) << endl;
+        xoh << " times" << endl;
+        // Pause
+        inner.NewCell();
+        xoh << "Pause [Orb]: " << endl;
+        //sprintf(dum,"%ld",cycl->GetPause());
+        xoh
+            << cgicc::input().set("type", "text").set("name", sgen + "pause").set("size", "3").set("value",
+                Long2String(cycl->GetPause()).c_str()) << endl;
+        // IsRepetitive();
+        inner.NewCell();
+        if (cycl->IsRepetitive())
+        {
+          xoh << cgicc::input().set("type", "checkbox").set("name", sgen + "repetitive").set("checked", "checked");
+        }
+        else
+        {
+          xoh << cgicc::input().set("type", "checkbox").set("name", sgen + "repetitive");
+        }
+        xoh << "repetitive" << endl;
+        // IsPermanent();
+        inner.NewCell();
+        if (cycl->IsPermanent())
+        {
+          xoh << cgicc::input().set("type", "checkbox").set("name", sgen + "permanent").set("checked", "checked");
+        }
+        else
+        {
+          xoh << cgicc::input().set("type", "checkbox").set("name", sgen + "permanent");
+        }
+        xoh << "permanent" << endl;
+
+        inner.Close();
+      }
+    }
+    // End main table.
+    maintab.Close();
+  }
+
+  // Begin fieldset.
+  xoh << cgicc::fieldset() << endl;
+  xoh << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Apply");
+  xoh << cgicc::form() << endl;
+
+  {
+    string cmd_url = string("/") + getApplicationDescriptor()->getURN() + "/ReadCyclicGeneratorsFromLTC";
+
+    xoh << "<br/>" << endl << "<form method=\"post\" action=\"" << cmd_url << "\">" << endl
+        << "  <input type=\"submit\" name=\"submit\" value=\"Read cyclic generator configuration from hardware\"/>"
+        << endl << "</form>" << endl;
+  }
+  PrintHTMLFooter(xoh);
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageSummary(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageSummary");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl;
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << cgicc::title("LTC \"" + name_.toString() + "\"") << endl;
+
+  if (autoRefresh_)
+  {
+    xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"5; URL=" << lastPage_ << "\">" << endl;
+  }
+
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ErrorStatement(xoh);
+
+  {
+    const string emph = DARKBLUE, deflt = BLACK, alert = RED;
+    // Status summary.
+    const string url = "/" + getApplicationDescriptor()->getURN() + "/";
+    ReadLTCCounters();
+    HTMLTable stab(xoh, 1, 2, 0, "", "", 100);
+    stab.NewCell("top", 1, 1);
+    xoh << "Finite State Machine: ";
+    PrintFSMState(xoh);
+    stab.NewCell("top", 1, 1);
+    xoh << "L1A: " << BOLD << (boardLockingProxy()->IsL1AEnabled() ? GREEN : RED)
+        << (boardLockingProxy()->IsL1AEnabled() ? "Enabled" : "Disabled") << NOCOL<< NOBOLD << endl;
+
+    stab.NewCell("top", 1, 1);
+    { // VME BGO BX
+      xoh << "VME-BGO @ BX " << boardLockingProxy()->GetVMEBGOBX();
+    }
+
+    stab.NewCell("top", 1, 1);
+    { // Cancel counter.
+      string defaultcol = GREEN, alertcol = RED;
+      uint32_t ncan = boardLockingProxy()->CancelledTriggers();
+      bool isok = (ncan == 0);
+      string col = (isok ? defaultcol : alertcol);
+      xoh << "No. cancelled trigs.: " << col << ncan << NOCOL << endl;
+    }
+
+    stab.NewCell("top", 1, 1);
+    { // Clock sync
+      string defaultcol = GREEN, alertcol = RED;
+      if (!boardLockingProxy()->IsQPLLExternal())
+      {
+        xoh << alertcol << "Internal" << NOCOL << " clock (freq. bits: 0x" << hex
+            << boardLockingProxy()->GetQPLLFrequencyBits() << dec << ")" << endl;
+      }
+      else
+      {
+        xoh << "External clock (";
+        if (boardLockingProxy()->IsClockLocked())
+          xoh << defaultcol << "locked";
+        else
+          xoh << alertcol << "not locked!";
+        xoh << NOCOL << ")" << endl;
+      }
+    }
+
+    { // Orbit sync.
+      string defaultcol = GREEN, alertcol = RED;
+      bool isok = boardLockingProxy()->OrbitInSync();
+      string col = (isok ? defaultcol : alertcol);
+      xoh << "<br>Orbit " << col << (isok ? "in" : "out of") << NOCOL << " sync." << endl;
+    }
+
+    // Status & Counters.
+    stab.NewRow();
+    stab.NewCell("top lightyellow");
+    xoh << UNDERL<< "Counters / Status" << NOUNDERL<< endl;
+    xoh << "<br><br>" << endl;
+    xoh << BOLD<< "Run " << dec << (RunNumber_ = boardLockingProxy()->GetRunNumber()) << NOBOLD<< "<br>" << endl;
+    if (OverwriteRunNumber_)
+      xoh << "&amp;&amp;(set externally)<br>" << endl;
+    else
+      xoh << "&nbsp;&nbsp;&nbsp;(set by LTC S/W)<br>" << endl;
+    xoh << BOLD<< "Events: " << TriggerCounter_ << NOBOLD<< "<br>" << endl;
+    if (TriggerCounter_ + BlockedL1ACntr_ > 0)
+    {
+      TotalEfficiency_ = double(TriggerCounter_) / double(TriggerCounter_ + BlockedL1ACntr_);
+    }
+    else
+    {
+      TotalEfficiency_ = 0.0;
+    }
+    xoh << BOLD<< "Tot. efficieny: " << 100.0 * TotalEfficiency_ << NOBOLD<< " %<br>" << endl;
+
+    stab.NewCell();
+    xoh << UNDERL << "Counters" << NOUNDERL << endl;
+    xoh << "<br>" << "Triggers: " << RED<<TriggerCounter_ << NOCOL << endl;
+    xoh << "<br>" << "Evt-ID: " << RED<<EventCounter_ << NOCOL << endl;
+    xoh << "<br>" << "Blocked L1As: " << RED<<BlockedL1ACntr_ << NOCOL << endl;
+    xoh << "<br>" << "Orbit: " << RED<<OrbitCounter_ << NOCOL << endl;
+    int32_t secs = int32_t(double(OrbitCounter_) * 25.0e-9 * 3564.0);
+    int32_t mins = secs / 60;
+    secs = secs % 60;
+    int32_t hours = mins / 60;
+    mins = mins % 60;
+    xoh << "<br>(~ " << hours << ":" << (mins > 9 ? "" : "0") << mins << ":" << (secs > 9 ? "" : "0") << secs << ")"
+        << endl;
+    xoh << "<br>" << "BGO Cntr: " << RED<<StrobeCounter_ << NOCOL << endl;
+    stab.NewCell("", 2, 1);
+    const LTCStatusInfo* S = boardLockingProxy()->GetLTCStatusInfo();
+    {
+      const double dt = S->DeltaT(); //difftime(tnow_, tprevious_);
+      xoh << UNDERL << "L1A rate (after " << dt << " s):" << NOUNDERL << "<br>" << endl;
+      xoh << S->L1ADiff() << " L1As in " << S->OrbitDiff() << " orbs.<br>" << endl;
+      if (S->OrbitDiff() > 0 && dt > 0.0)
+        xoh << RED<< S->L1ARate() << " Hz" << NOCOL
+        << " (" << S->BlockedTriggerRate() << " Hz blocked)" << endl;
+      else
+        xoh << RED<< "nan" << " Hz" << NOCOL
+        << " (" << "nan" << " Hz blocked)" << endl;
+      xoh << "<br>" << endl;
+      if (S->OrbitDiff() > 0)
+      {
+        xoh << S->L1AsPerOrbit() << " L1As/orbit <br>" << endl;
+      }
+      else
+      {
+        xoh << "nan" << " L1As/orbit <br>" << endl;
+      }
+      if (S->L1ADiff() > 0)
+      {
+        xoh << 1.0 / S->L1AsPerOrbit() << " orbits/L1A <br>" << endl;
+      }
+      else
+      {
+        xoh << "nan" << " orbits/L1A" << endl;
+      }
+      if (S->RawDiff() > 0)
+      {
+        xoh << "<br>Current eff.: " << RED<<100.0 * S->Efficiency() << " %" << NOCOL << endl;
+      }
+      else
+      {
+        xoh << "<br>Current eff.: " << RED<< "nan %" << NOCOL << endl;
+      }
+      stab.NewCell();
+      xoh << UNDERL << "BGO. rate (after " << dt << " s):" << NOUNDERL<< "<br>" << endl;
+      xoh << S->BGODiff() << " BGOs in " << S->OrbitDiff() << " orbs.<br>" << endl;
+      if (dt > 0.0)
+      {
+        xoh << RED<<S->BGORate() << " Hz" << NOCOL << "<br>" << endl;
+      }
+      else
+      {
+        xoh << RED<< "nan" << " Hz" << NOCOL << "<br>" << endl;
+      }
+      if (S->OrbitDiff() > 0)
+      {
+        xoh << S->BGOsPerOrbit() << " BGOs/orbit <br>" << endl;
+      }
+      else
+      {
+        xoh << "nan" << " BGOs/orbit <br>" << endl;
+      }
+      if (S->BGODiff() > 0)
+      {
+        xoh << 1.0 / S->BGOsPerOrbit() << " orbits/BGO <br>" << endl;
+      }
+      else
+      {
+        xoh << "nan" << " orbits/BGO" << endl;
+      }
+    }
+
+    // Empty cell.
+    stab.NewCell();
+
+    stab.NewRow();
+    stab.NewCell("lightgreen", 1, 1);
+    xoh << UNDERL<< "S-Link, TTS, and Trigger Inputs" << NOUNDERL << endl;
+
+    stab.NewCell("lightgreen", 2, 1);
+
+    // S-Link status.
+    string slstat;
+    boardLockingProxy()->ReadSLinkStatus(slstat, true);
+
+    xoh
+        << UNDERL << "S-Link:" << NOUNDERL << "<br>"
+        << slstat << (boardLockingProxy()->IsSlinkBackpressureIgnored() ? " (check disabled)" : " (check enabled)")
+        << "<br><br>" << endl;
+
+    // TTS status.
+    {
+      TTSInfo mytts(boardLockingProxy()->ReadTTSStatus());
+
+      xoh << UNDERL << "TTS Status:" << NOUNDERL;
+      for (size_t j = 0; j < mytts.NPartitions(); ++j)
+      {
+        xoh << "<br>";
+        if (j == 0)
+          xoh << "aTTS: ";
+        else
+          xoh << "sTTS #" << j << ": ";
+        bool enabled = boardLockingProxy()->IsTTSEnabled(j);
+        xoh << BOLD << mytts.GetStatus_String(j, true) << NOBOLD;
+        if (enabled)
+        {
+          xoh << " (enabled)" << endl;
+        }
+        else
+        {
+          xoh << " (disabled)" << endl;
+        }
+      }
+    }
+
+    // Trigger inputs.
+    stab.NewCell("lightgreen", 2, 1);
+    // External Triggers
+    vector<float> delays = boardLockingProxy()->GetHWInputDelays();
+    xoh << BOLD<< UNDERL << "External Triggers Enabled:"
+    << NOUNDERL << NOBOLD << endl;
+
+    for (size_t i = 0; i < delays.size(); ++i)
+    {
+      if (boardLockingProxy()->IsExternalTriggerEnabled(i))
+      {
+        xoh << "<br>No. " << i << ") " << (i < 2 ? "(nim)" : "(lvds)");
+        xoh << " \"" << boardLockingProxy()->GetTriggerName(i) << "\"";
+        if (delays[i] > 0)
+        {
+          xoh << " delay: " << delays[i] << " BX";
+        }
+        if (S->GetTriggerComposition()->GetTriggerFraction(i) * 100 >= 0.0)
+        {
+          xoh << " Frac: " << S->GetTriggerComposition()->GetTriggerFraction(i) * 100 << " %";
+        }
+        xoh << endl;
+      }
+    }
+    xoh << "<br><br>" << endl;
+    // RAM triggers.
+    xoh << UNDERL << "RAM Triggers:" << NOUNDERL << "<br>" << endl;
+    if (!boardLockingProxy()->IsRAMTrigEnabled())
+    {
+      xoh << "Disabled.";
+      xoh << endl;
+    }
+    else
+    {
+      if (boardLockingProxy()->GetRAMTriggers()->CanSetInternalTriggerFrequency())
+      {
+        xoh << "Set to " << boardLockingProxy()->GetRAMTriggers()->GetInternalTriggerFrequency() << " Hz";
+      }
+      else
+      {
+        xoh << "trig intervals individually set (c.f. lines containing "
+            << "\"TRIGGER_INTERVAL x\" in config. file)";
+      }
+      if (S->GetTriggerComposition()->GetTriggerFraction(6) * 100 >= 0.0)
+      {
+        xoh << " Frac: " << S->GetTriggerComposition()->GetTriggerFraction(6) * 100 << " %";
+      }
+      xoh << endl;
+    }
+
+    // Trigger ticket.
+    xoh << "<br><br>" << endl;
+    xoh << UNDERL<< "L1A/Trigger Tickets:" << NOUNDERL<< "<br>" << endl;
+    if (boardLockingProxy()->GetFirmwareVersion() < 12)
+    {
+      xoh << "(Requires FW Ver 12+)";
+    }
+    else if (boardLockingProxy()->GetL1ATicket() > 0)
+    {
+      xoh << boardLockingProxy()->GetL1ATicket() << " L1As per L1ATicket: " << endl;
+      if (boardLockingProxy()->ReadTriggerCounter() >= boardLockingProxy()->GetMaxTrigger())
+      {
+        xoh << RED<< BOLD << "Blocked" << NOBOLD << NOCOL << endl;
+      }
+      else
+      {
+        xoh << GREEN << (boardLockingProxy()->GetMaxTrigger() - boardLockingProxy()->ReadTriggerCounter()) << " remaining" << NOCOL << endl;
+      }
+      }
+      else
+      {
+        xoh << "Off";
+      }
+
+    xoh << "<br><br>(L1AEnabled: " << endl;
+    if (boardLockingProxy()->IsL1AEnabled())
+      xoh << GREEN << "Yes";
+    else
+      xoh << RED << "No";
+    xoh << ")" << NOCOL << endl;
+
+    // Cyclic triggers.
+    if (boardLockingProxy()->IsCyclicTrigEnabled())
+    {
+      for (size_t i = 0; i < boardLockingProxy()->NCyclicTrigger(); ++i)
+      {
+        CyclicTriggerOrBGO* cycl = boardLockingProxy()->GetCyclic(true, i);
+        if (!cycl->IsEnabled())
+        {
+          continue;
+        }
+        stab.NewRow();
+        stab.NewCell("lightred");
+        xoh << "<a href=\"" << url << "CyclicGenerators\">";
+        xoh << "Cycl. Trig " << cycl->GetID() << "</a>" << endl;
+        stab.NewCell("", 4, 1);
+        xoh << (cycl->GetStartBX() > 0 ? emph : deflt) << "StartBX: " << cycl->GetStartBX() << NOCOL
+        << "&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->GetPrescale() > 0 ? emph : deflt) << "Prescale: "
+            << cycl->GetPrescale() << NOCOL
+            << "&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->GetInitialPrescale() > 0 ? emph : deflt) << "InitWait: "
+            << cycl->GetInitialPrescale() << NOCOL
+            << " orbits" << "&nbsp;&nbsp;&nbsp;&nbsp;" << endl;
+        xoh << "<br>" << endl;
+        xoh << (cycl->GetPostscale() > 0 ? emph : deflt) << cycl->GetPostscale() << " &times;" << NOCOL
+        << "&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->GetPause() > 0 ? emph : deflt) << "Pause: " << cycl->GetPause()
+            << " orbits" << NOCOL
+            << "&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->IsRepetitive() ? deflt : emph)
+            << (cycl->IsRepetitive() ? "(repetitive)" : "(non-repetitive)") << "&nbsp;&nbsp;&nbsp;&nbsp;"
+            << (cycl->IsPermanent() ? alert : deflt) << (cycl->IsPermanent() ? "(permanent)" : "(non-permanent)")
+            << NOCOL << endl;
+      }
+    }
+
+    // Cyclic BGOs.
+    for (size_t i = 0; i < boardLockingProxy()->NCyclicBGO(); ++i)
+    {
+      CyclicTriggerOrBGO* cycl = boardLockingProxy()->GetCyclic(false, i);
+      if (!cycl->IsEnabled())
+      {
+        continue;
+      }
+      stab.NewRow();
+      stab.NewCell("lightorange");
+      xoh << "<a href=\"" << url << "CyclicGenerators\">";
+      xoh << "Cycl. BGO " << cycl->GetID() << "</a>" << endl;
+      stab.NewCell("", 4, 1);
+      xoh << (cycl->GetStartBX() > 0 ? emph : deflt) << "StartBX: " << cycl->GetStartBX() << NOCOL
+      << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->GetPrescale() > 0 ? emph : deflt) << "Prescale: "
+          << cycl->GetPrescale() << NOCOL
+          << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->GetInitialPrescale() > 0 ? emph : deflt) << "InitWait: "
+          << cycl->GetInitialPrescale() << " orbits" << NOCOL
+          << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" << endl;
+      xoh << "Channel: " << emph << cycl->GetBChannel() << NOCOL << " (\"" << emph
+          << boardLockingProxy()->GetBGOChannel(cycl->GetBChannel())->GetName() << NOCOL << "\")";
+      xoh << "<br>" << endl;
+      xoh << (cycl->GetPostscale() > 0 ? emph : deflt) << cycl->GetPostscale() << " &times;" << NOCOL
+      << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->GetPause() > 0 ? emph : deflt) << "Pause: "
+          << cycl->GetPause() << " orbits" << NOCOL
+          << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" << (cycl->IsRepetitive() ? deflt : emph)
+          << (cycl->IsRepetitive() ? "(repetitive)" : "(non-repetitive)") << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
+          << (cycl->IsPermanent() ? (cycl->GetBChannel() != 1 ? alert : emph) : deflt)
+          << (cycl->IsPermanent() ? "(permanent)" : "(non-permanent)") << NOCOL << endl;
+    }
+
+    // Sequences.
+    stab.NewRow();
+    stab.NewCell("center lightyellow", 5, 1);
+    xoh << BOLD<< "<a href=\"" << url << "Sequences\">" << "State-transition sequences</a>" << NOBOLD << endl;
+    stab.NewRow();
+    for (size_t i = 0; i < 5; ++i)
+    {
+      bool enabled = false;
+      bool disabled = false;
+      stab.NewCell("left", 1, 1);
+      string myseq;
+      if (i == 0)
+      {
+        myseq = "coldReset";
+      }
+      else if (i == 1)
+      {
+        myseq = "configure";
+      }
+      else if (i == 2)
+      {
+        myseq = "enable";
+      }
+      else if (i == 3)
+      {
+        myseq = "suspend";
+      }
+      else if (i == 4)
+      {
+        myseq = "stop";
+      }
+      else
+      {
+        assert(false);
+      }
+
+      Sequence* seq = boardLockingProxy()->GetSequence(myseq);
+
+      xoh << UNDERL<< BOLD << "\"" << seq->GetName() << "\""
+      << NOBOLD << NOUNDERL << endl;
+      for (size_t j = 0; j < seq->N(); ++j)
+      {
+        xoh << "<br>- " << MONO << seq->Get(j) << NOMONO << endl;
+        // Check if this command makes sense in this particular
+        // sequence.
+        if (seq->Get(j) == "DisableL1A")
+        {
+          disabled = true;
+        }
+        if (seq->Get(j) == "EnableL1A")
+        {
+          enabled = true;
+        }
+        if (myseq == "enable")
+        {
+          if (seq->Get(j) == "DisableL1A")
+          {
+            xoh << alert << "<br>&nbsp;&nbsp;disable L1A here?!?" << NOCOL << endl;
+          }
+          else if (seq->Get(j) == "ResetCounters")
+          {
+            xoh << alert << "<br>&nbsp;&nbsp;reset counters here?!?" << NOCOL << endl;
+          }
+        }
+        else if ((myseq == "coldReset") || (myseq == "configure") || (myseq == "suspend") || (myseq == "stop"))
+        {
+          if (seq->Get(j) == "EnableL1A")
+          {
+            xoh << alert << "<br>&nbsp;&nbsp;enable L1A here?!?" << NOCOL << endl;
+          }
+        }
+      }
+      if (myseq == "enable")
+      {
+        if (!enabled)
+        {
+          xoh << alert << "<br>No " << MONO << "EnableL1A" << NOMONO
+          << " here?!?" << NOCOL << endl;
+        }
+      }
+      else if ((myseq == "coldReset") || (myseq == "configure") || (myseq == "suspend") || (myseq == "stop"))
+      {
+        if (!disabled)
+        {
+          xoh << alert << "<br>No " << MONO << "DisableL1A" << NOMONO
+          << " here?!?" << NOCOL << endl;
+        }
+      }
+    }
+
+    // Empty cell.
+    stab.NewCell("center lightyellow", 3, 1);
+
+    // BX gaps.
+    stab.NewRow();
+    stab.NewCell("lightred", 5, 1);
+    xoh << BOLD<< UNDERL << "Imposed BX Gaps:"
+    << NOUNDERL << NOBOLD << endl;
+    vector<size_t> begin, end;
+    boardLockingProxy()->GetBXGaps(begin, end);
+    if (begin.size() == 0)
+    {
+      xoh << "<br> none" << endl;
+    }
+    for (size_t i = 0; ((i < begin.size()) && (i < boardLockingProxy()->Nextern())); ++i)
+    {
+      size_t length = end[i] - begin[i];
+      if (begin[i] > end[i])
+      {
+        length = 3564 - begin[i];
+      }
+      xoh << "<br> " << i + 1 << ") " << "[" << begin[i] << ", " << end[i] << ") (=" << (length) << " clocks)"
+          << endl;
+    }
+
+    // User sequences.
+    stab.NewRow();
+    stab.NewCell("center lightyellow", 5, 1);
+    xoh << BOLD << "User sequences" << NOBOLD << endl;
+    vector<string> const seqNames = boardLockingProxy()->GetSequenceNames();
+    for (vector<string>::const_iterator i = seqNames.begin(); i != seqNames.end(); ++i)
+    {
+      if ((*i != "coldReset") && (*i != "configure") && (*i != "enable") && (*i != "stop") && (*i != "suspend"))
+      {
+        stab.NewRow();
+        stab.NewCell("center lightyellow", 5, 1);
+        Sequence const* const seq = boardLockingProxy()->GetSequence(*i);
+        xoh << UNDERL<< BOLD
+        << "'" << seq->GetName() << "'"
+        << NOBOLD << NOUNDERL
+        << endl;
+        for (size_t j = 0; j < seq->N(); ++j)
+        {
+          xoh << "<br>- " << MONO << seq->Get(j) << NOMONO << endl;
+        }
+      }
+    }
+
+    stab.Close();
+  }
+
+  {  // General LTC info.
+    uint32_t slinkSrcId = boardLockingProxy()->GetSlinkSrcId();
+    uint32_t bTimeCorrection = boardLockingProxy()->GetBTimeCorrection();
+
+    // General info.
+    xoh << "<br>" << BOLD << "General Info" << NOBOLD << "<br>" << endl
+        << "SLink Source ID: " << slinkSrcId << " (0x" << hex << slinkSrcId << dec << ")<br>" << endl
+        << "BTimeCorrection: " << bTimeCorrection << " BX " << "<br>" << endl;
+
+    if (!boardLockingProxy()->GetVMEWritesEnabledStatus())
+    {
+      xoh << RED << "VME writes DISABLED <br/>" << NOCOL << endl;
+    }
+  }
+
+  PrintHTMLFooter(xoh);
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageRegisterAccess(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageRegisterAccess");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << endl;
+  //xoh << cgicc::html().set("lang", "en").set("dir","ltr") << endl;
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << cgicc::title("LTC \"" + name_.toString() + "\"") << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  PrintHTMLHeader(xoh);
+
+  ErrorStatement(xoh);
+
+  xoh << "Finite State Machine: ";
+  PrintFSMState(xoh);
+  xoh << cgicc::p() << cgicc::p() << endl;
+
+  {
+    HTMLTable tab(xoh, 0, 2, 2, "", "", 100);
+    tab.NewCell();
+    // DumpVME commands.
+    string cmd_url = "/";
+    cmd_url += getApplicationDescriptor()->getURN();
+    cmd_url += "/SoapCommand";
+
+    xoh
+        << cgicc::form().set("method", "get").set("action", cmd_url).set("enctype", "multipart/form-data") << endl
+        << cgicc::input().set("type", "submit").set("name", "Command").set("value", "DumpVMEHistory")
+        << cgicc::form()
+        << cgicc::form().set("method", "get").set("action", cmd_url).set("enctype", "multipart/form-data") << endl
+        << cgicc::input().set("type", "submit").set("name", "Command").set("value", "DumpEventFIFO")
+        << cgicc::form();
+
+    tab.Close();
+  }
+
+  string command_url = "/";
+  command_url += getApplicationDescriptor()->getURN();
+  command_url += "/RegisterAccessCommand";
+
+  xoh
+      << cgicc::form().set("method", "post").set("action", command_url).set("enctype", "multipart/form-data") << endl
+      << cgicc::fieldset() << endl
+      << cgicc::legend("Read from or write to LTC Registers") << endl
+      << cgicc::label("Address Name ") << endl;
+
+  VMEAddrList1.Write(xoh);
+
+  xoh
+      << cgicc::label("Index ")
+      << cgicc::input().set("type", "text").set("name", "index").set("size", "4").set("value", "0") << cgicc::p() << endl
+      << "Value " << MONO << "0x" << NOMONO << endl
+      << cgicc::input().set("type", "text").set("name", "Value").set("size", "4").set("value", "0") << cgicc::p() << endl
+      << endl
+      << cgicc::label("Read ")
+      << cgicc::input().set("type", "checkbox").set("name", "readchecked") << endl
+      << cgicc::label("Write ")
+      << cgicc::input().set("type", "checkbox").set("name", "writechecked") << endl
+      << cgicc::fieldset() << endl // End Fieldset
+      << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Apply")
+      << cgicc::form() << endl;
+
+  command_url = "/";
+  command_url += getApplicationDescriptor()->getURN();
+  command_url += "/SetControlRegisterBits";
+
+  xoh
+      << "<a name=\"regtest\"></a><br>" << endl
+      << cgicc::form().set("method", "post").set("action", command_url).set("enctype", "multipart/form-data") << endl
+      << cgicc::fieldset() << endl
+      << cgicc::legend("Debug the Control Register") << endl;
+
+  uint32_t controlReg = boardLockingProxy()->Read(LTCAdd::CONTROL, "");
+
+  xoh
+      << "Control Register: " << MONO << "0x" << hex << controlReg << dec << NOMONO << endl
+      << "<a href=\"/" << getApplicationDescriptor()->getURN() << "/" << lastPage_ << "\">" << "[top of page]<a>" << endl
+      << " BGOs: " << boardLockingProxy()->ReadStrobeCounter()
+      << " EvtID: " << boardLockingProxy()->ReadEventCounter() << endl
+      << "<br>" << endl;
+
+  for (int i = 0; i < 32; ++i)
+  {
+    if (((controlReg >> i) & 1) == 1)
+    {
+      RegList.SetCheck(31 - i, true);
+    }
+    else
+    {
+      RegList.SetCheck(31 - i, false);
+    }
+  }
+  RegList.Write(xoh);
+
+  // End fieldset.
+
+  xoh << cgicc::fieldset() << endl
+      << cgicc::input().set("type", "submit").set("name", "submit").set("value", "Apply")
+      << cgicc::form() << endl
+      << "<br><br>";
+
+  xoh << BOLD << BIGGER
+      << "Snap-Shot of Event FIFO:" << NOBIGGER << NOBOLD << "<br>"
+      << MONO << endl;
+
+  boardLockingProxy()->DumpEventFIFO(&xoh, true);
+
+  xoh << NOMONO "<br>" << endl;
+  PrintHTMLFooter(xoh);
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageRatesPopup(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageRatesPopup");
+
+  XgiOutputHandler xoh(*out);
+
+  const string page_name = "ShowRatesPopup";
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<title>L1A and BGO Rates (LTC)</title>\n";
+
+  // Auto-refresh.
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"1; URL=" << page_name << "\">" << endl;
+  xoh << "</head>\n";
+
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  // Print the data.
+  {
+    const LTCStatusInfo* S = boardLockingProxy()->GetLTCStatusInfo();
+
+    xoh << "<table>\n";
+    xoh << "<tr><td>L1 Rate:</td><td>" << S->L1ARate() << " Hz" << "</td></tr>\n";
+    xoh << "<tr><td>BGO Rate:</td><td>" << S->BGORate() << " Hz" << "</td></tr>\n";
+
+    uint32_t orbit_counter = boardLockingProxy()->ReadOrbitCounter();
+
+    xoh << "<tr><td>Orbit counter:</td><td>" << orbit_counter << "(~ "
+        << GenericTTCModule::OrbitCounterToSecondsString(orbit_counter) << ")" << "</td></tr>\n";
+
+    xoh << "</table>\n";
+  }
+
+  xoh << "</body>\n";
+  xoh << "</html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandConfigureTTS(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandConfigureTTS");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Configure TTS and S-Link") << endl;
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  TTSInfo tts(boardLockingProxy()->ReadTTSStatus());
+
+  for (size_t i = 0; i < tts.NPartitions(); ++i)
+  {
+    stringstream stm;
+    stm << "TTS " << i;
+    bool enable = cgi.queryCheckbox(stm.str());
+    boardLockingProxy()->EnableTTS(i, enable);
+  }
+  // Ignore/act on s-link back-pressure:
+  boardLockingProxy()->IgnoreSlinkBackpressure(!cgi.queryCheckbox("slinkbackpressure"));
+  // "warningpause"
+  uint32_t warnpause;
+  stringstream g(cgi["warningpause"]->getValue());
+  if (g >> warnpause)
+  {
+    boardLockingProxy()->SetWarningInterval(warnpause);
+  }
+  else
+  {
+    XCEPT_RAISE(
+        xcept::Exception,
+        "Don't understand TTS 'Warning' pause interval "
+        "'" + cgi["warningpause"]->getValue() + "'");
+  }
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandNewConfigFile(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandConfigureTTS");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"1; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("New Configuration File") << endl;
+
+  // Create a new Cgicc object containing all the CGI data.
+  cgicc::Cgicc cgi(in);
+
+  std::string fileName = cgi["ConfigurationFile"]->getValue();
+  string file_radiobutton = cgi["inputfiles"]->getValue();
+
+  string newpath;
+
+  if (file_radiobutton == "other" && fileName.size() > 0)
+    newpath = fileName;
+  else
+    newpath = file_radiobutton;
+
+  xoh << "New path to configuration file = " << newpath << "<br>" << endl;
+
+  FILE* fp = fopen(newpath.c_str(), "r");
+  if (!fp)
+  {
+    XCEPT_RAISE(
+        xcept::Exception,
+        "Unable to open file '" + newpath + "' for reading");
+  }
+  else
+  {
+    asciConfigurationFilePath_ = newpath;
+    ReadConfigFromFile_ = true;
+    fclose(fp);
+  }
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandWriteConfigFile(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandWriteConfigFile");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"2; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Write Configuration File") << endl;
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  string fileName = cgi["ConfigurationFile"]->getValue();
+
+  if (fileName.size() > 0)
+  {
+    asciConfigurationFilePath_ = fileName;
+    ReadConfigFromFile_ = true;
+  }
+  else
+  {
+    XCEPT_RAISE(
+        xcept::Exception,
+        "Path to new configuration file is empty");
+  }
+
+  bool overwrite = cgi.queryCheckbox("overwrite");
+  if (!overwrite)
+  {
+    FILE* fp = fopen(asciConfigurationFilePath_.toString().c_str(), "r");
+    if (fp)
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "File '" + asciConfigurationFilePath_.toString() + "' "
+          "already exists, but 'force overwrite' was not checked!");
+    }
+  }
+
+  ofstream oo(asciConfigurationFilePath_.toString().c_str(), ios_base::out);
+  if (!oo)
+  {
+    XCEPT_RAISE(
+        xcept::Exception,
+        "Unable to open file '" + asciConfigurationFilePath_.toString() + "' for writing");
+  }
+
+  boardLockingProxy()->WriteConfiguration(oo, string("(from LTCControl::") + string("WriteConfigurationFile())"));
+  LOG4CPLUS_INFO(logger_, "Configuration written to file '" + asciConfigurationFilePath_.toString() + "'");
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandMainConfig(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandMainConfig");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Main Configuration") << endl;
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  // INPUTS:
+  bool cyclic = false, ram = false;
+  for (size_t i = 0; i < Trigselector.size(); ++i)
+  {
+    stringstream g;
+    g << Trigselector.GetName() << "__" << Trigselector.GetValue(i);
+    bool checked = cgi.queryCheckbox(g.str().c_str());
+    int ii = atoi(Trigselector.GetValue(i).c_str());
+    if (ii < int(boardLockingProxy()->Nextern()))
+    {
+      boardLockingProxy()->EnableExternalTrigger(ii, checked);
+    }
+    else if (ii == int(boardLockingProxy()->Nextern()))
+    {
+      cyclic = checked;
+    }
+    else if (ii == 1 + int(boardLockingProxy()->Nextern()))
+    {
+      ram = checked;
+    }
+    else
+    {
+      stringstream msg;
+      msg << "LTCControl::HTMLPageMainConfigCommand(): " << "Unknown trigsel=" << ii << " extracted from '" << g.str() << "'";
+      LOG4CPLUS_ERROR(logger_, msg.str());
+    }
+  }
+  if (boardLockingProxy()->GetRAMTriggers()->CanSetInternalTriggerFrequency())
+  {
+    double myValue = cgi["TriggerFrequency"]->getDoubleValue(0.0);
+    bool myRandom = cgi.queryCheckbox("TriggerRandom");
+    if ((myValue > 0.0) && (myValue <= 10000000.0))
+    {
+      if ((oldfrequency_ != myValue) || (myRandom != boardLockingProxy()->GetRAMTriggers()->GetInternalTriggerRandom()))
+      {
+        boardLockingProxy()->GetRAMTriggers()->SetInternalTriggerFrequencyLTC(myValue, myRandom);
+        oldfrequency_ = myValue;
+      }
+    }
+    else
+    {
+      LOG4CPLUS_ERROR(
+          logger_,
+          toolbox::toString("LTCControl::HTMLPageMainConfigCommand(): Unable to extract trigger frequency from \"%s\"!", cgi["TriggerFrequency"]->getValue().c_str()));
+    }
+  }
+  boardLockingProxy()->EnableRAMTrig(ram);
+  boardLockingProxy()->StartRAMTrigs();
+  boardLockingProxy()->EnableCyclicTrig(cyclic);
+
+  // QPLL
+  string str_external = cgi["QPLLext"]->getValue();
+  const bool external = (str_external == "YES");
+
+  boardLockingProxy()->SetQPLLExternal(external);
+  if (external)
+  {
+    cgicc::const_form_iterator cgi_it;
+
+    if (CgiUtils::CgiccHasParameter(cgi, "QPLLReset"))
+    {
+      cgi_it = cgi.getElement("QPLLReset");
+      if (cgi_it->getValue() == "YES")
+      {
+        boardLockingProxy()->ResetQPLL(true);
+      }
+      else
+      {
+        boardLockingProxy()->ResetQPLL(false);
+      }
+
+    } // if paramter QPLLReset was present
+
+    if (CgiUtils::CgiccHasParameter(cgi, "QPLLAutoRestart"))
+    {
+      cgi_it = cgi.getElement("QPLLAutoRestart");
+
+      if (cgi_it->getValue() == "ON")
+      {
+        boardLockingProxy()->AutoRestartQPLL(true);
+      }
+      else
+      {
+        boardLockingProxy()->AutoRestartQPLL(false);
+      }
+    } // if parameter QPLLAutoRestart was given
+  } // if external
+
+  if (CgiUtils::CgiccHasParameter(cgi, "freqbits"))
+  {
+    uint32_t freqbits;
+    stringstream g(cgi["freqbits"]->getValue());
+    g >> hex >> freqbits;
+    boardLockingProxy()->SetQPLLFrequencyBits(freqbits, external);
+  }
+
+  // Trigger burst.
+  if (cgi.queryCheckbox("bursten"))
+  {
+    unsigned trigb = 0;
+    if (sscanf(cgi["trigburst"]->getValue().c_str(), "%u", &trigb) != 1)
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "Don't understand trigger burst size '" + cgi["trigburst"]->getValue() + "'");
+    }
+
+    if (trigb == 0)
+      trigb = 10;
+
+    boardLockingProxy()->SetL1ATicket(trigb);
+  }
+  else
+  {
+    boardLockingProxy()->SetL1ATicket(0);
+  }
+
+  // Monitoring.
+  bool domonitoring = cgi.queryCheckbox("domonitoring");
+
+  boardLockingProxy()->EnableMonitoring(domonitoring);
+
+  if (domonitoring)
+  {
+    float monintv = -99.0;
+    if (sscanf(cgi["monitoringintv"]->getValue().c_str(), "%f", &monintv) == 1)
+    {
+      boardLockingProxy()->SetMonitoringInterval(monintv);
+    }
+    else
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "Don't understand monitoring interval '" + cgi["monitoringintv"]->getValue() + "'");
+    }
+  }
+
+  if (!boardLockingProxy()->DefaultFIFODumpEnabled())
+  {
+    bool dofifodump = cgi.queryCheckbox("dofifodump");
+    string fifopth = string("");
+    if (dofifodump)
+    {
+      fifopth = cgi["fifodumpfile"]->getValue();
+    }
+    boardLockingProxy()->SetFilePathForFIFODump(dofifodump, fifopth);
+  }
+
+  // GPS/BST through VME:
+  boardLockingProxy()->EnableBSTGPSviaVME(cgi.queryCheckbox("gpsfromvme"));
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandTriggerRulesDelays(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandTriggerRulesDelays");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Configure Trigger Rules and Hardware Trigger Delays") << endl;
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  // Trigger Rules
+  for (size_t i = 0; i < boardLockingProxy()->TriggerRuleSize(); ++i)
+  {
+    char dum1[50];
+    sprintf(dum1, "trigrule%zu", (i + boardLockingProxy()->FirstTriggerRule()));
+    uint32_t myValue = cgi[dum1]->getIntegerValue(0);
+    boardLockingProxy()->SetTriggerRule((i + boardLockingProxy()->FirstTriggerRule()), myValue);
+  }
+
+  // HW Trigger Delays:
+  vector<float> delays;
+  for (size_t i = 0; i < boardLockingProxy()->Nextern(); ++i)
+  {
+    char dum1[50];
+    sprintf(dum1, "trigdelay %zu", i);
+    delays.push_back(cgi[dum1]->getDoubleValue(0));
+  }
+  boardLockingProxy()->SetHWInputDelays(delays);
+
+  for (size_t i = 0; i < boardLockingProxy()->Nextern(); ++i)
+  {
+    char dum1[50], dum2[100];
+    sprintf(dum1, "trigname %zu", i);
+    boardLockingProxy()->SetTriggerName(i, cgi[dum1]->getValue());
+    sprintf(dum2, "External trigger %zu (%s): %s", i, (i < 2 ? "nim" : "lvds"),
+        boardLockingProxy()->GetTriggerName(i).c_str());
+    Trigselector.SetTitle(i, string(dum2));
+  }
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandVMEBGOTiming(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandVMEBGOTiming");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("VME-BGO timing") << endl;
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  // which BX for following VME BGOs?
+  uint32_t mybx = cgi["atbx"]->getIntegerValue(0);
+
+  if (mybx >= NClocksPerOrbit())
+  {
+    ostringstream err;
+    err << "Argument for BX=" << mybx << "is out of range";
+    XCEPT_RAISE(xcept::Exception, err.str());
+  }
+
+  boardLockingProxy()->SetVMEBX(mybx);
+
+  try {
+    boardLockingProxy()->CheckBXConflicts();
+  }
+  catch(ttc::exception::BXConflictsDetected& e)
+  {
+    XCEPT_RETHROW(xcept::Exception, "BX conflicts detected", e);
+  }
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandSequenceAction(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandSequenceAction");
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  // The Sequence Selection: which sequence?
+  string seqname = cgi["sequenceselect"]->getValue();
+  string seqchoice = cgi["seqchoice"]->getValue();
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Sequence '" + seqname + "', Action '" + seqchoice + "'") << endl;
+
+  if (seqchoice == "remove")
+  {
+    boardLockingProxy()->DeleteSequence(seqname);
+  }
+  else if (seqchoice == "add")
+  {
+    string newname = cgi["newsequence"]->getValue();
+    if (newname.size() > 0)
+    {
+      boardLockingProxy()->AddSequence(newname);
+      SequenceSelector.push_back(newname);
+      SequenceSelector.SetDefault(newname);
+    }
+  }
+  else if (seqchoice == "exec")
+  {
+    SequenceSelector.SetDefault(seqname);
+    boardLockingProxy()->ExecuteSequence(seqname);
+  }
+  else if (seqchoice == "display")
+  {
+    SequenceSelector.SetDefault(seqname);
+  }
+  else {
+    XCEPT_RAISE(xcept::Exception, "Invalid sequence action '" + seqchoice + "'");
+  }
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandEditSequence(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandEditSequence");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Edit sequence") << endl;
+
+  // Create a new Cgicc object containing all the CGI data.
+  cgicc::Cgicc cgi(in);
+
+  // Which sequence line (or eppend)?
+  string line = cgi["sequenceline"]->getValue();
+
+  // Which action to take?
+  string edit = cgi["edit"]->getValue();
+
+  // Which action to take?
+  string command = cgi["edit2"]->getValue();
+  string command2 = cgi["edit3"]->getValue();
+
+  // Which action to take?
+  string xstring = cgi["x"]->getValue();
+  int32_t x = -99;
+
+  if (!String2Long(xstring, x))
+    x = -99;
+
+  const string SeqTitle = SequenceSelector.GetDefaultTitle();
+
+  Sequence* myseq = boardLockingProxy()->GetSequence(SeqTitle);
+
+  //----------------------------------------
+  // Delete a line from a sequence.
+  //----------------------------------------
+  if (edit == "delete")
+  {
+    if (line == "< Append >")
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "To delete, you have to choose a line other than '< Append >'");
+    }
+    else
+    {
+      int index = myseq->GetIndex(line);
+      if (index < 0)
+      {
+        XCEPT_RAISE(
+            xcept::Exception,
+            "Unable to find line '" + line + "' in sequence '" + SeqTitle + "'");
+      }
+      myseq->Delete(size_t(index));
+    }
+  }
+
+  //----------------------------------------
+  // Replace (modify) or create a new line in a sequence.
+  //----------------------------------------
+  else if (edit == "modify" || edit == "new")
+  {
+    if (command == "Choose" && command2 == "Choose")
+    {
+      XCEPT_RAISE(
+          xcept::Exception,
+          "To '" + edit + "' you have to select a command other than '" + command + "'");
+    }
+
+    string newline = command;
+    if (command == "Choose")
+    {
+      newline = command2;
+    }
+    else
+    {
+      // Commands which have a parameter.
+      if (command == "Sleep" ||
+          command == "mSleep" ||
+          command == "uSleep" ||
+          command == "BGO" ||
+          command == "Periodic" ||
+          command == "Monitoring" ||
+          command == "EnableCyclicBgo" ||
+          command == "DisableCyclicBgo" ||
+          command == "EnableCyclicTrigger" ||
+          command == "DisableCyclicTrigger")
+      {
+        bool is_good = true;
+
+        if (x == -99)
+          is_good = false;
+
+        if (command == "Sleep" && x < 0)
+          is_good = false;
+
+        if (command == "BGO" && (x < 0 || x > int(boardLockingProxy()->NChannels())))
+          is_good = false;
+
+        if (command == "EnableCyclicBgo" || command == "DisableCyclicBgo")
+        {
+          if (x < 0)
+            is_good = false;
+
+          if (size_t(x) >= boardLockingProxy()->NCyclicBGO())
+            is_good = false;
+        }
+
+        if (command == "EnableCyclicTrigger" || command == "DisableCyclicTrigger")
+        {
+          if (x < 0)
+            is_good = false;
+
+          if (size_t(x) >= boardLockingProxy()->NCyclicTrigger())
+            is_good = false;
+        }
+
+        if (!is_good)
+        {
+          XCEPT_RAISE(
+              xcept::Exception,
+              "Invalid value '" + xstring + "' for command " + command + "'");
+        }
+
+        // Append parameter to the command.
+        newline = newline + " " + xstring;
+      }
+    }
+
+    if (line == "< Append >")
+    {
+      myseq->PushBack(newline);
+    }
+    else
+    {
+      int index = myseq->GetIndex(line);
+      if (index < 0)
+      {
+        XCEPT_RAISE(
+            xcept::Exception,
+            "Unable to find line '" + line + "' in sequence '" + SeqTitle + "'");
+      }
+
+      if (edit == "new")
+      {
+        myseq->Insert((size_t) index, newline);
+      }
+      else if (edit == "modify")
+      {
+        myseq->Set((size_t) index, newline);
+      }
+      else
+      {
+        XCEPT_RAISE(
+            xcept::Exception,
+            "Unknown action '" + edit + "'");
+      }
+    }
+  } // Modify a line or add a new line.
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandConfigureCyclicGenerator(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandConfigureCyclicGenerator");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Cyclic Generator Configuration") << endl;
+
+  // Create a new Cgicc object containing all the CGI data.
+  cgicc::Cgicc cgi(in);
+
+  // Loop over all cyclic generators.
+  for (size_t ik = 0; ik < (boardLockingProxy()->NCyclicBGO() + boardLockingProxy()->NCyclicTrigger()); ++ik)
+  {
+    char genc[23];
+    sprintf(genc, "%zu__", ik);
+    const string sgen = string(genc);
+    bool trigger = (ik >= boardLockingProxy()->NCyclicBGO());
+    const size_t i = (!trigger ? ik : ik - boardLockingProxy()->NCyclicBGO());
+    CyclicTriggerOrBGO* cycl = boardLockingProxy()->GetCyclic(trigger, i);
+
+    // start-BX
+    uint32_t val = cgi[(sgen + "startbx").c_str()]->getIntegerValue(0);
+    cycl->SetStartBX(val);
+    // prescale
+    val = cgi[(sgen + "prescale").c_str()]->getIntegerValue(0);
+    cycl->SetPrescale(val);
+    // initprescale
+    val = cgi[(sgen + "initprescale").c_str()]->getIntegerValue(0);
+    cycl->SetInitialPrescale(val);
+    // Postscale
+    val = cgi[(sgen + "postscale").c_str()]->getIntegerValue(0);
+    cycl->SetPostscale(val);
+    // Pause
+    val = cgi[(sgen + "pause").c_str()]->getIntegerValue(0);
+    cycl->SetPause(val);
+    // Select the B-Channel:
+    if (!trigger)
+    {
+      string channel = cgi[(sgen + "channelno").c_str()]->getValue();
+      val = cgi[(sgen + "channelno").c_str()]->getIntegerValue();
+      cycl->SetBChannel(val);
+    }
+    // repetitive
+    bool boolval = cgi.queryCheckbox((sgen + "repetitive").c_str());
+    cycl->SetRepetitive(boolval);
+    // repetitive
+    boolval = cgi.queryCheckbox((sgen + "permanent").c_str());
+    cycl->SetPermanent(boolval);
+    // enable
+    cgicc::const_form_iterator EnableRadio = cgi.getElement((sgen + "enable").c_str());
+    cycl->SetEnable((EnableRadio->getValue() == "enable"));
+
+    boardLockingProxy()->WriteCyclicGeneratorToLTC(trigger, i);
+  }
+
+  try {
+    boardLockingProxy()->CheckBXConflicts();
+  }
+  catch(ttc::exception::BXConflictsDetected& e)
+  {
+    XCEPT_RETHROW(xcept::Exception, "BX conflicts detected", e);
+  }
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandReadCyclicGeneratorConfig(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandReadCyclicGeneratorConfig");
+
+  XgiOutputHandler xoh(*out);
+
+  boardLockingProxy()->ReadAllCyclicGeneratorsFromLTC();
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Read Cyclic Generator Configuration from Hardware") << endl;
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageCommandRegisterAccess(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageCommandRegisterAccess");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+//  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+//  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Read/Write VME Register - Results:") << endl;
+
+  // Create a new Cgicc object containing all the CGI data
+  cgicc::Cgicc cgi(in);
+
+  const string parName = cgi["Addresses"]->getValue();
+
+  if (parName != "none")
+  {
+    bool read = cgi.queryCheckbox("readchecked");
+    bool write = cgi.queryCheckbox("writechecked");
+
+    const uint32_t index = cgi["index"]->getIntegerValue(0);
+
+    uint32_t myValue;
+    stringstream g(cgi["Value"]->getValue());
+    g >> hex >> myValue;
+
+    if (read || write)
+      xoh << "<ul>" << endl;
+
+    if (read)
+    {
+      xoh << "<li>" << endl;
+      xoh << "Reading from VME address with name '" << MONO<<parName << NOMONO<< "', index=" << dec << index
+          << ": <br>" << endl;
+      uint32_t output = boardLockingProxy()->Read(parName, index);
+      xoh << MONO<<BLUE<< "0x" <<hex<<output<<dec<< " = " <<output
+      << NOCOL <<NOMONO<< endl;
+      if (write)
+      {
+        xoh << BLUE << " (before)." << NOCOL << endl;
+      }
+      xoh << "</li>" << endl;
+    }
+
+    if (write)
+    {
+      xoh << "<li>" << endl;
+      xoh << "Writing 0x" << hex << myValue << dec << " = " << myValue << " to VME address with name '"
+          << MONO<<parName << NOMONO
+          << "', index=" << dec << index << endl;
+      boardLockingProxy()->Write(parName, index, myValue);
+      xoh << "</li>" << endl;
+      if (read)
+      {
+        xoh << "<li>" << endl;
+        xoh << "Reading (again) from VME address with name '" << MONO<<parName << NOMONO
+        << "', index=" << dec << index << ": <br> " << endl;
+        uint32_t output = boardLockingProxy()->Read(parName, index);
+        xoh << MONO<<BLUE<< "0x" <<hex<<output<<dec<< " = " <<output
+        <<NOMONO<< NOCOL << endl
+        << BLUE << " (after)." << NOCOL << endl;
+        xoh << "</li>" << endl;
+      }
+    }
+
+    if (read || write)
+      xoh << "</ul>" << endl;
+  }
+
+  string oldurl = "/" + getApplicationDescriptor()->getURN() + "/";
+  xoh << BOLD<<BIGGER;
+  xoh << "<a href=\"" << oldurl << "RegisterAccess\"> Back to previous page </a>";
+  xoh << NOBIGGER<<NOBOLD<< "<br>" << endl;
+
+  xoh << "</body></html>\n";
+}
+
+
+void ttc::LTCControl::HTMLPageSetControlRegisterBits(xgi::Input* in, xgi::Output* out)
+{
+  LOG4CPLUS_INFO(logger_, "LTCControl::HTMLPageSetControlRegisterBits");
+
+  XgiOutputHandler xoh(*out);
+
+  xoh << "<html>\n";
+  xoh << "<head>\n";
+  xoh << "<meta HTTP-EQUIV=\"Refresh\" CONTENT=\"0; URL=" << lastPage_ << "\">" << endl;
+  xoh << "</head>\n";
+  xoh << "<body bgcolor=\"" << GetBodyBackgroundColour() << "\">" << endl;
+
+  RedirectMessage(&xoh, lastPage_);
+  xoh << cgicc::h1("Set Control Register Bits") << endl;
+
+  cgicc::Cgicc cgi(in);
+
+  uint32_t dum = 0;
+  for (size_t i = 0; i < RegList.size(); ++i)
+  {
+    stringstream g;
+    g << RegList.GetName() << "__" << RegList.GetValue(i);
+    if (cgi.queryCheckbox(g.str().c_str()))
+    {
+      dum |= (1 << (31 - i));
+    }
+  }
+
+  boardLockingProxy()->Write(LTCAdd::CONTROL, dum, "(LTCControl Register)");
+
+  xoh << "</body>" << "</html>" << endl;
+}
+
+
+void ttc::LTCControl::initHTMLFields()
+{
+  if (areHTMLFieldsInited())
+    return;
+
+  {
+    // Trigger selection:
+    vector<string> values, titles;
+    char dum[100];
+
+    for (size_t i = 0; i < boardLockingProxy()->Nextern(); ++i)
+    {
+      sprintf(dum, "%zu", i);
+      values.push_back(dum);
+      sprintf(dum, "External trigger %zu (%s): %s", i, (i < 2 ? "nim" : "lvds"),
+          boardLockingProxy()->GetTriggerName(i).c_str());
+      titles.push_back(dum);
+    }
+    sprintf(dum, "%zu", boardLockingProxy()->Nextern());
+    values.push_back(dum);
+    titles.push_back("Cyclic Trigger Generators");
+    sprintf(dum, "%zu", boardLockingProxy()->Nextern() + 1);
+    values.push_back(dum);
+    titles.push_back("RAM Trigger");
+    Trigselector.Set(HTMLFieldElement::CHECKBOX, 0, "trigselect", values, titles, "vertical green bold");
+  }
+
+  { // BGO selection
+    vector<string> values, titles;
+    values.push_back("0");
+    titles.push_back("Cyclic BGO Generators (should be \"on\")");
+    BGOselector.Set(HTMLFieldElement::CHECKBOX, 0, "bgoselect", values, titles, "vertical green bold");
+  }
+
+  { // The 16 BGO Channels
+    vector<string> values, titles;
+    for (size_t i = 0; i < boardLockingProxy()->NChannels(); ++i)
+    {
+      char si[100];
+      sprintf(si, "%zd", i);
+      values.push_back(si);
+      string name = boardLockingProxy()->GetBGOChannel(i)->GetName();
+      if (name[0] != 'C' || name[1] != 'h' || name[2] != 'a')
+      {
+        name += (string(" (") + string(si) + string(")"));
+      }
+      titles.push_back(name);
+    }
+    CurrentBGOList.Set(HTMLFieldElement::DROPDOWNMENU, 0, "BGOselect", values, titles);
+    CurrentBGOList.SetDefault(0);
+  }
+  { // The Cyclic Generators
+    vector<string> values, titles;
+    int jj = 0;
+    for (size_t i = 0; i < boardLockingProxy()->NCyclicTrigger(); ++i)
+    {
+      titles.push_back(boardLockingProxy()->GetCyclic(true, i)->GetName());
+      char tit[11];
+      sprintf(tit, "%d", jj++);
+      values.push_back(tit);
+    }
+    for (size_t i = 0; i < boardLockingProxy()->NCyclicBGO(); ++i)
+    {
+      titles.push_back(boardLockingProxy()->GetCyclic(false, i)->GetName());
+      char tit[10];
+      sprintf(tit, "%d", jj++);
+      values.push_back(tit);
+    }
+    CurrentCyclicList.Set(HTMLFieldElement::DROPDOWNMENU, 0, "cyclicselect", values, titles);
+    CurrentCyclicList.SetDefault(values[0]);
+  }
+  { // VME registers
+    vector<string> add1, add1_tit;
+    boardLockingProxy()->GetVMEAddresses(add1, add1_tit);
+    add1.insert(add1.begin(), string("none"));
+    add1_tit.insert(add1_tit.begin(), string("Choose parameter"));
+    VMEAddrList1.Set(HTMLFieldElement::DROPDOWNMENU, 0, "Addresses", add1, add1_tit);
+    VMEAddrList1.SetDefault("none");
+  }
+
+  {
+    vector<string> names, titles;
+    for (int i = 31; i >= 0; --i)
+    {
+      stringstream gg, gn;
+      gg << "Bit " << (i < 10 ? " " : "") << i;
+      titles.push_back(gg.str());
+      gn << i;
+      names.push_back(gn.str());
+    }
+    RegList.Set(HTMLFieldElement::CHECKBOX, 0, "singleregister", names, titles, "vertical green bold");
+  }
+
+  {
+    vector<string> values, titles;
+    values.push_back("Short");
+    titles.push_back("Short");
+    values.push_back("Long");
+    titles.push_back("Long");
+    values.push_back("A-Command");
+    titles.push_back("A-Cmnd/L1A");
+    DataTypeSelector.Set(HTMLFieldElement::DROPDOWNMENU, 0, "datatypeselect", values, titles);
+    DataTypeSelector.SetDefault(values[0]);
+  }
+
+  {
+    const vector<string> values = boardLockingProxy()->GetSequenceNames();
+    SequenceSelector.Set(ttc::HTMLFieldElement::DROPDOWNMENU, 0, "sequenceselect", values, values);
+    SequenceSelector.SetDefault(values[0]);
+  }
+
+  setHTMLFieldsInited();
+}
+
+
+void ttc::LTCControl::ErrorStatement(xgi::Output& out)
+{
+  try {
+    boardLockingProxy()->CheckBXConflicts();
+  }
+  catch(ttc::exception::BXConflictsDetected& e)
+  {
+    error_messages.add("ERROR") << "BX conflicts detected: " << string(e.what());
+  }
+
+  if (boardLockingProxy()->IsQPLLExternal() && !boardLockingProxy()->IsClockLocked())
+  {
+    error_messages.add("ERROR") << "LTC Clock NOT locked!";
+  }
+
+  out << "<div id=\"" << ERROR_MESSAGES_DIV << "\">" << endl;
+
+  if (!error_messages.isEmpty())
+  {
+    out << error_messages.asHtml() << endl;
+    error_messages.clear();
+  }
+
+  out << "</div>" << endl;
+}
+
+
+string ttc::LTCControl::GetDefaultSequenceName()
+{
+  return SequenceSelector.GetDefaultTitle();
+}
+
+
+void ttc::LTCControl::ReadLTCCounters()
+{
+  TriggerCounter_ = boardLockingProxy()->ReadTriggerCounter();
+  EventCounter_ = boardLockingProxy()->ReadEventCounter();
+  OrbitCounter_ = boardLockingProxy()->ReadOrbitCounter();
+  StrobeCounter_ = boardLockingProxy()->ReadStrobeCounter();
+  BlockedL1ACntr_ = boardLockingProxy()->ReadBlockedTriggersCounter();
+  BoardStatus_ = boardLockingProxy()->BoardStatus();
+}
+
+
+void ttc::LTCControl::GetFileList()
+{
+  char s[1024];
+  gethostname(s, sizeof s);
+  string machine = s;
+  size_t pos = machine.find_first_of(".");
+  if (pos < machine.size())
+    machine.erase(machine.begin() + pos, machine.end());
+  machine = string(" (on ") + MONO + machine + NOMONO + ")";
+
+  string path = "", suffix = "";
+  vector<string> filelist, filelistvar;
+  if (ReadConfigFromFile_)
+  {
+    path = asciConfigurationFilePath_.toString();
+    filelist.push_back(string(MONO) + path + string(NOMONO) + machine);
+    filelistvar.push_back(path);
+    size_t pos = path.find_last_of("/");
+    if (pos < path.size())
+    {
+      suffix = path;
+      path.erase(path.begin() + pos, path.end());
+      // find the ending
+      suffix.erase(suffix.begin(), suffix.begin() + pos + 1);
+      pos = suffix.find_last_of(".");
+      if (pos == 0)
+        suffix = "";
+      else if (pos < suffix.size())
+        suffix.erase(suffix.begin(), suffix.begin() + pos);
+      else
+      {
+        LOG4CPLUS_ERROR(logger_, "No file ending found in '" + suffix + "'");
+        suffix = "";
+      }
+    }
+  }
+  vector<string> addlist = ttc::filelist(path, "", (suffix = ".dat"));
+  for (size_t i = 0; i < addlist.size(); ++i)
+  {
+    if (filelistvar.size() > 0 && addlist[i] == filelistvar[0])
+      continue;
+    filelist.push_back(string(MONO) + addlist[i] + string(NOMONO) + machine);
+    filelistvar.push_back(addlist[i]);
+  }
+  addlist = ttc::filelist(path, "", (suffix = ".txt"));
+  for (size_t i = 0; i < addlist.size(); ++i)
+  {
+    if (filelistvar.size() > 0 && addlist[i] == filelistvar[0])
+      continue;
+    filelist.push_back(string(MONO) + addlist[i] + string(NOMONO) + machine);
+    filelistvar.push_back(addlist[i]);
+  }
+  filelist.push_back("other" + machine + ":");
+  filelistvar.push_back("other");
+  InputFileList.Set(HTMLFieldElement::RADIOBUTTON, 0, "inputfiles", filelistvar, filelist, "vertical bold blue");
+  InputFileList.SetDefault(filelistvar[0]);
+}
+
+
+void ttc::LTCControl::WriteBinaryRadioButton(
+    ostream& out,
+    const string& radio_group_name,
+    const string& text1,
+    const string& text2,
+    const string& value1,
+    const string& value2,
+    unsigned selected_index,
+    bool disabled)
+{
+  const string *texts[2] = {&text1, &text2};
+  const string *values[2] = {&value1, &value2};
+
+  for (unsigned i = 0; i < 2; ++i)
+  {
+    out << "<input type=\"radio\" name=\"" << radio_group_name << "\" value=\"" << (*values[i]) << "\"";
+    if (i == selected_index)
+      out << " checked=\"checked\"";
+
+    if (disabled)
+      out << " disabled";
+
+    out << "/>";
+
+    if (i == selected_index)
+      out << "<u>";
+    out << (*texts[i]);
+    if (i == selected_index)
+      out << "</u>";
+
+    out << "</input>" << endl;
+  }
+}
diff --git a/ttc/ltc/src/common/LTCControlSoapHandler.cc b/ttc/ltc/src/common/LTCControlSoapHandler.cc
new file mode 100755
index 000000000..9fa0b6b4a
--- /dev/null
+++ b/ttc/ltc/src/common/LTCControlSoapHandler.cc
@@ -0,0 +1,194 @@
+#include "ttc/ltc/LTCControlSoapHandler.hh"
+
+#include "ttc/ltc/LTC.hh"
+#include "ttc/ltc/LTCControl.hh"
+#include "ttc/utils/TTCXDAQBase.hh"
+
+#include "xoap/Method.h"
+#include "xoap/SOAPEnvelope.h"
+#include "xoap/MessageFactory.h"
+#include "xcept/tools.h"
+#include "xdaq/NamespaceURI.h"
+
+
+using namespace std;
+
+
+ttc::LTCControlSoapHandler::LTCControlSoapHandler(LTCControl* _ltc_control)
+:
+    ltc_control(_ltc_control),
+    logger_(
+        log4cplus::Logger::getInstance(ltc_control->getApplicationLogger().getName() + ".LTCControlSoapHandler"))
+{
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "ExecuteSequence", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "ResetCounters", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "VMETrigger", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "VMEBGO", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "L1ATicket", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "Cyclic", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "DumpVMEHistory", XDAQ_NS_URI);
+  xoap::bind(this, &LTCControlSoapHandler::userCommand, "DumpEventFIFO", XDAQ_NS_URI);
+}
+
+
+void ttc::LTCControlSoapHandler::addMethod(toolbox::lang::Method* m, string name)
+{
+  ltc_control->addMethod(m, name);
+}
+
+
+xoap::MessageReference
+ttc::LTCControlSoapHandler::userCommand(xoap::MessageReference msg)
+{
+  string cmd;
+
+  try
+  {
+    string msgStr;
+    msg->writeTo(msgStr);
+    LOG4CPLUS_INFO(
+        logger_,
+        "LTCControlSoapHandler::userCommand: SOAP message received:" << endl
+        << msgStr);
+
+    xoap::SOAPEnvelope envelope = msg->getSOAPPart().getEnvelope();
+    vector<xoap::SOAPElement> elems = envelope.getBody().getChildElements();
+
+    for (size_t i = 0; i < elems.size(); ++i)
+    {
+      xoap::SOAPElement& elem = elems[i];
+
+      // only consider "real" elements,
+      // i.e. ignore, text not embedded in tags, and comments
+      if (elem.getDOMNode()->getNodeType() != DOMNode::ELEMENT_NODE)
+        continue;
+
+      xoap::SOAPName cmdname = elem.getElementName();
+      cmd = cmdname.getLocalName();
+
+      xoap::SOAPName paramname("Param", "xdaq", XDAQ_NS_URI);
+
+      string param;
+      unsigned nparam = 0;
+
+      param = elem.getAttributeValue(paramname);
+      nparam = atoi(param.c_str());
+
+      // Execute a sequence via SOAP.
+
+      if (cmd == "ExecuteSequence")
+      {
+        LOG4CPLUS_INFO(
+            logger_,
+            "LTCControlSoapHandler::userCommand: "
+            "Calling LTC::ExecuteSequence(" << param << ")");
+
+        ltc_control->boardLockingProxy()->ExecuteSequence(param);
+      }
+
+      else if (cmd == "ResetCounters")
+      {
+        LOG4CPLUS_INFO(
+            logger_,
+            "LTCControlSoapHandler::userCommand: "
+            "Calling LTC::ResetCounters(" << nparam << ")");
+
+        ltc_control->boardLockingProxy()->ResetCounters(nparam);
+      }
+
+      else if (cmd == "VMETrigger")
+      {
+        ltc_control->boardLockingProxy()->ExecuteVMETrigger();
+      }
+
+      else if (cmd == "VMEBGO")
+      {
+        if (nparam == 0)
+        {
+          for (size_t i = 1; i < ltc_control->boardLockingProxy()->NChannels(); ++i)
+          {
+            if (param == ltc_control->boardLockingProxy()->GetBGOChannel(i)->GetName())
+            {
+              nparam = i;
+              break;
+            }
+          }
+        }
+        ltc_control->boardLockingProxy()->ExecuteVMEBGO(nparam);
+      }
+
+      else if (cmd == "L1ATicket")
+      {
+        if (nparam != 0)
+        {
+          ltc_control->boardLockingProxy()->SetL1ATicket(nparam);
+        }
+        ltc_control->boardLockingProxy()->SendL1ATicket();
+      }
+
+      else if (cmd == "Cyclic")
+      {
+        if (param == "Start")
+        {
+          ltc_control->boardLockingProxy()->StartCyclicGenerators();
+        }
+        else if (param == "Stop")
+        {
+          ltc_control->boardLockingProxy()->StopCyclicGenerators();
+        }
+        else if (param == "StartPermanent")
+        {
+          ltc_control->boardLockingProxy()->StartPermanentCyclicGenerators();
+        }
+        else if (param == "StopAll")
+        {
+          ltc_control->boardLockingProxy()->StopAllCyclicGenerators();
+        }
+        else
+        {
+          XCEPT_RAISE(
+              xcept::Exception,
+              "LTCControlSoapHandler::userCommand: Cyclic: "
+              "Unknown parameter '" + param + "'");
+        }
+      }
+
+      else if (cmd == "DumpVMEHistory")
+      {
+        ltc_control->boardLockingProxy()->PrintVMEHistory();
+      }
+
+      else if (cmd == "DumpEventFIFO")
+      {
+        ltc_control->boardLockingProxy()->DumpEventFIFO();
+      }
+
+      else
+      {
+        XCEPT_RAISE(
+            xcept::Exception,
+            "LTCControlSoapHandler::userCommand: Unknown command: " + cmd);
+      }
+    }
+
+    return ttc::createSOAPReplyCommand("LTCResponse");
+  }
+  catch (xcept::Exception& e)
+  {
+    XCEPT_DECLARE_NESTED(xcept::Exception, q,
+        string("SOAP callback userCommand for command '" + cmd + "' failed"), e);
+    return ltc_control->failSoapCallback(e);
+  }
+  catch (std::exception& e)
+  {
+    XCEPT_DECLARE(xcept::Exception, q,
+        string("SOAP callback userCommand for command '" + cmd + "' failed with std::exception: " + e.what()));
+    return ltc_control->failSoapCallback(q);
+  }
+  catch (...)
+  {
+    XCEPT_DECLARE(xcept::Exception, q,
+        string("SOAP callback userCommand for command '" + cmd + "' failed with unknown exception"));
+    return ltc_control->failSoapCallback(q);
+  }
+}
diff --git a/ttc/ltc/src/common/LTCEvent.cc b/ttc/ltc/src/common/LTCEvent.cc
new file mode 100644
index 000000000..23e5ee5fc
--- /dev/null
+++ b/ttc/ltc/src/common/LTCEvent.cc
@@ -0,0 +1,816 @@
+#include "ttc/ltc/LTCEvent.hh"
+
+#include "ttc/ltc/LTC.hh"
+#include "ttc/utils/Utils.hh"
+
+#include <stdint.h>
+#include <iostream>
+#include <iomanip>
+#include <sstream>
+#include <fstream>
+
+
+// Number of 32-bit words per event.
+#define NWORDSPEREVENT 8
+
+
+using namespace std;
+
+
+
+// constants in anonymous namespace
+
+namespace
+{
+const string RED = "<span style=\"color: rgb(255, 0, 0);\">";
+const string BLUE = "<span style=\"color: rgb(51, 51, 255);\">";
+const string GREEN = "<span style=\"color: rgb(51, 204, 0);\">";
+const string PURPLE = "<span style=\"color: rgb(102, 0, 204);\">";
+const string ORANGE = "<span style=\"color: rgb(255, 153, 0);\">";
+const string NOCOL = "</span>";
+const string BOLD = "<b>";
+const string NOBOLD = "</b>";
+const string ITALIC = "<i>";
+const string NOITALIC = "</i>";
+const string SMALLER = "<font size=\"-1\">";
+const string NOSMALLER = "</font>";
+const string BIGGER = "<font size=\"+1\">";
+const string NOBIGGER = "</font>";
+const string UNDERL = "<span style=\"text-decoration: underline;\">";
+const string NOUNDERL = "</span>";
+}
+
+
+// class ttc::LTCEvent
+
+ttc::LTCEvent::LTCEvent(size_t BTCorrection, size_t ATCorrection)
+:
+    data(NWORDSPEREVENT), BTCorr(BTCorrection), ATCorr(ATCorrection)
+{}
+
+
+ttc::LTCEvent::LTCEvent(const vector<uint32_t>& Data, size_t BTCorrection, size_t ATCorrection)
+:
+    data(NWORDSPEREVENT), BTCorr(BTCorrection), ATCorr(ATCorrection)
+{
+  Set(Data);
+}
+
+
+uint32_t ttc::LTCEvent::GetStrobeCounter() const
+{
+  return data[5];
+}
+
+
+uint32_t ttc::LTCEvent::GetEventCounter() const
+{
+  return data[4];
+}
+
+
+uint32_t ttc::LTCEvent::GetBunchCounter() const
+{
+  uint32_t corr = ((IsBGO() && !(IsHWTrigger() || IsVMETrigger() || IsRAMTrigger())) ? BTCorr : ATCorr);
+  return MaskOut(data[3], 12, 0) + corr;
+}
+
+
+uint32_t ttc::LTCEvent::GetOrbitCounter() const
+{
+  return (((ttc::MaskOut(data[2], 12, 0)) << 20) | (ttc::MaskOut(data[3], 20, 12)));
+}
+
+
+uint32_t ttc::LTCEvent::GetBlockedCounter() const
+{
+  // Only since firmware version 18+ (0x12+).
+  return ((data[2] >> 12) & 0xffff);
+}
+
+
+size_t ttc::LTCEvent::GetTTSWord() const
+{
+  return data[1];
+}
+
+
+string ttc::LTCEvent::GetTTSStatusString(const size_t idx, const bool htmlcolors) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::GetTTSStatusString(): idx=" << idx << " out of range!" << endl;
+    return string("ERROR in LTCEvent::GetTTSStatusString()");;
+  }
+  size_t stat = GetTTSStatusPattern(idx);
+  string s = "";
+  if (CheckReady(stat))
+  {
+    if (htmlcolors)
+      s += GREEN;
+    s += "Ready         ";
+    if (htmlcolors)
+      s += NOCOL;
+  }
+  else if (CheckDisconnected(stat))
+  {
+    s += "Disconnected  ";
+  }
+  else if (CheckOutOfSync(stat))
+  {
+    if (htmlcolors)
+      s += RED;
+    s += "OutOfSync     ";
+    if (htmlcolors)
+      s += NOCOL;
+  }
+  else if (CheckWarning(stat))
+  {
+    if (htmlcolors)
+      s += RED;
+    s += "Warning       ";
+    if (htmlcolors)
+      s += NOCOL;
+  }
+  else if (CheckBusy(stat))
+  {
+    if (htmlcolors)
+      s += RED;
+    s += "Busy          ";
+    if (htmlcolors)
+      s += NOCOL;
+  }
+  else
+  {
+    if (htmlcolors)
+      s += RED;
+    s += "Unknown (";
+    for (int i = 3; i >= 0; --i)
+    {
+      s += (((stat >> i) & 1) == (i == 3 ? 1 : 0) ? "1" : "0");
+    }
+    s += ")";
+    if (htmlcolors)
+    {
+      s += NOCOL;
+    }
+  }
+  return s;
+}
+
+
+bool ttc::LTCEvent::IsReady(size_t idx) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::IsReady(): idx=" << idx << " out of range!" << endl;
+    return false;
+  }
+  return CheckReady(GetTTSStatusPattern(idx));
+}
+
+
+bool ttc::LTCEvent::IsDisconnected(size_t idx) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::IsDisconnected(): idx=" << idx << " out of range!" << endl;
+    return true;
+  }
+  return CheckDisconnected(GetTTSStatusPattern(idx));
+}
+
+
+bool ttc::LTCEvent::IsOutOfSync(size_t idx) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::IsOutOfSync(): idx=" << idx << " out of range!" << endl;
+    return true;
+  }
+  return CheckOutOfSync(GetTTSStatusPattern(idx));
+}
+
+
+bool ttc::LTCEvent::IsWarning(size_t idx) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::IsWarning(): idx=" << idx << " out of range!" << endl;
+    return true;
+  }
+  return CheckWarning(GetTTSStatusPattern(idx));
+}
+
+
+bool ttc::LTCEvent::IsBusy(size_t idx) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::IsBusy(): idx=" << idx << " out of range!" << endl;
+    return true;
+  }
+  return CheckBusy(GetTTSStatusPattern(idx));
+}
+
+
+bool ttc::LTCEvent::IsRAMTrigger() const
+{
+  return ((data[0] >> 26) & 1);
+}
+
+
+bool ttc::LTCEvent::IsVMETrigger() const
+{
+  return ((data[0] >> 29) & 1);
+}
+
+
+bool ttc::LTCEvent::IsHWTrigger(size_t idx) const
+{
+  const uint32_t trigmask = (data[0] >> 20) & 0x3f;
+  if (idx >= 6)
+  {
+    return (trigmask > 0);
+  }
+  else
+  {
+    return (((trigmask >> idx) & 1) == 1);
+  }
+}
+
+
+bool ttc::LTCEvent::IsCyclicTrigger(size_t idx) const
+{
+  const uint32_t trigmask = data[0] & 0xff;
+  if (idx >= 8)
+  {
+    return (trigmask > 0);
+  }
+  else
+  {
+    return (((trigmask >> idx) & 1) == 1);
+  }
+}
+
+
+bool ttc::LTCEvent::IsBGO() const
+{
+  return ((data[0] >> 16) & 0xf) > 0;
+}
+
+
+void ttc::LTCEvent::Print(ostream& out, bool html) const
+{
+  out << hex;
+  for (int i = 0; i < int(data.size()); ++i)
+  {
+    out << hex << setfill('0') << setw(8) << data[i] << " ";
+  }
+  out << dec;
+  out << endl;
+  out << (html ? "<br>&nbsp;&nbsp;&nbsp;&nbsp;" : "    ");
+  out << (IsOK() ? "OK:  " : "ERR: ") << "O=" << GetOrbitCounter() << " E=" << GetEventCounter() << " Blck'd="
+      << GetBlockedCounter() << " BX=" << GetBunchCounter() << " BCnt=" << GetStrobeCounter() << " GPS=0x" << hex
+      << GetGPSWord1() << " 0x" << GetGPSWord0() << " TTS=0x" << GetTTSWord() << dec;
+  out << endl << (html ? "<br>&nbsp;&nbsp;&nbsp;&nbsp;" : "     ") << "BXMask=" << IsBXMaskOK() << " HW="
+      << IsHWTrigger() << " (";
+  for (int i = 5; i >= 0; --i)
+  {
+    out << (IsHWTrigger(size_t(i)) ? 1 : 0);
+  }
+  out << ") Cycl=" << IsCyclicTrigger() << " (";
+  for (int i = 5; i >= 0; --i)
+  {
+    out << (IsCyclicTrigger(size_t(i)) ? 1 : 0);
+  }
+  out << ") VME=" << IsVMETrigger() << " RAM=" << IsRAMTrigger() << " BGO=" << IsBGO() << " (CH#" << BGOChannel()
+      << ")";
+}
+
+
+size_t ttc::LTCEvent::BGOChannel() const
+{
+  return ((data[0] >> 16) & 0xf);
+}
+
+
+bool ttc::LTCEvent::IsSuppressed() const
+{
+  return ((data[0] >> 27) & 1);
+}
+
+
+bool ttc::LTCEvent::IsBXMaskOK() const
+{
+  return ((data[0] >> 28) & 1);
+}
+
+
+bool ttc::LTCEvent::CheckReady(size_t pattern) const
+{
+  return (pattern == 0xf);
+}
+
+
+bool ttc::LTCEvent::CheckDisconnected(size_t pattern) const
+{
+  return (pattern == 0x8);
+}
+
+
+bool ttc::LTCEvent::CheckOutOfSync(size_t pattern) const
+{
+  return (pattern == 0x5);
+}
+
+
+bool ttc::LTCEvent::CheckWarning(size_t pattern) const
+{
+  return (pattern == 0x6);
+}
+
+
+bool ttc::LTCEvent::CheckBusy(size_t pattern) const
+{
+  return (pattern == 0x3);
+}
+
+
+void ttc::LTCEvent::Set(const vector<uint32_t> &Data)
+{
+  for (size_t i = 0; i < data.size(); ++i)
+  {
+    if (i < Data.size())
+    {
+      data[i] = Data[i];
+    }
+    else
+    {
+      data[i] = 0;
+      cout << "ERROR: LTCEvent::Set(): \"Data\" vector is shorter (" << Data.size() << ") than " << NWordsPerEvent()
+          << "!" << endl;
+    }
+  }
+}
+
+
+vector<uint32_t> ttc::LTCEvent::Get() const
+{
+  return data;
+}
+
+
+void ttc::LTCEvent::Clear()
+{
+  for (size_t i = 0; i < data.size(); ++i)
+  {
+    data[i] = 0;
+  }
+}
+
+
+size_t ttc::LTCEvent::NWordsPerEvent() const
+{
+  return NWORDSPEREVENT;
+}
+
+
+uint32_t ttc::LTCEvent::GetGPSWord0() const
+{
+  return data[7];
+}
+
+
+void ttc::LTCEvent::SetGPSWord0(const uint32_t GPSwd)
+{
+  data[7] = GPSwd;
+}
+
+
+uint32_t ttc::LTCEvent::GetGPSWord1() const
+{
+  return data[6];
+}
+
+
+void ttc::LTCEvent::SetGPSWord1(const uint32_t GPSwd)
+{
+  data[6] = GPSwd;
+}
+
+
+void ttc::LTCEvent::SetGPSWords(const uint32_t GPSwd0, const uint32_t GPSwd1)
+{
+  SetGPSWord0(GPSwd0);
+  SetGPSWord1(GPSwd1);
+}
+
+
+void ttc::LTCEvent::SetStrobeCounter(const uint32_t cntr)
+{
+  data[5] = cntr;
+}
+
+
+void ttc::LTCEvent::SetEventCounter(const uint32_t cntr)
+{
+  data[4] = cntr;
+}
+
+
+void ttc::LTCEvent::SetBunchCounter(const uint32_t BC)
+{
+  ttc::MaskIn(data[3], BC, 12, 0);
+}
+
+
+void ttc::LTCEvent::SetOrbitCounter(const uint32_t orbit)
+{
+  ttc::MaskIn(data[3], orbit & 0xfffff, 20, 12);
+  ttc::MaskIn(data[2], (orbit >> 20) & 0xfff, 12, 0);
+}
+
+
+size_t ttc::LTCEvent::NTTS() const
+{
+  return 7;
+}
+
+
+size_t ttc::LTCEvent::GetTTSStatusPattern(const size_t idx) const
+{
+  if (idx >= 7)
+  {
+    cout << "ERROR: LTCEvent::GetTTSStatusPattern(): idx=" << idx << " out of range!" << endl;
+    return 0;
+  }
+  uint32_t stat = 0;
+  for (size_t i = 0; i < 4; ++i)
+  {
+    stat |= (((data[1] >> (idx + i * 7)) & 1) << i);
+  }
+  return stat;
+}
+
+
+bool ttc::LTCEvent::IsOK() const
+{
+  return (((data[2] >> 28) & 0xf) == 0xc) && // FW v. 0x12+ (18+)
+      (((data[0] >> 8) & 0xff) == 0) && (((data[0] >> 30) & 0x3) == 0) && (GetBunchCounter() < 3565);
+}
+
+
+// class ttc::LTCEventFIFO
+
+ttc::LTCEventFIFO::LTCEventFIFO()
+:
+    ltcptr(0)
+{}
+
+
+ttc::LTCEventFIFO::LTCEventFIFO(const vector<uint32_t>& buf, const LTC& ltc) :
+    ltcptr(&ltc), BTimeCorrection_(ltc.GetBTimeCorrection()), L1AEnabled_(ltc.IsL1AEnabled()), SlinkBackpressureIgnored_(
+        ltc.IsSlinkBackpressureIgnored())
+{
+  for (int i = 0; i < 6; ++i)
+  {
+    ExternalTriggerEnabled_[i] = ltc.IsExternalTriggerEnabled(i);
+    TriggerName_[i] = ltc.GetTriggerName(i);
+  }
+  for (int i = 0; i < 7; ++i)
+  {
+    TTSEnabled_[i] = ltc.IsTTSEnabled(i);
+  }
+  for (size_t i = 0; i < buf.size(); i += NWORDSPEREVENT)
+  {
+    vector<uint32_t> tmp(&buf[i], &buf[i + NWORDSPEREVENT]);
+    data.push_back(LTCEvent(tmp, BTimeCorrection_, 0 /*ATimeCorrection*/));
+  }
+}
+
+
+ttc::LTCEvent&
+ttc::LTCEventFIFO::operator[](size_t i)
+{
+  return data[i];
+}
+
+
+const ttc::LTCEvent&
+ttc::LTCEventFIFO::operator[](size_t i) const
+{
+  return data[i];
+}
+
+
+size_t ttc::LTCEventFIFO::size() const
+{
+  return data.size();
+}
+
+bool ttc::LTCEventFIFO::IsL1AEnabled() const
+{
+  return L1AEnabled_;
+}
+
+
+bool ttc::LTCEventFIFO::IsExternalTriggerEnabled(const size_t i) const
+{
+  if (i >= 6)
+  {
+    // ERROR
+    return false;
+  }
+  return ExternalTriggerEnabled_[i];
+}
+
+
+string ttc::LTCEventFIFO::GetTriggerName(const size_t i) const
+{
+  if (i >= 6)
+  {
+    // ERROR
+    return string("N.N.");
+  }
+  return TriggerName_[i];
+}
+
+
+void ttc::LTCEventFIFO::print(ostream & os, bool html) const
+{
+  if (!html)
+  {
+    os << "*** Monitoring::Print() ***" << endl;
+  }
+  if (BTimeCorrection_ > 0)
+  {
+    os << "(B-time corr: for BGO commands add " << BTimeCorrection_ << " to BX number!)" << (html ? "<br>" : "")
+        << endl;
+  }
+  if (!L1AEnabled_)
+  {
+    os << (html ? RED : "") << "WARNING: L1As are currently disabled! "
+        << "Be aware that this could also be the reason for blocked triggers!" << (html ? NOCOL + "<br>" : "") << endl;
+  }
+  if (data.size() == 0)
+  {
+    os << "FIFO is empty" << (html ? "<br>" : "") << endl;
+  }
+  for (size_t i = 0; i < data.size(); ++i)
+  {
+    // Catch BC0:
+    if (i > 0)
+    {
+      // 2 triggers with a BC0 in between?
+      int bdiff = data[i].GetStrobeCounter() - data[i - 1].GetStrobeCounter() - (data[i - 1].IsBGO() ? 1 : 0);
+      if (bdiff > 0)
+      {
+        os << (html ? PURPLE + "&nbsp;&nbsp;" : "  ") << bdiff << " x BC0 (= B-chnl.no. 1)"
+            << (html ? NOCOL + "<br>" : "") << endl;
+      }
+      uint32_t nb0 = data[i - 1].GetBlockedCounter();
+      uint32_t nb1 = data[i].GetBlockedCounter();
+      int ndiff = 0;
+      if (nb0 != nb1)
+      {
+        if (nb1 >= nb0)
+        {
+          ndiff = nb1 - nb0;
+        }
+        else
+        {
+          ndiff = 1 + nb1 + 0xffff - nb0;
+        }
+      }
+      if (ndiff > 1)
+      {
+        os << (html ? RED + "&nbsp;&nbsp;" : "  ") << ndiff - 1 << " x blocked triggers" << (html ? NOCOL : "")
+            << ", that did not make it in the FIFO" << (html ? "<br>" : "") << endl;
+      }
+    }
+    os << (i < 10 ? "  " : (i < 100) ? " " : "") << i << ") ";
+    data[i].Print(os, html);
+    os << (html ? "<br>" : "") << endl;
+    // Encoding:
+    uint32_t evt = data[i].GetEventCounter(), nextevt = (i + 1 < data.size() ? data[i + 1].GetEventCounter() : ~0);
+    bool newL1A = (evt == nextevt - 1);
+    bool isTTSChange = true;
+    if (data[i].IsBGO())
+    {
+      // Event caused by BGO request.
+      isTTSChange = false;
+      if (html)
+      {
+        os << BLUE;
+      }
+      os << (html ? "&nbsp;&nbsp;&nbsp;&nbsp;" : "     ") << "--> BGO: Channel " << data[i].BGOChannel()
+          << " requested at BX " << ((/* BTimeCorrection_ + */
+          data[i].GetBunchCounter()) % 3564) << endl;
+      if (html)
+      {
+        os << NOCOL << "<br>" << endl;
+      }
+    }
+    if ((data[i].IsHWTrigger() || data[i].IsRAMTrigger() || data[i].IsVMETrigger() || data[i].IsCyclicTrigger()))
+    {
+      // Event caused by a trigger.
+      isTTSChange = false;
+      os << (html ? "&nbsp;&nbsp;&nbsp;&nbsp;" + GREEN : "     ") << "-->" << (html ? NOCOL : "");
+      size_t ntrig = 0;
+      if (html)
+      {
+        os << BOLD << GREEN;
+      }
+      if (data[i].IsVMETrigger())
+      {
+        os << (ntrig++ > 0 ? " +" : "") << " VME";
+      }
+      vector<size_t> disabledHW;
+      vector<size_t> enabledHW;
+      for (size_t k = 0; k < 6; ++k)
+      {
+        if (data[i].IsHWTrigger(k))
+        {
+          bool disabled = !ExternalTriggerEnabled_[k];
+          os << (ntrig++ > 0 ? " +" : "") << (disabled ? RED : "") << " HW" << k << " (" << TriggerName_[k] << ")"
+              << (disabled ? NOCOL : "");
+          if (disabled)
+          {
+            disabledHW.push_back(k);
+          }
+          else
+          {
+            enabledHW.push_back(k);
+          }
+        }
+      }
+      for (size_t k = 0; k < 4; ++k)
+      {
+        if (data[i].IsCyclicTrigger(k))
+        {
+          os << (ntrig++ > 0 ? " +" : "") << " Cyclic" << k;
+        }
+      }
+      if (data[i].IsRAMTrigger())
+      {
+        os << (ntrig++ > 0 ? " +" : "") << " RAM";
+      }
+      os << " TRIGGER" << (ntrig++ > 1 ? "S" : "");
+      if (html)
+      {
+        os << NOCOL << NOBOLD;
+      }
+      os << ": ";
+      if (i + 1 == data.size())
+      {
+        os << "unable to tell whether trigger passed (last FIFO entry)";
+        if (html)
+          os << "<br>" << endl;
+      }
+      else if (newL1A)
+      {
+        os << (html ? GREEN : "") << "passed." << (html ? NOCOL + "<br>" : "") << endl;
+      }
+      else
+      {
+        os << (html ? RED : "") << "blocked by ";
+        vector<size_t> blockedTTS;
+        for (size_t itts = 0; itts < 7; ++itts)
+        {
+          if (TTSEnabled_[itts])
+          {
+            if (data[i].IsWarning(itts) || data[i].IsBusy(itts) || data[i].IsOutOfSync(itts))
+            {
+              blockedTTS.push_back(itts);
+            }
+          }
+        }
+        bool blockedfound = false;
+        if (!blockedfound && !data[i].IsBXMaskOK())
+        {
+          blockedfound = true;
+          os << "BX-Mask" << endl;
+        }
+        if (!blockedfound && disabledHW.size() > 0 && enabledHW.size() == 0 && !data[i].IsRAMTrigger()
+            && !data[i].IsVMETrigger() && !data[i].IsCyclicTrigger())
+        {
+          blockedfound = true;
+          os << "HW trigger(s) being diabled." << endl;
+        }
+        if (!blockedfound && blockedTTS.size() > 0)
+        {
+          blockedfound = true;
+          os << "TTS (";
+          for (size_t j = 0; j < blockedTTS.size(); ++j)
+          {
+            if (j != 0)
+              os << ", ";
+            os << blockedTTS[j] << ":" << data[i].GetTTSStatusString(blockedTTS[j]) << endl;
+          }
+          os << ")" << endl;
+        }
+        if (!blockedfound)
+        {
+          os << "Trigger rules";
+          if (!SlinkBackpressureIgnored_)
+          {
+            os << " or s-link backpressure";
+          }
+          os << endl;
+        }
+        if (html)
+        {
+          os << NOCOL << "<br>";
+        }
+      }
+    }
+    if (isTTSChange && i > 0)
+    {
+      // no L1A, no BGO, so this must be a TTS state change
+      if (html)
+        os << ORANGE;
+      os << (html ? "&nbsp;&nbsp;&nbsp;&nbsp;" : "     ") << "--> TTS State Change? 0x" << hex
+          << data[i - 1].GetTTSWord() << " --> 0x" << data[i].GetTTSWord() << dec << endl;
+      if (html)
+        os << NOCOL << "<br>" << endl;
+
+    }
+  }
+  os << "(FIFO entries are generated by all " << (html ? BLUE : "") << "BGO requests" << (html ? NOCOL : "") << " ("
+      << (html ? PURPLE : "") << "BC0 is ignored" << (html ? NOCOL : "") << "), by " << (html ? ORANGE : "")
+      << "TTS state changes" << (html ? NOCOL : "") << ", and by " << (html ? GREEN : "") << "triggers"
+      << (html ? NOCOL : "") << ")" << (html ? "<br>" : "") << endl;
+
+  if (!html)
+  {
+    os << "*** end ***" << endl;
+  }
+}
+
+
+void ttc::LTCEventFIFO::tofile(const string& path) const
+{
+  ofstream fp(path.c_str(), fstream::app);
+
+  if (!fp)
+    return;
+
+  if (!L1AEnabled_ || data.size() == 0)
+    return;
+
+  for (size_t i = 0; i < data.size() - 1; ++i)
+  {
+    uint32_t evt = data[i].GetEventCounter();
+    uint32_t nextevt = (i + 1 < data.size() ? data[i + 1].GetEventCounter() : ~0);
+    bool newL1A = (evt == nextevt - 1);
+    uint32_t blk = data[i].GetBlockedCounter(), nextblk = (i + 1 < data.size() ? data[i + 1].GetBlockedCounter() : ~0);
+    bool blockedL1A = (blk == nextblk - 1);
+    if (!data[i].IsHWTrigger() && !data[i].IsRAMTrigger())
+    {
+      continue;
+    }
+    fp << setw(5) << i << " " << setw(5) << evt << " " << setw(7) << data[i].GetBunchCounter() << " " << setw(4)
+        << data[i].GetOrbitCounter() << " " << setw(10) << data[i].GetBlockedCounter();
+    fp << (newL1A ? " 1" : " 0") << (blockedL1A ? " 1" : " 0");
+    fp << "   " << (data[i].IsHWTrigger(0) ? "1" : "0") << " " << (data[i].IsHWTrigger(1) ? "1" : "0") << " "
+        << (data[i].IsHWTrigger(2) ? "1" : "0") << " " << (data[i].IsHWTrigger(3) ? "1" : "0") << " "
+        << (data[i].IsHWTrigger(4) ? "1" : "0") << " " << (data[i].IsHWTrigger(5) ? "1" : "0") << "    "
+        << (data[i].IsRAMTrigger() ? "1" : "0") << endl;
+  }
+  fp.close();
+}
+
+
+void ttc::LTCEventFIFO::UpdateGeneralInfo()
+{
+  if (!ltcptr)
+    return;
+  L1AEnabled_ = ltcptr->IsL1AEnabled();
+  SlinkBackpressureIgnored_ = ltcptr->IsSlinkBackpressureIgnored();
+  for (int i = 0; i < 6; ++i)
+  {
+    ExternalTriggerEnabled_[i] = ltcptr->IsExternalTriggerEnabled(i);
+    TriggerName_[i] = ltcptr->GetTriggerName(i);
+  }
+  for (int i = 0; i < 7; ++i)
+  {
+    TTSEnabled_[i] = ltcptr->IsTTSEnabled(i);
+  }
+}
+
+
+// non-member-functions in ttc namespace
+
+ostream& ttc::operator<<(ostream& os, const LTCEvent& e)
+{
+  e.Print(os);
+  return os;
+}
+
+
+ostream& ttc::operator<<(ostream& os, const LTCEventFIFO& e)
+{
+  e.print(os);
+  return os;
+}
diff --git a/ttc/ltc/src/common/LTCStatusInfo.cc b/ttc/ltc/src/common/LTCStatusInfo.cc
new file mode 100644
index 000000000..1bb79156e
--- /dev/null
+++ b/ttc/ltc/src/common/LTCStatusInfo.cc
@@ -0,0 +1,400 @@
+#include "ttc/ltc/LTCStatusInfo.hh"
+
+#include <stdint.h>
+#include <iostream>
+
+
+using namespace std;
+
+
+ttc::LTCStatusInfo::LTCStatusInfo()
+:
+    _tupdate(1, time_t(0)),
+    _evt0(1, 0),
+    _evt1(1, 0),
+    _blocked0(1, 0),
+    _blocked1(1, 0),
+    _cancelled0(1, 0),
+    _cancelled1(1, 0),
+    _bgo0(1, 0),
+    _bgo1(1, 0),
+    _orb0(1, 0),
+    _orb1(1, 0)
+{}
+
+
+void ttc::LTCStatusInfo::Set(
+    uint32_t orbit,
+    uint32_t evtnum,
+    uint32_t blockedL1As,
+    uint32_t nbgos,
+    uint32_t ncancelled)
+{
+  const size_t n = _tupdate.size();
+
+  if (_tupdate.size() > N()
+      || _evt0.size() > n
+      || _evt1.size() > n
+      || _blocked0.size() > n
+      || _blocked1.size() > n
+      || _cancelled0.size() > n
+      || _cancelled1.size() > n
+      || _bgo0.size() > n
+      || _bgo1.size() > n
+      || _orb0.size() > n
+      || _orb1.size() > n)
+  {
+    cout
+        << "ERROR: LTCStatusInfo::Set:"
+        << " _tupdate.size()=" << _tupdate.size()
+        << " _evt0.size()=" << _evt0.size()
+        << " _evt1.size()=" << _evt1.size()
+        << " _blocked0.size()=" << _blocked0.size()
+        << " _blocked1.size()=" << _blocked1.size()
+        << " _cancelled0.size()=" << _cancelled0.size()
+        << " _cancelled1.size()=" << _cancelled1.size()
+        << " _bgo0.size()=" << _bgo0.size()
+        << " _bgo1.size()=" << _bgo1.size()
+        << " _orb0.size()=" << _orb0.size()
+        << " _orb1.size()=" << _orb1.size() << endl;
+  }
+
+  if (n >= N())
+  {
+    // delete the first element of each of the vectors to make space
+    _tupdate.erase(_tupdate.begin(), _tupdate.begin() + 1);
+    _evt0.erase(_evt0.begin(), _evt0.begin() + 1);
+    _evt1.erase(_evt1.begin(), _evt1.begin() + 1);
+    _blocked0.erase(_blocked0.begin(), _blocked0.begin() + 1);
+    _blocked1.erase(_blocked1.begin(), _blocked1.begin() + 1);
+    _cancelled0.erase(_cancelled0.begin(), _cancelled0.begin() + 1);
+    _cancelled1.erase(_cancelled1.begin(), _cancelled1.begin() + 1);
+    _bgo0.erase(_bgo0.begin(), _bgo0.begin() + 1);
+    _bgo1.erase(_bgo1.begin(), _bgo1.begin() + 1);
+    _orb0.erase(_orb0.begin(), _orb0.begin() + 1);
+    _orb1.erase(_orb1.begin(), _orb1.begin() + 1);
+  }
+
+  _tupdate.push_back(time_t());
+  time(&_tupdate[_tupdate.size() - 1]);
+
+  // Orbit:
+  _orb0.push_back(*(_orb1.end() - 1));
+  _orb1.push_back(orbit);
+
+  // Evt Number:
+  _evt0.push_back(*(_evt1.end() - 1));
+  _evt1.push_back(evtnum);
+
+  // Blocked triggers:
+  _blocked0.push_back(*(_blocked1.end() - 1));
+  _blocked1.push_back(blockedL1As);
+
+  // BGOs:
+  _bgo0.push_back(*(_bgo1.end() - 1));
+  _bgo1.push_back(nbgos);
+
+  // Cancelled trigs:
+  _cancelled0.push_back(*(_cancelled1.end() - 1));
+  _cancelled1.push_back(ncancelled);
+
+  if (*(_orb1.end() - 1) <= *(_orb0.end() - 1))
+  {
+    // e.g. after a reset
+
+    size_t m = _orb1.size() - 1;
+    _orb0[m] = _orb1[m];
+    _evt0[m] = _evt1[m];
+    _blocked0[m] = _blocked1[m];
+    _bgo0[m] = _bgo1[m];
+    _cancelled0[m] = _cancelled1[m];
+  }
+}
+
+
+void ttc::LTCStatusInfo::SetTriggerComposition(const TriggerComposition *Composition)
+{
+  _comp = *Composition;
+}
+
+
+const ttc::TriggerComposition*
+ttc::LTCStatusInfo::GetTriggerComposition() const
+{
+  return (TriggerComposition *) &_comp;
+}
+
+
+double ttc::LTCStatusInfo::DeltaT() const
+{
+  const unsigned bunch_crossings_per_orbit = 3564;
+  const double time_between_bunch_crossings = 25.0E-9; // in units of seconds
+
+  const size_t m = _orb1.size() - 1;
+  return (double(_orb1[m] - _orb0[m]) * double(bunch_crossings_per_orbit) * time_between_bunch_crossings);
+}
+
+
+double ttc::LTCStatusInfo::DeltaT_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  return DeltaT_Accum(i0, i1);
+}
+
+
+double ttc::LTCStatusInfo::L1ARate() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double(_evt1[m] - _evt0[m]) / DeltaT());
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::L1ARate_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  const double dt = DeltaT_Accum(i0, i1);
+  if (_orb1[i1] - _orb0[i0] > 0)
+  {
+    return (double(_evt1[i1] - _evt0[i0]) / dt);
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::RawTriggerRate() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double((_evt1[m] + _blocked1[m]) - (_evt0[m] + _blocked0[m])) / DeltaT());
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::RawTriggerRate_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  const double dt = DeltaT_Accum(i0, i1);
+  if (_orb1[i1] - _orb0[i0] > 0)
+  {
+    return (double((_evt1[i1] + _blocked1[i1]) - (_evt0[i0] + _blocked0[i0])) / dt);
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::BlockedTriggerRate() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double(_blocked1[m] - _blocked0[m]) / DeltaT());
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::BlockedTriggerRate_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  const double dt = DeltaT_Accum(i0, i1);
+  if (_orb1[i1] - _orb0[i0] > 0)
+  {
+    return (double(_blocked1[i1] - _blocked0[i0]) / dt);
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::CancelledRate() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double(_cancelled1[m] - _cancelled0[m]) / DeltaT());
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::CancelledRate_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  const double dt = DeltaT_Accum(i0, i1);
+  if (_orb1[i1] - _orb0[i0] > 0)
+  {
+    return (double(_cancelled1[i1] - _cancelled0[i0]) / dt);
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::Efficiency() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0 && (_blocked1[m] - _blocked0[m] + _evt1[m] - _evt0[m]) > 0)
+  {
+    return (double(_evt1[m] - _evt0[m]) / double(_blocked1[m] - _blocked0[m] + _evt1[m] - _evt0[m]));
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::Efficiency_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  DeltaT_Accum(i0, i1);
+  if (_orb1[i1] - _orb0[i0] > 0 && (_blocked1[i1] - _blocked0[i0] + _evt1[i1] - _evt0[i0]) > 0)
+  {
+    return (double(_evt1[i1] - _evt0[i0]) / double(_blocked1[i1] - _blocked0[i0] + _evt1[i1] - _evt0[i0]));
+  }
+  else
+    return 0.0;
+}
+
+
+size_t ttc::LTCStatusInfo::NAccumulations() const
+{
+  return N();
+}
+
+
+double ttc::LTCStatusInfo::BGORate() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double(_bgo1[m] - _bgo0[m]) / DeltaT());
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::BGORate_Accumulated() const
+{
+  size_t i0 = 0, i1 = 0;
+  const double dt = DeltaT_Accum(i0, i1);
+  if (_orb1[i1] - _orb0[i0] > 0)
+  {
+    return (double(_bgo1[i1] - _bgo0[i0]) / dt);
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::L1AsPerOrbit() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double(_evt1[m] - _evt0[m]) / double(_orb1[m] - _orb0[m]));
+  }
+  else
+    return 0.0;
+}
+
+
+double ttc::LTCStatusInfo::BGOsPerOrbit() const
+{
+  const size_t m = _orb1.size() - 1;
+  if (_orb1[m] - _orb0[m] > 0)
+  {
+    return (double(_bgo1[m] - _bgo0[m]) / double(_orb1[m] - _orb0[m]));
+  }
+  else
+    return 0.0;
+}
+
+
+uint32_t ttc::LTCStatusInfo::OrbitDiff() const
+{
+  return (*(_orb1.end() - 1) - (*(_orb0.end() - 1)));
+}
+
+
+uint32_t ttc::LTCStatusInfo::L1ADiff() const
+{
+  return (*(_evt1.end() - 1) - (*(_evt0.end() - 1)));
+}
+
+
+uint32_t ttc::LTCStatusInfo::RawDiff() const
+{
+  return (*(_evt1.end() - 1) - (*(_evt0.end() - 1)) + (*(_blocked1.end() - 1)) - (*(_blocked0.end() - 1)));
+}
+
+
+uint32_t ttc::LTCStatusInfo::BGODiff() const
+{
+  return ((*(_bgo1.end() - 1)) - (*(_bgo0.end() - 1)));
+}
+
+
+void ttc::LTCStatusInfo::Print() const
+{
+  size_t i0 = 0, i1 = 0;
+  DeltaT_Accum(i0, i1);
+
+  cout
+      << "DeltaT_Accum(): i0/1=" << i0 << "/" << i1
+      << " _orb1.size()=" << _orb1.size() << endl;
+
+  for (size_t k = 0; k < _orb1.size(); ++k)
+  {
+    cout
+        << "  _orb=" << _orb0[k] << "/" << _orb1[k]
+        << "  _evt=" << _evt0[k] << "/" << _evt1[k]
+        << "  _blocked=" << _blocked0[k] << "/" << _blocked1[k] << endl;
+  }
+
+  cout
+      << "  --> DT=" << DeltaT_Accumulated()
+      << " Eff=" << Efficiency_Accumulated()
+      << " l1arate=" << L1ARate_Accumulated() << endl;
+}
+
+
+size_t ttc::LTCStatusInfo::N() const
+{
+  return 5;
+}
+
+
+double ttc::LTCStatusInfo::DeltaT_Accum(size_t &i0, size_t &i1) const
+{
+  i1 = _orb1.size() - 1;
+  i0 = i1;
+
+  for (int j = i1; j >= 0; --j)
+  {
+    if (_orb0[j] == 0 || int(_orb1[i1]) <= int(_orb0[j]) || _orb1[j] <= _orb0[j])
+    {
+      break;
+    }
+    i0 = size_t(j);
+  }
+
+  return (double(_orb1[i1] - _orb0[i0]) * 3564.0 * 25.0E-9);
+}
+
+
+time_t ttc::LTCStatusInfo::Time() const
+{
+  return *(_tupdate.end() - 1);
+}
diff --git a/ttc/ltc/src/common/Monitoring.cc b/ttc/ltc/src/common/Monitoring.cc
new file mode 100644
index 000000000..4019d4342
--- /dev/null
+++ b/ttc/ltc/src/common/Monitoring.cc
@@ -0,0 +1,122 @@
+#include "ttc/ltc/Monitoring.hh"
+
+#include "ttc/ltc/LTCStatusInfo.hh"
+
+#include <string>
+#include <sstream>
+
+
+using namespace std;
+
+
+ttc::Monitoring::Monitoring(
+    size_t BTCorrection,
+    size_t ATCorrection,
+    size_t maxbufsize,
+    ostream* outputstream)
+:
+    Status(0),
+    nmax(maxbufsize),
+    out_(outputstream),
+    runno(-1),
+    BTCorr(BTCorrection),
+    ATCorr(ATCorrection)
+{
+  time(&tinit);
+}
+
+
+void ttc::Monitoring::Flush()
+{
+  buf = LTCEventFIFO();
+}
+
+
+size_t ttc::Monitoring::N() const
+{
+  return buf.size();
+}
+
+
+size_t ttc::Monitoring::Nmax() const
+{
+  return nmax;
+}
+
+
+void ttc::Monitoring::SetEventFIFO(const LTCEventFIFO& myevts)
+{
+  buf = myevts;
+}
+
+
+ttc::LTCEventFIFO
+ttc::Monitoring::GetEventFIFO() const
+{
+  return buf;
+}
+
+
+const ttc::TriggerComposition*
+ttc::Monitoring::GetTriggerComposition() const
+{
+  return (TriggerComposition*) &Comp;
+}
+
+
+void ttc::Monitoring::SetRunNumber(const int32_t No)
+{
+  runno = No;
+}
+
+
+double ttc::Monitoring::RunDuration() const
+{
+  time_t t0 = tinit, t1;
+  time(&t1);
+  size_t ienable = 0;
+  for (int i = (MyStates.size() - 1); i >= 0; --i)
+  {
+    if (MyStates.Get(i)->act == ENABLE)
+    {
+      ienable = i;
+      t0 = MyStates.Get(i)->t;
+      break;
+    }
+  }
+  for (size_t i = ienable + 1; i < MyStates.size(); ++i)
+  {
+    if (MyStates.Get(i)->act == STOP)
+    {
+      t1 = MyStates.Get(i)->t;
+      break;
+    }
+  }
+  return difftime(t1, t0);
+}
+
+
+void ttc::Monitoring::SetLTCStatusInfo(LTCStatusInfo *stat)
+{
+  Status = stat;
+}
+
+
+void ttc::Monitoring::NewState(const string& Name)
+{
+  MyStates.push_back(Name);
+}
+
+
+void ttc::Monitoring::Print(ostream& out) const
+{
+  if (BTCorr > 0)
+    out << "(B-time correction: for BGO commands add " << BTCorr << " to the BX number!)" << endl;
+  for (size_t i = 0; i < buf.size(); ++i)
+  {
+    out << (i < 10 ? "  " : (i < 100) ? " " : "") << i << ") ";
+    buf[i].Print(out);
+    out << endl;
+  }
+  out << "*** end ***" << endl;
+}
diff --git a/ttc/ltc/src/common/StateChanges.cc b/ttc/ltc/src/common/StateChanges.cc
new file mode 100644
index 000000000..193846ac9
--- /dev/null
+++ b/ttc/ltc/src/common/StateChanges.cc
@@ -0,0 +1,139 @@
+#include "ttc/ltc/StateChanges.hh"
+
+
+#include <stdint.h>
+#include <sstream>
+#include <iostream>
+
+
+using namespace std;
+
+
+// class ttc::StateChanges
+
+ttc::StateChanges::StateChanges()
+{}
+
+
+void ttc::StateChanges::push_back(const StateEvent& evt)
+{
+  states.push_back(evt);
+}
+
+
+void ttc::StateChanges::push_back(const string& statename)
+{
+  push_back(State(statename));
+}
+
+
+void ttc::StateChanges::push_back(const Action statechange)
+{
+  time_t t0;
+  time(&t0);
+  StateEvent myevt;
+  myevt.act = statechange;
+  myevt.t = t0;
+  push_back(myevt);
+}
+
+
+void ttc::StateChanges::push_back(const Action statechange, const time_t time)
+{
+  StateEvent myevt;
+  myevt.act = statechange;
+  myevt.t = time;
+  push_back(myevt);
+}
+
+
+size_t ttc::StateChanges::size() const
+{
+  return states.size();
+}
+
+
+ttc::StateEvent*
+ttc::StateChanges::Get(const size_t idx)
+{
+  if (idx >= size())
+  {
+    cout << "ERROR: StateChanges::Get(idx=" << idx << "): arg out of range (size=" << size() << "!" << endl;
+    return (StateEvent *) 0;
+  }
+  return &(states[idx]);
+}
+
+
+const ttc::StateEvent*
+ttc::StateChanges::Get(const size_t idx) const
+{
+  if (idx >= size())
+  {
+    cout << "ERROR: StateChanges::Get(idx=" << idx << "): arg out of range (size=" << size() << "!" << endl;
+    return (const StateEvent *) 0;
+  }
+  return (const StateEvent *) &(states[idx]);
+}
+
+
+void ttc::StateChanges::Delete(const size_t idx)
+{
+  if (idx >= size())
+  {
+    cout << "ERROR: StateChanges::Delete(idx=" << idx << "): arg out of range (size=" << size() << "!"
+        << endl;
+    return;
+  }
+  states.erase(states.begin() + idx, states.begin() + idx + 1);
+}
+
+
+// non-member-functions in namespace ttc
+
+ttc::Action ttc::State(const string& Name)
+{
+  if (Name == "coldReset")
+  {
+    return COLDRESET;
+  }
+  else if (Name == "configure")
+  {
+    return CONFIGURE;
+  }
+  else if (Name == "enable")
+  {
+    return ENABLE;
+  }
+  else if (Name == "suspend")
+  {
+    return SUSPEND;
+  }
+  else if (Name == "stop")
+  {
+    return STOP;
+  }
+  else
+  {
+    return UNKNOWN;
+  }
+}
+
+string ttc::State(const Action mystate)
+{
+  switch (mystate)
+  {
+    case COLDRESET:
+      return "coldReset";
+    case CONFIGURE:
+      return "configure";
+    case ENABLE:
+      return "enable";
+    case SUSPEND:
+      return "suspend";
+    case STOP:
+      return "stop";
+    default:
+      return "unkown";
+  }
+}
diff --git a/ttc/ltc/src/common/TriggerComposition.cc b/ttc/ltc/src/common/TriggerComposition.cc
new file mode 100644
index 000000000..9f6c54b27
--- /dev/null
+++ b/ttc/ltc/src/common/TriggerComposition.cc
@@ -0,0 +1,124 @@
+#include "ttc/ltc/TriggerComposition.hh"
+
+
+using namespace std;
+
+
+ttc::TriggerComposition::TriggerComposition() :
+    _n(0), _countall(0), _countall0(0), _counter(_NN, 0), _counter0(_NN, 0)
+{
+}
+
+
+void ttc::TriggerComposition::Clear()
+{
+  for (size_t i = 0; i < N(); ++i)
+  {
+    _counter[i] = _counter0[i] = 0;
+    for (size_t j = 0; j < N(); ++j)
+    {
+      _cnt[i][j] = _cnt0[i][j] = 0;
+    }
+  }
+  _n = _countall = _countall0 = 0;
+}
+
+
+void ttc::TriggerComposition::SetTrigger(bool HW0, bool HW1, bool HW2, bool HW3, bool HW4, bool HW5, bool INT)
+{
+  vector<bool> trig(N(), 0);
+  if (HW0)
+    trig[0] = true;
+  if (HW1)
+    trig[1] = true;
+  if (HW2)
+    trig[2] = true;
+  if (HW3)
+    trig[3] = true;
+  if (HW4)
+    trig[4] = true;
+  if (HW5)
+    trig[5] = true;
+  if (INT)
+    trig[6] = true;
+  SetTrigger(trig);
+}
+
+
+void ttc::TriggerComposition::SetTrigger(const vector<bool> &trig)
+{
+
+  if (_n >= _Nmax)
+  {
+    for (size_t i = 0; i < N(); ++i)
+    {
+      _counter0[i] = _counter[i];
+      _counter[i] = 0;
+      for (size_t j = 0; j < N(); ++j)
+      {
+        _cnt0[i][j] = _cnt[i][j];
+        _cnt[i][j] = 0;
+      }
+    }
+    _countall0 = _countall;
+    _countall = 0;
+    _n = 0;
+  }
+  ++_n;
+  bool istrig = false;
+  for (size_t i = 0; i < trig.size() && i < N(); ++i)
+  {
+    if (trig[i])
+    {
+      ++_counter[i];
+      istrig = true;
+    }
+    for (size_t j = i + 1; j < trig.size() && j < N(); ++j)
+    {
+      ++_cnt[i][j];
+    }
+  }
+  if (istrig)
+    ++_countall;
+}
+
+
+uint32_t ttc::TriggerComposition::GetSum() const
+{
+  return _countall + _countall0;
+}
+
+
+double ttc::TriggerComposition::GetTriggerFraction(size_t itrig, size_t itrig2) const
+{
+  if (itrig >= N())
+  { // ERROR
+    return -1.0;
+  }
+  if (GetSum() == 0)
+    return -0.999999;
+  if (itrig2 == 999 || itrig2 == itrig)
+    return (double(_counter0[itrig] + _counter[itrig]) / double(GetSum()));
+  else
+  {
+    if (itrig2 >= N())
+    { // ERROR
+      return -1.0;
+    }
+    size_t i = (itrig2 > itrig ? itrig : itrig2);
+    size_t j = (itrig2 > itrig ? itrig2 : itrig);
+    return double(_cnt[i][j] + _cnt0[i][j]) / double(GetSum());
+  }
+}
+
+
+void ttc::TriggerComposition::Print(ostream &out) const
+{
+  out << "INFO: TriggerComposition::Print(): Sum = " << GetSum() << " _n=" << _n << " _countall=" << _countall
+      << " _countall0=" << _countall0 << endl;
+  for (size_t i = 1; i < N(); ++i)
+  {
+    out << "  " << i << ") frac=" << GetTriggerFraction(i) * 100 << " %" << " _counter[]=" << _counter[i]
+        << " _counter0[]=" << _counter0[i] << endl;
+  }
+}
diff --git a/ttc/ltc/src/common/version.cc b/ttc/ltc/src/common/version.cc
new file mode 100644
index 000000000..26ba803e6
--- /dev/null
+++ b/ttc/ltc/src/common/version.cc
@@ -0,0 +1,30 @@
+#include "ttc/ltc/version.h"
+
+#include "ttc/utils/version.h"
+#include "config/version.h"
+#include "toolbox/version.h"
+#include "xdata/version.h"
+#include "xgi/version.h"
+
+GETPACKAGEINFO(ttcltc)
+
+void ttcltc::checkPackageDependencies()
+{
+  CHECKDEPENDENCY(ttcutils);
+  CHECKDEPENDENCY(config);
+  CHECKDEPENDENCY(toolbox);
+  CHECKDEPENDENCY(xdata);
+  CHECKDEPENDENCY(xgi);
+}
+
+std::set<std::string, std::less<std::string> > ttcltc::getPackageDependencies()
+{
+  std::set<std::string, std::less<std::string> > dependencies;
+  ADDDEPENDENCY(dependencies, ttcutils);
+  ADDDEPENDENCY(dependencies, config);
+  ADDDEPENDENCY(dependencies, toolbox);
+  ADDDEPENDENCY(dependencies, xdata);
+  ADDDEPENDENCY(dependencies, xgi);
+
+  return dependencies;
+}
diff --git a/ttc/monitoring/Makefile b/ttc/monitoring/Makefile
index eaed98d93..16de04f95 100755
--- a/ttc/monitoring/Makefile
+++ b/ttc/monitoring/Makefile
@@ -2,6 +2,7 @@ BUILD_HOME:=$(shell pwd)/../..
 
 BUILD_SUPPORT=build
 PROJECT_NAME=worksuite
+
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfAutoconf.rules
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfDefs.$(XDAQ_OS)
 include $(BUILD_HOME)/mfDefs.$(PROJECT_NAME)
diff --git a/ttc/ttcci/Makefile b/ttc/ttcci/Makefile
index 4343ad522..04e08158e 100755
--- a/ttc/ttcci/Makefile
+++ b/ttc/ttcci/Makefile
@@ -2,6 +2,7 @@ BUILD_HOME:=$(shell pwd)/../..
 
 BUILD_SUPPORT=build
 PROJECT_NAME=worksuite
+
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfAutoconf.rules
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfDefs.$(XDAQ_OS)
 include $(BUILD_HOME)/mfDefs.$(PROJECT_NAME)
diff --git a/ttc/ttcci/src/common/TTCciControl.cc b/ttc/ttcci/src/common/TTCciControl.cc
index 56da7c90d..69a70de70 100755
--- a/ttc/ttcci/src/common/TTCciControl.cc
+++ b/ttc/ttcci/src/common/TTCciControl.cc
@@ -2136,7 +2136,7 @@ void ttc::TTCciControl::HTMLPageCyclicGenerators(xgi::Input* /*in*/, xgi::Output
 
     for (size_t ik = 0; ik < (boardLockingProxy()->NCyclicBGO() + boardLockingProxy()->NCyclicTrigger()); ++ik)
     {
-      char genc[10];
+      char genc[23];
       sprintf(genc, "%zu__", ik);
       const string sgen = string(genc);
       bool trigger = (ik >= boardLockingProxy()->NCyclicBGO());
@@ -3531,7 +3531,7 @@ void ttc::TTCciControl::HTMLPageCommandConfigureBGO(xgi::Input* in, xgi::Output*
           bch->SetIndividualPostScaleValue(index, postscale_value);
           is_modified = true;
         }
-        catch (boost::bad_lexical_cast e)
+        catch (boost::bad_lexical_cast const& e)
         {
           ostringstream msg;
           msg << __PRETTY_FUNCTION__ << ": Invalid postscale value '" << postscale_value_str << "'";
@@ -3582,7 +3582,7 @@ void ttc::TTCciControl::HTMLPageCommandConfigureBGO(xgi::Input* in, xgi::Output*
           {
             postscale_value = boost::lexical_cast<short>(postscale_value_str);
           }
-          catch (boost::bad_lexical_cast e)
+          catch (boost::bad_lexical_cast const& e)
           {
             ostringstream msg;
             msg << __PRETTY_FUNCTION__ << ": Invalid postscale value '" << postscale_value_str << "'";
@@ -3880,7 +3880,7 @@ void ttc::TTCciControl::HTMLPageCommandConfigureCyclicGenerator(xgi::Input* in,
   // Loop over all cyclic generators.
   for (size_t ik = 0; ik < (boardLockingProxy()->NCyclicBGO() + boardLockingProxy()->NCyclicTrigger()); ++ik)
   {
-    char genc[10];
+    char genc[23];
     sprintf(genc, "%zu__", ik);
     const string sgen = string(genc);
     bool trigger = (ik >= boardLockingProxy()->NCyclicBGO());
diff --git a/ttc/utils/Makefile b/ttc/utils/Makefile
index 1f2e5bc23..73533ecb1 100755
--- a/ttc/utils/Makefile
+++ b/ttc/utils/Makefile
@@ -2,6 +2,7 @@ BUILD_HOME:=$(shell pwd)/../..
 
 BUILD_SUPPORT=build
 PROJECT_NAME=worksuite
+
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfAutoconf.rules
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfDefs.$(XDAQ_OS)
 include $(BUILD_HOME)/mfDefs.$(PROJECT_NAME)
diff --git a/ttc/utils/src/common/TTCXDAQBase.cc b/ttc/utils/src/common/TTCXDAQBase.cc
index 6fa8da2e4..8a91578f4 100755
--- a/ttc/utils/src/common/TTCXDAQBase.cc
+++ b/ttc/utils/src/common/TTCXDAQBase.cc
@@ -1165,23 +1165,19 @@ void ttc::TTCXDAQBase::addFSMButton(
 
 string ttc::TTCXDAQBase::originalException(xcept::Exception& e)
 {
-  vector<xcept::ExceptionInformation>& ve = e.getHistory();
-
-  return ve.front().getProperty("message");
+  return e.begin()->getProperty("message");
 }
 
 
 string ttc::TTCXDAQBase::compactExceptionHistory(xcept::Exception& e)
 {
-  vector<xcept::ExceptionInformation>& ve = e.getHistory();
-
   ostringstream msg;
 
   bool rfirst = true;
 
-  for (vector<xcept::ExceptionInformation>::reverse_iterator
-      rit = ve.rbegin();
-      rit != ve.rend(); ++rit, rfirst = false)
+  for (xcept::Exception::const_reverse_iterator
+         rit = e.rbegin();
+       rit != e.rend(); ++rit, rfirst = false)
   {
     if (!rfirst) msg << endl << " <= ";
     msg << rit->getProperty("message");
diff --git a/tts/atts/include/tts/atts/ATTSCrate.hh b/tts/atts/include/tts/atts/ATTSCrate.hh
index 2dd5fd1ac..058c8919f 100755
--- a/tts/atts/include/tts/atts/ATTSCrate.hh
+++ b/tts/atts/include/tts/atts/ATTSCrate.hh
@@ -37,8 +37,7 @@ namespace tts {
     /// read the address table and determines the PCI-Devices 
     ///
     /// @param dummy: if true the dummy bus adapter will be used
-    ATTSCrate(bool dummy=false)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    ATTSCrate(bool dummy=false);
 
   public:
 
@@ -47,8 +46,7 @@ namespace tts {
 
     /// get an the (single) instance of the ATTSCrate
     ///
-    static ATTSCrate* getInstance()
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    static ATTSCrate* getInstance();
 
   
     /// get the ATTS Address Table
@@ -59,16 +57,14 @@ namespace tts {
 
     /// find an ATTS by its PCI Index
     ///
-    tts::ATTSInterfaceCard& getATTSInterfaceCard( uint32_t id )
-      throw (xcept::Exception);
+    tts::ATTSInterfaceCard& getATTSInterfaceCard( uint32_t id );
 
   
     /// find an ATTS by its Serial Number
     ///
     /// @param sn is the serial number
     ///
-    tts::ATTSInterfaceCard& getATTSInterfaceCardbySN( std::string const& sn )
-      throw (xcept::Exception);
+    tts::ATTSInterfaceCard& getATTSInterfaceCardbySN( std::string const& sn );
   
     /// find an ATTS by its GeoSlot
     ///
@@ -81,8 +77,7 @@ namespace tts {
     /// 
     /// Note: GeoSlots are only available in Compact PCI crates with a custom CMSDAQ backplane.
     ///
-    tts::ATTSInterfaceCard& getATTSInterfaceCardbyGeoSlot( uint32_t geoslot )
-      throw (xcept::Exception);
+    tts::ATTSInterfaceCard& getATTSInterfaceCardbyGeoSlot( uint32_t geoslot );
 
     /// get a reference to the bus adapter
     HAL::PCIBusAdapterInterface& getPCIBusAdapter() { return *_busadapter;};
@@ -93,8 +88,7 @@ namespace tts {
     void cleanup();
 
     /// check that the geoslots are unique in the crate
-    void checkGeoSlotsUnique()
-      throw (xcept::Exception);
+    void checkGeoSlotsUnique();
 
   protected: 
     HAL::PCIBusAdapterInterface *_busadapter;
diff --git a/tts/atts/include/tts/atts/ATTSInterfaceCard.hh b/tts/atts/include/tts/atts/ATTSInterfaceCard.hh
index 328466e09..be73ffd40 100755
--- a/tts/atts/include/tts/atts/ATTSInterfaceCard.hh
+++ b/tts/atts/include/tts/atts/ATTSInterfaceCard.hh
@@ -47,8 +47,7 @@ namespace tts {
 
     /// reset the ATTSInterface
     ///
-    void reset()
-      throw (HAL::HardwareAccessException);
+    void reset();
 
 
     /// read the GeoSlot
@@ -59,37 +58,32 @@ namespace tts {
     ///
     /// Note: GeoSlots are only available in Compact PCI crates with a custom CMSDAQ backplane.
     ///
-    uint32_t getGeoSlot()
-      throw (HAL::HardwareAccessException);
+    uint32_t getGeoSlot();
 
 
     /// read the Revision of the FMM Firmware
     ///
     /// The std::string contains 9 characters in the format "YYMMDD_RR",
     /// where YY is the year since 2000, MM, the month (1-12), DD the day (1-31) and RR the revision in this day (00-99)
-    std::string readFirmwareRev()
-      throw (HAL::HardwareAccessException);
+    std::string readFirmwareRev();
 
     /// read the Revision of the Firmware of the Altera (Bridge)
     ///
     /// The std::string contains 9 characters in the format "YYMMDD_RR",
     /// where YY is the year since 2000, MM, the month (1-12), DD the day (1-31) and RR the revision in this day (00-99)
-    std::string readFirmwareRevAltera()
-      throw (HAL::HardwareAccessException);
+    std::string readFirmwareRevAltera();
 
     /// read the serial number
     ///
     /// the reurned std::string contains the 19 digits of the serial number
-    std::string getSerialNumber()
-      throw (HAL::HardwareAccessException);
+    std::string getSerialNumber();
 
   
     /// set front panel LEDs
     ///
     /// @param led_setting[2:0] contains 1 bit each for the front panel LEDs 4 to 2 
     ///
-    void setLEDs(uint32_t led_setting)
-      throw (HAL::HardwareAccessException);
+    void setLEDs(uint32_t led_setting);
 
     /// Set the state of the DAQ Partition to be signalled to the Global Trigger TCS System
     ///
@@ -100,8 +94,7 @@ namespace tts {
     /// States Error and Out of Sync should be signalled as a pulse using pulseDAQPartitionState(),
     /// because they must not exceed a certain pulse length.
     ///
-    void setDAQPartitionState(uint32_t ipartition, tts::TTSState const& state)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void setDAQPartitionState(uint32_t ipartition, tts::TTSState const& state);
 
     /// Set the state of the DAQ Partition state for a certain time, then return to the previous state
     ///
@@ -115,58 +108,49 @@ namespace tts {
     /// therefore generates a pulse of 5 bx length and then goes back to
     /// the previous state.
     ///
-    void pulseDAQPartitionState(uint32_t ipartition, tts::TTSState const& state)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void pulseDAQPartitionState(uint32_t ipartition, tts::TTSState const& state);
 
     /// Read back the DAQ partition state set by setDAQPartitionState
     ///
     /// @param ipartition is the DAQ partiton index (0..7 (11) )
-    tts::TTSState readbackDAQPartitionState(uint32_t ipartition)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    tts::TTSState readbackDAQPartitionState(uint32_t ipartition);
 
     /// Read the state of the Global Trigger TCS System for all DAQ Partitions
     ///
     /// returns the state signalleds by the TCS system
-    std::vector<tts::TTSState> readTCSPartitionStates()
-      throw (HAL::HardwareAccessException);
+    std::vector<tts::TTSState> readTCSPartitionStates();
 
     /// Read the state of the Global Trigger TCS System for a given DAQ Partition
     ///
     /// @param ipartition is the DAQ partiton index (0..7 (11) )
     ///
     /// returns the state signalled by the TCS system
-    tts::TTSState readTCSPartitionState(uint32_t ipartition)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    tts::TTSState readTCSPartitionState(uint32_t ipartition);
 
     /// are we in simulation mode?
-    bool isSimuMode()
-      throw (HAL::HardwareAccessException); 
+    bool isSimuMode(); 
 
     /// toggle simu mode
     ///
     /// @param simu_mode is true for input simulation mode, false for normal operation 
-    void toggleSimuMode(bool simu_mode)
-      throw (HAL::HardwareAccessException);
+    void toggleSimuMode(bool simu_mode);
 
 
     /// set the simulated input states
     ///
     /// @param states contains the 12 input states to be simulated
-    void setSimulatedInputStates(std::vector <tts::TTSState> const& states)
-      throw (HAL::HardwareAccessException);
+    void setSimulatedInputStates(std::vector <tts::TTSState> const& states);
 
     /// set the simulated input state
     ///
     /// @param channel is the channel number (0..11) 
     /// @param state contains input state to be simulated
-    void setSimulatedInputState(uint32_t channel, tts::TTSState const& state)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void setSimulatedInputState(uint32_t channel, tts::TTSState const& state);
 
     /// read back the simulated input states
     ///
     /// returns a std::vector of 12 TTSStates
-    std::vector<tts::TTSState> readbackSimulatedInputStates()
-      throw (HAL::HardwareAccessException);
+    std::vector<tts::TTSState> readbackSimulatedInputStates();
 
     /// get a referene to the HAL::PCIDevice
     HAL::PCIDevice& device() { return *_atts; };
diff --git a/tts/atts/include/tts/atts/version.h b/tts/atts/include/tts/atts/version.h
index 1eff43311..4202d3ac8 100755
--- a/tts/atts/include/tts/atts/version.h
+++ b/tts/atts/include/tts/atts/version.h
@@ -43,7 +43,7 @@ namespace ttsatts
 	const std::string summary = "ttsatts";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/atts/src/common/ATTSCrate.cc b/tts/atts/src/common/ATTSCrate.cc
index 0e788364b..cb00c4f45 100755
--- a/tts/atts/src/common/ATTSCrate.cc
+++ b/tts/atts/src/common/ATTSCrate.cc
@@ -25,8 +25,7 @@
 
 tts::ATTSCrate* tts::ATTSCrate::_instance = 0;
 
-tts::ATTSCrate::ATTSCrate(bool dummy) 
-  throw (HAL::HardwareAccessException, xcept::Exception)
+tts::ATTSCrate::ATTSCrate(bool dummy)
   : _busadapter(0),
     _atts_addresstable(0),
     _theATTSs() {
@@ -65,8 +64,7 @@ tts::ATTSCrate::ATTSCrate(bool dummy)
 }
 
 
-tts::ATTSCrate* tts::ATTSCrate::getInstance() 
-    throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::ATTSCrate* tts::ATTSCrate::getInstance() {
 
   if (_instance == 0)
     _instance = new tts::ATTSCrate();
@@ -103,8 +101,7 @@ tts::ATTSCrate::~ATTSCrate() {
 
 
 
-tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCard( uint32_t id )     
-  throw (xcept::Exception) {
+tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCard( uint32_t id ) {
 
   if ( id >= (uint32_t) _theATTSs.size() )
     XCEPT_RAISE (xcept::Exception, "ATTS with requested ID is not present.");
@@ -112,8 +109,7 @@ tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCard( uint32_t id )
   return * (_theATTSs[id] );
 }
 
-tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCardbySN( std::string const& sn ) 
-  throw (xcept::Exception) {
+tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCardbySN( std::string const& sn ) {
 
   std::vector<tts::ATTSInterfaceCard *>::iterator it = _theATTSs.begin();
   for (; it != _theATTSs.end(); ++it) 
@@ -124,8 +120,7 @@ tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCardbySN( std::string co
   
 }
 
-tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCardbyGeoSlot( uint32_t geoslot )
-  throw (xcept::Exception) {
+tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCardbyGeoSlot( uint32_t geoslot ) {
 
   checkGeoSlotsUnique();
 
@@ -140,8 +135,7 @@ tts::ATTSInterfaceCard& tts::ATTSCrate::getATTSInterfaceCardbyGeoSlot( uint32_t
   XCEPT_RAISE(xcept::Exception, msg.str() );
 }
 
-void tts::ATTSCrate::checkGeoSlotsUnique()
-  throw (xcept::Exception) {
+void tts::ATTSCrate::checkGeoSlotsUnique() {
 
   // check that geoslots are unique to be sure that we are in a crate with proper backplane
 
diff --git a/tts/atts/src/common/ATTSInterfaceCard.cc b/tts/atts/src/common/ATTSInterfaceCard.cc
index 54e180922..817bab1eb 100755
--- a/tts/atts/src/common/ATTSInterfaceCard.cc
+++ b/tts/atts/src/common/ATTSInterfaceCard.cc
@@ -21,8 +21,7 @@ tts::ATTSInterfaceCard::~ATTSInterfaceCard() {
   delete _atts;
 };
 
-uint32_t tts::ATTSInterfaceCard::getGeoSlot() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::ATTSInterfaceCard::getGeoSlot() {
   
   if (_geoslot == 999) {
 
@@ -35,15 +34,13 @@ uint32_t tts::ATTSInterfaceCard::getGeoSlot()
   return _geoslot;
 }
 
-void tts::ATTSInterfaceCard::reset() 
-    throw (HAL::HardwareAccessException) { 
+void tts::ATTSInterfaceCard::reset() { 
   _atts->write("reset_all",0x7f); 
   _atts->write("reset_all",0x0); 
 };
 
 
-std::string tts::ATTSInterfaceCard::readFirmwareRev() 
-    throw (HAL::HardwareAccessException) {
+std::string tts::ATTSInterfaceCard::readFirmwareRev() {
 
   uint32_t year;
   uint32_t month;
@@ -65,8 +62,7 @@ std::string tts::ATTSInterfaceCard::readFirmwareRev()
   return rev;
 }
 
-std::string tts::ATTSInterfaceCard::readFirmwareRevAltera() 
-    throw (HAL::HardwareAccessException) {
+std::string tts::ATTSInterfaceCard::readFirmwareRevAltera() {
 
   
   uint32_t fwid_altera;
@@ -87,8 +83,7 @@ std::string tts::ATTSInterfaceCard::BCDtoString(uint32_t num, uint32_t ndigit) {
   return txt.str();
 }
 
-bool tts::ATTSInterfaceCard::isSimuMode() 
-    throw (HAL::HardwareAccessException) {
+bool tts::ATTSInterfaceCard::isSimuMode() {
   
   uint32_t simu_mode;
   _atts->read("Test_select", &simu_mode);
@@ -96,22 +91,19 @@ bool tts::ATTSInterfaceCard::isSimuMode()
   return (simu_mode & 0x1) == 0x1;
 }
 
-void tts::ATTSInterfaceCard::toggleSimuMode(bool simu_mode) 
-    throw (HAL::HardwareAccessException) {
+void tts::ATTSInterfaceCard::toggleSimuMode(bool simu_mode) {
 
   _atts->write("Test_select", simu_mode?0x1:0x0);
 
 }
 
 
-void tts::ATTSInterfaceCard::setLEDs(uint32_t led_setting) 
-    throw (HAL::HardwareAccessException) {
+void tts::ATTSInterfaceCard::setLEDs(uint32_t led_setting) {
   _atts->write("leds", led_setting);
 };
 
 
-void tts::ATTSInterfaceCard::setSimulatedInputStates(std::vector <tts::TTSState> const& states) 
-    throw (HAL::HardwareAccessException) {
+void tts::ATTSInterfaceCard::setSimulatedInputStates(std::vector <tts::TTSState> const& states) {
 
   uint32_t ready=0;
   uint32_t busy=0;
@@ -135,8 +127,7 @@ void tts::ATTSInterfaceCard::setSimulatedInputStates(std::vector <tts::TTSState>
 };
 
 
-void tts::ATTSInterfaceCard::setSimulatedInputState(uint32_t channel, tts::TTSState const& state) 
-    throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::ATTSInterfaceCard::setSimulatedInputState(uint32_t channel, tts::TTSState const& state) {
 
   if (channel > 11)
     XCEPT_RAISE(xcept::Exception, "channel out of range");
@@ -170,8 +161,7 @@ void tts::ATTSInterfaceCard::setSimulatedInputState(uint32_t channel, tts::TTSSt
 };
 
 
-std::vector<tts::TTSState> tts::ATTSInterfaceCard::readbackSimulatedInputStates() 
-    throw (HAL::HardwareAccessException) {
+std::vector<tts::TTSState> tts::ATTSInterfaceCard::readbackSimulatedInputStates() {
 
   uint32_t ready=0;
   uint32_t busy=0;
@@ -201,8 +191,7 @@ std::vector<tts::TTSState> tts::ATTSInterfaceCard::readbackSimulatedInputStates(
 
 
 
-void tts::ATTSInterfaceCard::setDAQPartitionState(uint32_t ipartition, tts::TTSState const& state) 
-    throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::ATTSInterfaceCard::setDAQPartitionState(uint32_t ipartition, tts::TTSState const& state) {
 
   if (ipartition > 11)
     XCEPT_RAISE(xcept::Exception, "ipartition out of range");
@@ -213,8 +202,7 @@ void tts::ATTSInterfaceCard::setDAQPartitionState(uint32_t ipartition, tts::TTSS
   _atts->write(item.str(), (uint32_t) state);
 }
 
-void tts::ATTSInterfaceCard::pulseDAQPartitionState(uint32_t ipartition, tts::TTSState const& state)
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::ATTSInterfaceCard::pulseDAQPartitionState(uint32_t ipartition, tts::TTSState const& state) {
 
   XCEPT_RAISE(xcept::Exception, "pulsing of DAQ partition states not yet implemented.");
 
@@ -222,8 +210,7 @@ void tts::ATTSInterfaceCard::pulseDAQPartitionState(uint32_t ipartition, tts::TT
 
 
 
-tts::TTSState tts::ATTSInterfaceCard::readbackDAQPartitionState(uint32_t ipartition) 
-    throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::TTSState tts::ATTSInterfaceCard::readbackDAQPartitionState(uint32_t ipartition) {
 
   if (ipartition > 11)
     XCEPT_RAISE(xcept::Exception, "ipartition out of range");
@@ -237,8 +224,7 @@ tts::TTSState tts::ATTSInterfaceCard::readbackDAQPartitionState(uint32_t ipartit
   return tts::TTSState(state);
 }
 
-std::vector<tts::TTSState> tts::ATTSInterfaceCard::readTCSPartitionStates() 
-    throw (HAL::HardwareAccessException) {
+std::vector<tts::TTSState> tts::ATTSInterfaceCard::readTCSPartitionStates() {
 
   uint32_t ready=0;
   uint32_t busy=0;
@@ -266,8 +252,7 @@ std::vector<tts::TTSState> tts::ATTSInterfaceCard::readTCSPartitionStates()
   return states;
 };
 
-tts::TTSState tts::ATTSInterfaceCard::readTCSPartitionState(uint32_t ipartition) 
-    throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::TTSState tts::ATTSInterfaceCard::readTCSPartitionState(uint32_t ipartition) {
 
   if (ipartition > 11)
     XCEPT_RAISE(xcept::Exception, "ipartition out of range");
@@ -275,8 +260,7 @@ tts::TTSState tts::ATTSInterfaceCard::readTCSPartitionState(uint32_t ipartition)
   return readTCSPartitionStates()[ipartition];
 };
 
-std::string tts::ATTSInterfaceCard::getSerialNumber() 
-    throw (HAL::HardwareAccessException) {
+std::string tts::ATTSInterfaceCard::getSerialNumber() {
 
   if (_serialnumber == "") {
     std::stringstream sn;
diff --git a/tts/atts/src/common/version.cc b/tts/atts/src/common/version.cc
index 4f9798122..1bf42521b 100755
--- a/tts/atts/src/common/version.cc
+++ b/tts/atts/src/common/version.cc
@@ -18,7 +18,7 @@
 
 GETPACKAGEINFO(ttsatts)
 
-void ttsatts::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsatts::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(ttsttsbase);  
 
diff --git a/tts/cpcibase/include/tts/cpcibase/CPCICard.hh b/tts/cpcibase/include/tts/cpcibase/CPCICard.hh
index 761c1517b..e16bc07f6 100755
--- a/tts/cpcibase/include/tts/cpcibase/CPCICard.hh
+++ b/tts/cpcibase/include/tts/cpcibase/CPCICard.hh
@@ -58,8 +58,7 @@ namespace tts {
     /// This method needs a host-wide semaphore arrary which has to be crated with crate_lock_util.exe
     ///
     /// returns true if successful, false if not
-    bool getWriteLock()
-      throw (ipcutils::exception::Exception);
+    bool getWriteLock();
 
     /// release the write lock for the FMM
     ///
@@ -68,8 +67,7 @@ namespace tts {
     /// threads using the FMM have stopped writing to the FMM before calling
     /// releaseWriteLock()
     ///
-    void releaseWriteLock()
-      throw (ipcutils::exception::Exception);
+    void releaseWriteLock();
 
     /// check if we have a write lock
     ///
@@ -92,8 +90,7 @@ namespace tts {
     /// get process id of the process that has the write lock of the FMM
     /// 
     /// returns -1 if the FMM is not locked
-    int getWriteLockOwnerPID()
-      throw (ipcutils::exception::Exception);
+    int getWriteLockOwnerPID();
   
 
     /// disable locking
@@ -119,14 +116,12 @@ namespace tts {
     ///
     /// The std::string contains 9 characters in the format "YYMMDD_RR",
     /// where YY is the year since 2000, MM, the month (1-12), DD the day (1-31) and RR the revision in this day (00-99)
-    std::string readFirmwareRevAltera()
-      throw (HAL::HardwareAccessException);
+    std::string readFirmwareRevAltera();
 
     /// read the serial number
     ///
     /// the reurned std::string contains the 19 digits of the serial number
-    std::string getSerialNumber()
-      throw (HAL::HardwareAccessException);
+    std::string getSerialNumber();
 
 
     /// read the GeoSlot
@@ -137,8 +132,7 @@ namespace tts {
     ///
     /// Note: GeoSlots are only available in Compact PCI crates with a custom CMSDAQ backplane.
     ///
-    uint32_t getGeoSlot()
-      throw (HAL::HardwareAccessException);
+    uint32_t getGeoSlot();
 
 
     /// get a referene to the HAL HAL::PCIDevice
@@ -150,8 +144,7 @@ namespace tts {
 
   protected: 
     /// check if we have a write lock and throw exception, otherwise throw an exception
-    void check_write_lock() 
-      throw (tts::exception::NoWriteLock);
+    void check_write_lock();
 
     HAL::PCIDevice* _dev() {
       return _device;
diff --git a/tts/cpcibase/include/tts/cpcibase/version.h b/tts/cpcibase/include/tts/cpcibase/version.h
index 7d6dcf067..e944f51d5 100755
--- a/tts/cpcibase/include/tts/cpcibase/version.h
+++ b/tts/cpcibase/include/tts/cpcibase/version.h
@@ -43,7 +43,7 @@ namespace ttscpcibase
 	const std::string summary = "ttscpcibase";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/cpcibase/src/common/CPCICard.cc b/tts/cpcibase/src/common/CPCICard.cc
index 57a3c44a6..ba4dd0762 100755
--- a/tts/cpcibase/src/common/CPCICard.cc
+++ b/tts/cpcibase/src/common/CPCICard.cc
@@ -35,8 +35,7 @@ tts::CPCICard::~CPCICard() {
   delete _device;
 };
 
-bool tts::CPCICard::getWriteLock() 
-  throw (ipcutils::exception::Exception) {
+bool tts::CPCICard::getWriteLock() {
 
   if (_have_write_lock)
     XCEPT_RAISE( ipcutils::exception::Exception, 
@@ -50,8 +49,7 @@ bool tts::CPCICard::getWriteLock()
   return _have_write_lock;
 }
 
-void tts::CPCICard::releaseWriteLock() 
-  throw (ipcutils::exception::Exception) {
+void tts::CPCICard::releaseWriteLock() {
 
   if (! _have_write_lock)
     XCEPT_RAISE( ipcutils::exception::Exception, 
@@ -77,16 +75,14 @@ bool tts::CPCICard::haveWriteLock() {
   return _have_write_lock;
 }
 
-void tts::CPCICard::check_write_lock() 
-  throw (tts::exception::NoWriteLock) {
+void tts::CPCICard::check_write_lock() {
 
   if ( !_have_write_lock )
     XCEPT_RAISE( tts::exception::NoWriteLock, 
 		 "do not have write lock for this FMM. Obtain it with getWriteLock()");
 }
 
-int tts::CPCICard::getWriteLockOwnerPID() 
-  throw (ipcutils::exception::Exception) {
+int tts::CPCICard::getWriteLockOwnerPID() {
 
   if ( ! _locking_enabled ) 
     return -1;
@@ -111,8 +107,7 @@ bool tts::CPCICard::isLockingEnabled() {
 }
 
 
-std::string tts::CPCICard::readFirmwareRevAltera() 
-  throw (HAL::HardwareAccessException) {
+std::string tts::CPCICard::readFirmwareRevAltera() {
 
   
   uint32_t fwid_altera;
@@ -125,8 +120,7 @@ std::string tts::CPCICard::readFirmwareRevAltera()
 }
 
 
-std::string tts::CPCICard::getSerialNumber() 
-  throw (HAL::HardwareAccessException) {
+std::string tts::CPCICard::getSerialNumber() {
 
   if (_serialnumber == "") {
     std::stringstream sn;
@@ -149,8 +143,7 @@ std::string tts::CPCICard::getSerialNumber()
 
 
 
-uint32_t tts::CPCICard::getGeoSlot() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::CPCICard::getGeoSlot() {
   
   if (_geoslot == 999) {
 
diff --git a/tts/cpcibase/src/common/version.cc b/tts/cpcibase/src/common/version.cc
index 864c8435b..2e0a93568 100755
--- a/tts/cpcibase/src/common/version.cc
+++ b/tts/cpcibase/src/common/version.cc
@@ -21,7 +21,7 @@
 
 GETPACKAGEINFO(ttscpcibase)
 
-void ttscpcibase::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttscpcibase::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 	CHECKDEPENDENCY(xcept);  
diff --git a/tts/fmm/Makefile b/tts/fmm/Makefile
index 08f2df653..ab3455bab 100755
--- a/tts/fmm/Makefile
+++ b/tts/fmm/Makefile
@@ -46,7 +46,8 @@ Sources=\
 	FMMHardcodedAddressTableReader.cc
 
 
-#ORACLE_HOME = /afs/cern.ch/project/oracle/linux/10103/
+#allow user to overwrite ORACLE_HOME = ../../extern/oracle/x86_64_centos7
+
 ifdef ORACLE_HOME
 ORACLE_INCLUDE_PREFIX=${ORACLE_HOME}/rdbms/demo/ ${ORACLE_HOME}/rdbms/public/
 ORACLE_LIB_PREFIX=${ORACLE_HOME}/lib
@@ -129,9 +130,9 @@ ifeq ($(Set),withdbi)
 UserCCFlags =
 
 TestLibraries += \
-	fmmdbi occi clntsh 
+	ttsfmmdbi occi clntsh clntshcore ons nnz12
 Libraries += \
-	fmmdbi occi clntsh 
+	ttsfmmdbi occi clntsh clntshcore ons nnz12
 
 else
 
diff --git a/tts/fmm/include/tts/fmm/FMMCard.hh b/tts/fmm/include/tts/fmm/FMMCard.hh
index 16ade825f..ae5106948 100755
--- a/tts/fmm/include/tts/fmm/FMMCard.hh
+++ b/tts/fmm/include/tts/fmm/FMMCard.hh
@@ -59,53 +59,39 @@ namespace tts {
     virtual ~FMMCard();
 
     /// reset the dead-time monitors
-    void resetDeadTimeMonitors()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void resetDeadTimeMonitors();
   
     /// reset the transition miss counter
-    void resetTransitionMissCounter()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void resetTransitionMissCounter();
   
     /// reset the time tag counter
-    void resetTimeTag()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void resetTimeTag();
 
     /// reset history write counter
-    void resetHistoryAddress()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void resetHistoryAddress();
   
     /// Reset the FMM
     ///
     /// This reset clears state machines, fifos and registers for which individual reset
     /// functions exist.
     /// Does not reset control register, mask and threshold registers.
-    void resetAll()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void resetAll();
 
     /// read the history memory write address (17 bit) in unites of 16-byte blocks
-    uint32_t readHistoryAddress()
-      throw (HAL::HardwareAccessException);
+    uint32_t readHistoryAddress();
 
     /// read the history memory write address (17 bit) in unites of 16-byte blocks (first in pair), 
     /// and the wrap counter for the History Address counter (second in pair) 
-    std::pair<uint32_t, uint32_t> readHistoryAddressAndWrapCount()
-      throw (HAL::HardwareAccessException);
+    std::pair<uint32_t, uint32_t> readHistoryAddressAndWrapCount();
 
     /// read transition miss counter
-    uint32_t readTransitionMissCounter()
-      throw (HAL::HardwareAccessException);
+    uint32_t readTransitionMissCounter();
 
     /// read the Revision of the FMM Firmware
     ///
     /// The std::string contains 9 characters in the format "YYMMDD_RR",
     /// where YY is the year since 2000, MM, the month (1-12), DD the day (1-31) and RR the revision in this day (00-99)
-    std::string readFirmwareRev()
-      throw (HAL::HardwareAccessException);
+    std::string readFirmwareRev();
 
     /// toggle dual FMM mode
     ///
@@ -122,160 +108,120 @@ namespace tts {
     /// and setThreshold10B().
     ///
     /// @param dual is true for dual-FMM mode, false for single-FMM mode
-    void toggleDualMode(bool dual)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void toggleDualMode(bool dual);
 
     /// are we in dual FMM mode?
-    bool isDualMode()
-      throw (HAL::HardwareAccessException);
+    bool isDualMode();
 
     /// set the mask
     ///
     /// @param mask[19:0] is the mask for the 20 input channels. 
     ///        Setting a bit to 1 means that the channel is masked (switched off).
-    void setMask(uint32_t mask)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setMask(uint32_t mask);
 
     /// read back the mask
-    uint32_t getMask()
-      throw (HAL::HardwareAccessException);
+    uint32_t getMask();
 
     /// set the threshold for 20-input (single-FMM) mode
     ///
     /// @param threshold[4:0] is the threshold for the merging of out-of-sync inputs.
     ///        more than threshold inputs have to be out-of-sync for the resulting 
     ///        state to be out-of-sync. The default value of 0(zero) corresponds to a logical OR.
-    void setThreshold20(uint32_t threshold)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setThreshold20(uint32_t threshold);
 
     /// read back the threshold
-    uint32_t getThreshold20()
-      throw (HAL::HardwareAccessException);
+    uint32_t getThreshold20();
 
     /// set the threshold A (merging of first 10 inputs) for 10-input (dual-FMM) mode
     ///
     /// @param threshold[3:0] is the threshold for the merging of out-of-sync inputs.
     ///        more than threshold inputs have to be out-of-sync for the resulting 
     ///        state to be out-of-sync. The default value of 0(zero) corresponds to a logical OR.
-    void setThreshold10A(uint32_t threshold)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setThreshold10A(uint32_t threshold);
 
     /// read back the threshold
-    uint32_t getThreshold10A()
-      throw (HAL::HardwareAccessException);
+    uint32_t getThreshold10A();
 
     /// set the threshold B (merging of second 10 inputs) for 10-input (dual-FMM) mode
     ///
     /// @param threshold[3:0] is the threshold for the merging of out-of-sync inputs.
     ///        more than threshold inputs have to be out-of-sync for the resulting 
     ///        state to be out-of-sync. The default value of 0(zero) corresponds to a logical OR.
-    void setThreshold10B(uint32_t threshold)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setThreshold10B(uint32_t threshold);
 
     /// read back the threshold
-    uint32_t getThreshold10B()
-      throw (HAL::HardwareAccessException);
+    uint32_t getThreshold10B();
 
     /// set the configuration
     /// 
     /// This sets dualmode, mask and the three thesholds at the same time
     ///
     /// @param cfg is the FMM configuration
-    void setConfig(tts::FMMConfiguration const& cfg)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setConfig(tts::FMMConfiguration const& cfg);
 
     /// read back the configuration
-    tts::FMMConfiguration readConfig()
-      throw (HAL::HardwareAccessException);
+    tts::FMMConfiguration readConfig();
 
     /// are we in simulation mode?
-    bool isSimuMode()
-      throw (HAL::HardwareAccessException); 
+    bool isSimuMode(); 
 
     /// toggle simu mode
     ///
     /// @param simu_mode is true for input simulation mode, false for normal operation 
-    void toggleSimuMode(bool simu_mode)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void toggleSimuMode(bool simu_mode);
 
     /// are we in DMA History mode?
-    bool isDMAMode()
-      throw (HAL::HardwareAccessException); 
+    bool isDMAMode(); 
 
     /// toggle DMA mode
     ///
     /// @param dma_mode is true for DMA mode, false for ZBT (normal) mode
-    void toggleDMAMode(bool dma_mode)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void toggleDMAMode(bool dma_mode);
 
     /// toggle enable bit for time tag reset from backplane
     ///
     /// @param enabled is true if tim e tag reset from the backplane is enabled
-    void toggleTimeTagExtResetEnable(bool enable)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void toggleTimeTagExtResetEnable(bool enable);
 
     /// is time tag reset from backplane enabled?
-    bool timeTagExtResetEnabled()
-      throw (HAL::HardwareAccessException);
+    bool timeTagExtResetEnabled();
 
     /// set front panel LEDs
     ///
     /// @param led_setting[2:0] contains 1 bit each for the front panel LEDs 4 to 2 
     ///
-    void setLEDs(uint32_t led_setting)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setLEDs(uint32_t led_setting);
 
     /// set the simulated input states
     ///
     /// @param states contains the 20 input states to be simulated
-    void setSimulatedInputStates(std::vector <tts::TTSState> const& states)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void setSimulatedInputStates(std::vector <tts::TTSState> const& states);
 
     /// set the simulated input state
     ///
     /// @param channel is the channel number (0..19) 
     /// @param state contains input state to be simulated
-    void setSimulatedInputState(uint32_t channel, tts::TTSState const& state)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock,
-	     xcept::Exception);
+    void setSimulatedInputState(uint32_t channel, tts::TTSState const& state);
 
     /// read back the simulated input states
     ///
-    std::vector<tts::TTSState> getSimulatedInputStates()
-      throw (HAL::HardwareAccessException);
+    std::vector<tts::TTSState> getSimulatedInputStates();
   
     /// read the current inputs from the spy registers
     ///
-    std::vector<tts::TTSState> readInputs()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    std::vector<tts::TTSState> readInputs();
   
 
     /// read an item from the history memory
     ///
     /// @param addr is the address of the item (in units of 16-byte blocks)
     /// @param hi is a reference to the history item to be filled
-    void readHistoryItem(uint32_t addr, tts::FMMHistoryItem& hi)
-      throw (HAL::HardwareAccessException);
+    void readHistoryItem(uint32_t addr, tts::FMMHistoryItem& hi);
 
     /// clear the history memory
     ///
     /// @param pattern is the 32-bit pattern to write to each word in the history memory
-    void clearHistoryMemory(uint32_t pattern = 0x00000000)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void clearHistoryMemory(uint32_t pattern = 0x00000000);
 
 
     /// retrieve dead-time counters
@@ -288,9 +234,7 @@ namespace tts {
     ///        the second 22 count the time spent in warning state.
     ///        In a set of 22 counters, the first 20 corresponf to the 20 inputs, 
     ///        the next two to the two possible outputs (FuncA, FuncB)
-    void readDeadTimeCounters(std::vector<uint32_t> & counters )
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void readDeadTimeCounters(std::vector<uint32_t> & counters );
 
 
     /// retrieve dead-time counters and time tag in one operation
@@ -304,9 +248,7 @@ namespace tts {
     ///        In a set of 22 counters, the first 20 corresponf to the 20 inputs, 
     ///        the next two to the two possible outputs (FuncA, FuncB)
     /// @param tt is the 40-bit time tag
-    void readDeadTimeCountersAndTimeTag(std::vector<uint32_t> & counters, uint64_t& tt )
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void readDeadTimeCountersAndTimeTag(std::vector<uint32_t> & counters, uint64_t& tt );
 
 
     /// read the time tag counter read register
@@ -314,84 +256,64 @@ namespace tts {
     /// does the necessary unfreezing and freezing.
     /// synchronized with readDeadTimeCounters() and readDeadTimeCountersAndTimeTag();
     /// 
-    uint64_t readTimeTag()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    uint64_t readTimeTag();
 
     /// retrieve the current result of half-FMM A (sent to IO20 and IO21)
-    tts::TTSState readResultA()
-      throw (HAL::HardwareAccessException);
+    tts::TTSState readResultA();
 
     /// retrieve the current result of half-FMM B (sent to IO22 and IO23)
-    tts::TTSState readResultB()
-      throw (HAL::HardwareAccessException);
+    tts::TTSState readResultB();
 
     /// read the func value A (input to the priority encoder of first half-FMM)
-    uint32_t readFuncA()
-      throw (HAL::HardwareAccessException);
+    uint32_t readFuncA();
 
     /// read the func value B (input to the priority encoder of second half-FMM)
-    uint32_t readFuncB()
-      throw (HAL::HardwareAccessException);
+    uint32_t readFuncB();
   
     /// toggle output test mode
     ///
     /// @param test_output_enable[3:0] switches outputs 23:20 to test mode (when the corresponding bit is set)
-    void enableTestOutputs(uint32_t test_output_enable)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void enableTestOutputs(uint32_t test_output_enable);
 
     /// read back the test output enable bits
     ///
     /// the returned value[3:0] indicates which of outputs 23:20 are in test mode
-    uint32_t readTestOutputEnables()
-      throw (HAL::HardwareAccessException);
+    uint32_t readTestOutputEnables();
 
     /// set the state of one of the four outputs (if in the output is in test mode)
     ///
     /// @param output_idx is the index of the output (0..3)
     /// @param state is the state to set
-    void setTestOutputValue(uint32_t output_idx, tts::TTSState const& state )
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock,
-	     xcept::Exception);
+    void setTestOutputValue(uint32_t output_idx, tts::TTSState const& state );
 
     /// read back the test-state of an output 
     ///
     /// note: the output is set to this state only if the output is in test mode
     ///
     /// @param output_idx is the index of the output (0..3)
-    tts::TTSState readTestOutputValue(uint32_t output_idx)
-      throw (HAL::HardwareAccessException, 
-	     xcept::Exception);
+    tts::TTSState readTestOutputValue(uint32_t output_idx);
 
     enum { FMMHistMemSize = 0x20000 }; // in units of 16-byte blocks
     enum { FMMWrapCounterLength = 32768 };
 
   protected:
   
-    void doReadDeadTimeCounters(std::vector<uint32_t> & counters )
-      throw (HAL::HardwareAccessException);
+    void doReadDeadTimeCounters(std::vector<uint32_t> & counters );
 
-    uint64_t doReadTimeTag()
-      throw (HAL::HardwareAccessException);
+    uint64_t doReadTimeTag();
 
 
     /// freeze the dead time counter and time tag read registers
     ///
     /// the actual counters keep running. Use this before redaing the dead tim counters and the time tag.
     /// unFreezeTimes() has to be called after reading.
-    void freezeTimes()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void freezeTimes();
 
     /// un freeze the dead time counter and time tag read registers
     ///
     /// the actual counters keep running. Use this before redaing the dead tim counters and the time tag.
     /// unFreezeTimes() has to be called after reading.
-    void unFreezeTimes()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void unFreezeTimes();
 
 
   private: 
diff --git a/tts/fmm/include/tts/fmm/FMMCrate.hh b/tts/fmm/include/tts/fmm/FMMCrate.hh
index bc1fc0e9d..2f2ff3b62 100755
--- a/tts/fmm/include/tts/fmm/FMMCrate.hh
+++ b/tts/fmm/include/tts/fmm/FMMCrate.hh
@@ -46,8 +46,7 @@ namespace tts {
     /// @param project_id is the project ID used in the genreation of a unique key to identify
     ///        the semaphore array. 
     ///        The default value can be used unless there are multiple cPCI crates on the same host  
-    FMMCrate(bool dummy=false, char project_id='t')
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    FMMCrate(bool dummy=false, char project_id='t');
 
     /// d-tor
     virtual ~FMMCrate();
@@ -60,15 +59,13 @@ namespace tts {
 
     /// find an FMM by its PCI Index
     ///
-    tts::FMMCard& getFMM( uint32_t id )
-      throw (xcept::Exception);
+    tts::FMMCard& getFMM( uint32_t id );
   
     /// find an FMM by its Serial Number
     ///
     /// @param sn is the serial number
     ///
-    tts::FMMCard& getFMMbySN( std::string const& sn )
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    tts::FMMCard& getFMMbySN( std::string const& sn );
   
     /// find an FMM by its GeoSlot
     ///
@@ -81,15 +78,13 @@ namespace tts {
     /// 
     /// Note: GeoSlots are only available in Compact PCI crates with a custom CMSDAQ backplane.
     ///
-    tts::FMMCard& getFMMbyGeoSlot( uint32_t geoslot )
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    tts::FMMCard& getFMMbyGeoSlot( uint32_t geoslot );
 
     /// is there a trigger dirtibutor in the crate?
     bool hasTD();
 
     /// get the Trigger Distributor
-    tts::FMMTDCard& getTD()
-      throw (xcept::Exception);
+    tts::FMMTDCard& getTD();
 
     /// get a reference to the bus adapter
     HAL::PCIBusAdapterInterface& getPCIBusAdapter() { return *_busadapter;};
@@ -100,8 +95,7 @@ namespace tts {
     void cleanup();
 
     /// check that the geoslots are unique in the crate
-    void checkGeoSlotsUnique()
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void checkGeoSlotsUnique();
 
   protected: 
     HAL::PCIBusAdapterInterface *_busadapter;
diff --git a/tts/fmm/include/tts/fmm/FMMDeadTimeMonitor.hh b/tts/fmm/include/tts/fmm/FMMDeadTimeMonitor.hh
index 0565a1caf..f8e9559b0 100755
--- a/tts/fmm/include/tts/fmm/FMMDeadTimeMonitor.hh
+++ b/tts/fmm/include/tts/fmm/FMMDeadTimeMonitor.hh
@@ -52,14 +52,12 @@ namespace tts {
     /// @param resetHW. if true, reset the counters;
     ///        if false counters have to be reset after calling start
     ///
-    void start( bool resetHW = true )
-      throw (HAL::HardwareAccessException);
+    void start( bool resetHW = true );
 
     /// stop monitoring dead times
     ///
     /// counters are read for a last time and kept in memeory.
-    void stop()
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void stop();
 
     /// retrieve dead time counters and time tag
     ///
@@ -71,15 +69,13 @@ namespace tts {
     ///
     /// the dead time is counted in units of 25 ns
     ///
-    void readCounters(std::vector<tts::FMMDeadTime> & counters, uint64_t& timetag, bool doUpdate=true)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void readCounters(std::vector<tts::FMMDeadTime> & counters, uint64_t& timetag, bool doUpdate=true);
 
     /// read one counter
     ///
     /// no update is done.
     /// internally, no lock is used. Lock has to be used by calling lock() before calling readCounterNoUpdateNoLock()
-    tts::FMMDeadTime readCounterNoUpdateNoLock(uint32_t icounter)
-      throw (xcept::Exception) {
+    tts::FMMDeadTime readCounterNoUpdateNoLock(uint32_t icounter) {
 
       if (icounter >= NumCounters) {
 	XCEPT_RAISE(xcept::Exception, "counter index out of range");
@@ -91,8 +87,7 @@ namespace tts {
     ///
     /// no update is done.
     /// internally, no lock is used. Lock has to be used by calling lock() before calling readCounterNoUpdateNoLock()
-    double readDeadTimeFractionLastIntervalNoUpdateNoLock(uint32_t icounter)
-      throw (xcept::Exception) {
+    double readDeadTimeFractionLastIntervalNoUpdateNoLock(uint32_t icounter) {
 
       if (icounter >= NumCounters) {
 	XCEPT_RAISE(xcept::Exception, "counter index out of range");
@@ -122,8 +117,7 @@ namespace tts {
     /// fractions 0 to 21 count for each input channel and two output functions the fraction of time spent in busy state
     /// fractions 22 to 43 count for each input channel and two output functions the fraction of time spent in warning state
     ///
-    void readDeadTimeFractions(std::vector<double> & deadTimeFractions, bool doUpdate=true)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void readDeadTimeFractions(std::vector<double> & deadTimeFractions, bool doUpdate=true);
 
     /// retrieve the dead time counters as a fractions of the time over which they are measured
     /// for the interval between the last two calls to doUpdateCounters()
@@ -138,8 +132,7 @@ namespace tts {
     /// fractions 66 to 87 count for each input channel and two output functions the fraction of time spent in oos state
     /// fractions 88 to 109 count for each input channel and two output functions the fraction of time spent in error state
     ///
-    void readDeadTimeFractionsLastInterval(std::vector<double> & deadTimeFractions)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void readDeadTimeFractionsLastInterval(std::vector<double> & deadTimeFractions);
 
     /// update the software counters
     ///
@@ -149,8 +142,7 @@ namespace tts {
     /// 
     /// it does not access hardware if the FMMDeadTimeMonitor is not running
     ///
-    void updateCounters()
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void updateCounters();
 
     /// lock the FMMDeadTimeMonitor
     ///
@@ -170,13 +162,11 @@ namespace tts {
     ///
     /// the monitors start counting immediately as they are always running
     ///
-    void doReset( bool resetHW )
-      throw (HAL::HardwareAccessException);
+    void doReset( bool resetHW );
 
     /// internal method to update the software counters
     ///
-    void doUpdateCounters()
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    void doUpdateCounters();
 
     tts::FMMCard& _fmm;
     bool _running;
diff --git a/tts/fmm/include/tts/fmm/version.h b/tts/fmm/include/tts/fmm/version.h
index 672f15a94..96afe0a5b 100755
--- a/tts/fmm/include/tts/fmm/version.h
+++ b/tts/fmm/include/tts/fmm/version.h
@@ -41,7 +41,7 @@ namespace ttsfmm
 	const std::string summary = "ttsfmm";
 	const std::string link = "http://xdaqwiki.cern.ch/";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/fmm/src/common/FMMCard.cc b/tts/fmm/src/common/FMMCard.cc
index 9ebbc80e9..d5565eb95 100755
--- a/tts/fmm/src/common/FMMCard.cc
+++ b/tts/fmm/src/common/FMMCard.cc
@@ -22,9 +22,7 @@ tts::FMMCard::~FMMCard() {
 };
 
 
-void tts::FMMCard::resetDeadTimeMonitors() 
-  throw (HAL::HardwareAccessException,
- 	 tts::exception::NoWriteLock) {
+void tts::FMMCard::resetDeadTimeMonitors() {
 
   check_write_lock();
 
@@ -42,9 +40,7 @@ void tts::FMMCard::resetDeadTimeMonitors()
 
 };
   
-void tts::FMMCard::resetTransitionMissCounter() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::resetTransitionMissCounter() {
 
   check_write_lock();
 
@@ -60,9 +56,7 @@ void tts::FMMCard::resetTransitionMissCounter()
   _ctrl_reg_semaphore.give();
 };
   
-void tts::FMMCard::resetTimeTag() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::resetTimeTag() {
 
   check_write_lock();
 
@@ -78,9 +72,7 @@ void tts::FMMCard::resetTimeTag()
   _ctrl_reg_semaphore.give();
 };
 
-void tts::FMMCard::resetHistoryAddress() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::resetHistoryAddress() {
 
   check_write_lock();
 
@@ -96,9 +88,7 @@ void tts::FMMCard::resetHistoryAddress()
   _ctrl_reg_semaphore.give();
 };
   
-void tts::FMMCard::resetAll() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) { 
+void tts::FMMCard::resetAll() { 
 
   check_write_lock();
 
@@ -114,16 +104,14 @@ void tts::FMMCard::resetAll()
   _ctrl_reg_semaphore.give();
 };
 
-uint32_t tts::FMMCard::readHistoryAddress() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::readHistoryAddress() {
 
   uint32_t add;
   _dev()->read("ZBT_WR_ADD", &add);
   return add;
 }
 
-std::pair<uint32_t, uint32_t> tts::FMMCard::readHistoryAddressAndWrapCount()
-  throw (HAL::HardwareAccessException) {
+std::pair<uint32_t, uint32_t> tts::FMMCard::readHistoryAddressAndWrapCount() {
 
   uint32_t add;
   _dev()->read("ZBT_WR_ADD_ALL", &add);
@@ -136,16 +124,14 @@ std::pair<uint32_t, uint32_t> tts::FMMCard::readHistoryAddressAndWrapCount()
 }
 
 
-uint32_t tts::FMMCard::readTransitionMissCounter() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::readTransitionMissCounter() {
 
   uint32_t cnt;
   _dev()->read("TRT_MISS", &cnt);
   return cnt;
 }
 
-std::string tts::FMMCard::readFirmwareRev() 
-  throw (HAL::HardwareAccessException) {
+std::string tts::FMMCard::readFirmwareRev() {
 
   if (_fwRevXilinx == "") {
     uint32_t year;
@@ -178,68 +164,56 @@ std::string tts::FMMCard::BCDtoString(uint32_t num, uint32_t ndigit) {
   return txt.str();
 }
 
-void tts::FMMCard::setMask(uint32_t mask) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setMask(uint32_t mask) {
 
   check_write_lock();
 
   _dev()->write( "MASK", mask);
 };
   
-uint32_t tts::FMMCard::getMask() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::getMask() {
 
   uint32_t mask;  
   _dev()->read( "MASK", &mask);
   return mask;
 };
   
-void tts::FMMCard::setThreshold20(uint32_t threshold) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setThreshold20(uint32_t threshold) {
 
   check_write_lock();
 
   _dev()->write( "Synch_thres_20", threshold);
 };
   
-uint32_t tts::FMMCard::getThreshold20() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::getThreshold20() {
 
   uint32_t threshold;  
   _dev()->read( "Synch_thres_20", &threshold);
   return threshold;
 };
   
-void tts::FMMCard::setThreshold10A(uint32_t threshold) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setThreshold10A(uint32_t threshold) {
 
   check_write_lock();
 
   _dev()->write( "Synch_thres_10A", threshold);
 };
   
-uint32_t tts::FMMCard::getThreshold10A() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::getThreshold10A() {
 
   uint32_t threshold;  
   _dev()->read( "Synch_thres_10A", &threshold);
   return threshold;
 };
   
-void tts::FMMCard::setThreshold10B(uint32_t threshold) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setThreshold10B(uint32_t threshold) {
 
   check_write_lock();
 
   _dev()->write( "Synch_thres_10B", threshold);
 };
   
-uint32_t tts::FMMCard::getThreshold10B() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::getThreshold10B() {
 
   uint32_t threshold;  
   _dev()->read( "Synch_thres_10B", &threshold);
@@ -247,9 +221,7 @@ uint32_t tts::FMMCard::getThreshold10B()
 };
   
 
-void tts::FMMCard::setConfig(tts::FMMConfiguration const& cfg) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setConfig(tts::FMMConfiguration const& cfg) {
 
   check_write_lock();
 
@@ -260,8 +232,7 @@ void tts::FMMCard::setConfig(tts::FMMConfiguration const& cfg)
   setThreshold10B( cfg.getThreshold10B() );
 };
 
-tts::FMMConfiguration tts::FMMCard::readConfig() 
-  throw (HAL::HardwareAccessException) {
+tts::FMMConfiguration tts::FMMCard::readConfig() {
 
   tts::FMMConfiguration cfg( isDualMode(),
 			     getMask(),
@@ -274,8 +245,7 @@ tts::FMMConfiguration tts::FMMCard::readConfig()
 
 
 
-bool tts::FMMCard::isSimuMode() 
-  throw (HAL::HardwareAccessException) {
+bool tts::FMMCard::isSimuMode() {
   
   uint32_t simu_mode;
   _dev()->read("Test_select", &simu_mode);
@@ -283,9 +253,7 @@ bool tts::FMMCard::isSimuMode()
   return (simu_mode & 0x1) == 0x1;
 }
 
-void tts::FMMCard::toggleSimuMode(bool simu_mode) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::toggleSimuMode(bool simu_mode) {
 
   check_write_lock();
 
@@ -301,8 +269,7 @@ void tts::FMMCard::toggleSimuMode(bool simu_mode)
   _ctrl_reg_semaphore.give();
 }
 
-bool tts::FMMCard::isDMAMode() 
-  throw (HAL::HardwareAccessException) {
+bool tts::FMMCard::isDMAMode() {
 
   uint32_t dma_mode;
   _dev()->read("History_mode", &dma_mode);
@@ -310,9 +277,7 @@ bool tts::FMMCard::isDMAMode()
   return (dma_mode & 0x1) == 0x1;
 }; 
 
-void tts::FMMCard::toggleDMAMode(bool dma_mode)
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::toggleDMAMode(bool dma_mode) {
 
   check_write_lock();
 
@@ -328,9 +293,7 @@ void tts::FMMCard::toggleDMAMode(bool dma_mode)
 
 };
 
-void tts::FMMCard::toggleTimeTagExtResetEnable(bool enabled) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::toggleTimeTagExtResetEnable(bool enabled) {
 
   check_write_lock();
   
@@ -345,8 +308,7 @@ void tts::FMMCard::toggleTimeTagExtResetEnable(bool enabled)
   _ctrl_reg_semaphore.give();
 };
 
-bool tts::FMMCard::timeTagExtResetEnabled() 
-  throw (HAL::HardwareAccessException) {
+bool tts::FMMCard::timeTagExtResetEnabled() {
   
   uint32_t enabled;
   _dev()->read("enable_timetag_reset", &enabled);
@@ -354,8 +316,7 @@ bool tts::FMMCard::timeTagExtResetEnabled()
   return (enabled & 0x1) == 0x1;
 };
 
-bool tts::FMMCard::isDualMode() 
-  throw (HAL::HardwareAccessException) {
+bool tts::FMMCard::isDualMode() {
 
   uint32_t dual_mode;
   _dev()->read("Dual_mode", &dual_mode);
@@ -363,9 +324,7 @@ bool tts::FMMCard::isDualMode()
   return (dual_mode & 0x1) == 0x1;
 }; 
 
-void tts::FMMCard::toggleDualMode(bool dual)
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::toggleDualMode(bool dual) {
 
   check_write_lock();
 
@@ -382,9 +341,7 @@ void tts::FMMCard::toggleDualMode(bool dual)
 }
 
 
-void tts::FMMCard::setLEDs(uint32_t led_setting) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setLEDs(uint32_t led_setting) {
 
   check_write_lock();
 
@@ -400,8 +357,7 @@ void tts::FMMCard::setLEDs(uint32_t led_setting)
 };
 
 
-tts::TTSState tts::FMMCard::readResultA() 
-  throw (HAL::HardwareAccessException) {
+tts::TTSState tts::FMMCard::readResultA() {
 
   uint32_t state;
   _dev()->read( "ResultA", &state);
@@ -409,8 +365,7 @@ tts::TTSState tts::FMMCard::readResultA()
   return tts::TTSState( (int) state );
 };
 
-tts::TTSState tts::FMMCard::readResultB() 
-  throw (HAL::HardwareAccessException) {
+tts::TTSState tts::FMMCard::readResultB() {
 
   uint32_t state;
   _dev()->read( "ResultB", &state);
@@ -419,8 +374,7 @@ tts::TTSState tts::FMMCard::readResultB()
 };
 
 
-uint32_t tts::FMMCard::readFuncA() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::readFuncA() {
 
   uint32_t func;
   _dev()->read( "FUNC_A", &func);
@@ -428,8 +382,7 @@ uint32_t tts::FMMCard::readFuncA()
   return (uint32_t) func;
 };
 
-uint32_t tts::FMMCard::readFuncB() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::readFuncB() {
 
   uint32_t func;
   _dev()->read( "FUNC_B", &func);
@@ -437,8 +390,7 @@ uint32_t tts::FMMCard::readFuncB()
   return (uint32_t) func;
 };
 
-std::vector<tts::TTSState> tts::FMMCard::getSimulatedInputStates() 
-  throw (HAL::HardwareAccessException) {
+std::vector<tts::TTSState> tts::FMMCard::getSimulatedInputStates() {
 
   uint32_t ready=0;
   uint32_t busy=0;
@@ -468,9 +420,7 @@ std::vector<tts::TTSState> tts::FMMCard::getSimulatedInputStates()
   return states;
 };
 
-std::vector<tts::TTSState> tts::FMMCard::readInputs() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+std::vector<tts::TTSState> tts::FMMCard::readInputs() {
 
   check_write_lock();
 
@@ -519,9 +469,7 @@ std::vector<tts::TTSState> tts::FMMCard::readInputs()
   return states;
 };
 
-void tts::FMMCard::setSimulatedInputStates(std::vector <tts::TTSState> const& states) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::setSimulatedInputStates(std::vector <tts::TTSState> const& states) {
 
   check_write_lock();
 
@@ -547,10 +495,7 @@ void tts::FMMCard::setSimulatedInputStates(std::vector <tts::TTSState> const& st
 };
 
 
-void tts::FMMCard::setSimulatedInputState(uint32_t channel, tts::TTSState const& state) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock,
-	 xcept::Exception) {
+void tts::FMMCard::setSimulatedInputState(uint32_t channel, tts::TTSState const& state) {
 
   if (channel >= 20) XCEPT_RAISE(xcept::Exception, "channel out of range");
 
@@ -585,9 +530,7 @@ void tts::FMMCard::setSimulatedInputState(uint32_t channel, tts::TTSState const&
 };
 
 
-void tts::FMMCard::enableTestOutputs(uint32_t test_output_enable) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::enableTestOutputs(uint32_t test_output_enable) {
 
   check_write_lock();
   _ctrl_reg_semaphore.take();
@@ -600,8 +543,7 @@ void tts::FMMCard::enableTestOutputs(uint32_t test_output_enable)
   _ctrl_reg_semaphore.give();
 }
 
-uint32_t tts::FMMCard::readTestOutputEnables() 
-  throw (HAL::HardwareAccessException) {
+uint32_t tts::FMMCard::readTestOutputEnables() {
   uint32_t val;
   _dev()->read("TestOutput_enable", &val);
 
@@ -609,10 +551,7 @@ uint32_t tts::FMMCard::readTestOutputEnables()
 }
 
 
-void tts::FMMCard::setTestOutputValue(uint32_t output_idx, tts::TTSState const& state ) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock,
-	 xcept::Exception) {
+void tts::FMMCard::setTestOutputValue(uint32_t output_idx, tts::TTSState const& state ) {
 
   check_write_lock();
 
@@ -624,8 +563,7 @@ void tts::FMMCard::setTestOutputValue(uint32_t output_idx, tts::TTSState const&
   _dev()->write(item.str(), (uint32_t) state);
 }
 
-tts::TTSState tts::FMMCard::readTestOutputValue(uint32_t output_idx) 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::TTSState tts::FMMCard::readTestOutputValue(uint32_t output_idx) {
 
   if (output_idx > 3) XCEPT_RAISE(xcept::Exception, "output_idx out of range");
 
@@ -638,8 +576,7 @@ tts::TTSState tts::FMMCard::readTestOutputValue(uint32_t output_idx)
   return tts::TTSState(state);
 }
 
-void tts::FMMCard::readHistoryItem(uint32_t addr, tts::FMMHistoryItem& hi) 
-  throw (HAL::HardwareAccessException) {
+void tts::FMMCard::readHistoryItem(uint32_t addr, tts::FMMHistoryItem& hi) {
 
   uint32_t hist[4];
   uint32_t val;
@@ -651,9 +588,7 @@ void tts::FMMCard::readHistoryItem(uint32_t addr, tts::FMMHistoryItem& hi)
   hi.set(hist);
 };
 
-void tts::FMMCard::clearHistoryMemory(uint32_t pattern) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::clearHistoryMemory(uint32_t pattern) {
 
   check_write_lock();
 
@@ -665,9 +600,7 @@ void tts::FMMCard::clearHistoryMemory(uint32_t pattern)
 }
 
 
-void tts::FMMCard::readDeadTimeCounters(std::vector <uint32_t>& counters) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::readDeadTimeCounters(std::vector <uint32_t>& counters) {
 
   _timers_semaphore.take();
   try {
@@ -688,9 +621,7 @@ void tts::FMMCard::readDeadTimeCounters(std::vector <uint32_t>& counters)
 
 }
 
-uint64_t tts::FMMCard::readTimeTag() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+uint64_t tts::FMMCard::readTimeTag() {
 
   uint64_t tt;
 
@@ -718,9 +649,7 @@ uint64_t tts::FMMCard::readTimeTag()
   return tt;
 }
 
-void tts::FMMCard::readDeadTimeCountersAndTimeTag(std::vector <uint32_t>& counters, uint64_t& tt) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::readDeadTimeCountersAndTimeTag(std::vector <uint32_t>& counters, uint64_t& tt) {
 
 
 
@@ -750,8 +679,7 @@ void tts::FMMCard::readDeadTimeCountersAndTimeTag(std::vector <uint32_t>& counte
 //--------------------------------------------------------------------------------
 
 
-void tts::FMMCard::doReadDeadTimeCounters(std::vector <uint32_t>& counters) 
-  throw (HAL::HardwareAccessException) {
+void tts::FMMCard::doReadDeadTimeCounters(std::vector <uint32_t>& counters) {
 
   counters.resize( NumCounters );
 
@@ -820,8 +748,7 @@ void tts::FMMCard::doReadDeadTimeCounters(std::vector <uint32_t>& counters)
 
 }
 
-uint64_t tts::FMMCard::doReadTimeTag() 
-  throw (HAL::HardwareAccessException) {
+uint64_t tts::FMMCard::doReadTimeTag() {
 
   uint64_t tt;
   uint32_t val;
@@ -840,9 +767,7 @@ uint64_t tts::FMMCard::doReadTimeTag()
   return tt;
 }
 
-void tts::FMMCard::freezeTimes() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::freezeTimes() {
 
   check_write_lock();
 
@@ -856,9 +781,7 @@ void tts::FMMCard::freezeTimes()
   _ctrl_reg_semaphore.give();
 }  
 
-void tts::FMMCard::unFreezeTimes() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMCard::unFreezeTimes() {
 
   check_write_lock();
   _ctrl_reg_semaphore.take();
diff --git a/tts/fmm/src/common/FMMCrate.cc b/tts/fmm/src/common/FMMCrate.cc
index 2fc971376..7b1e03ba8 100755
--- a/tts/fmm/src/common/FMMCrate.cc
+++ b/tts/fmm/src/common/FMMCrate.cc
@@ -29,8 +29,7 @@
 static const char* key_file = "/dev/xpci";
 static const uint32_t n_geoslots = 21;
 
-tts::FMMCrate::FMMCrate(bool dummy, char project_id) 
-  throw (HAL::HardwareAccessException, xcept::Exception)
+tts::FMMCrate::FMMCrate(bool dummy, char project_id)
   : _busadapter(0),
     _fmm_addresstable(0),
     _theFMMs(),
@@ -145,8 +144,7 @@ tts::FMMCrate::~FMMCrate() {
 }
 
 
-tts::FMMCard& tts::FMMCrate::getFMM( uint32_t id ) 
-  throw (xcept::Exception) {
+tts::FMMCard& tts::FMMCrate::getFMM( uint32_t id ) {
 
   if ( id >= (uint32_t) _theFMMs.size() )
     XCEPT_RAISE( xcept::Exception, "FMMCrate::getFMM: FMM with requested ID is not present.");
@@ -154,8 +152,7 @@ tts::FMMCard& tts::FMMCrate::getFMM( uint32_t id )
   return * (_theFMMs[id] );
 }
 
-tts::FMMCard& tts::FMMCrate::getFMMbySN( std::string const& sn ) 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::FMMCard& tts::FMMCrate::getFMMbySN( std::string const& sn ) {
     
   for (std::vector<tts::FMMCard*>::iterator it = _theFMMs.begin(); it!= _theFMMs.end(); ++it) {
     if ( (*it)->getSerialNumber() == sn ) 
@@ -166,8 +163,7 @@ tts::FMMCard& tts::FMMCrate::getFMMbySN( std::string const& sn )
   
 }
 
-tts::FMMCard& tts::FMMCrate::getFMMbyGeoSlot( uint32_t geoslot ) 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::FMMCard& tts::FMMCrate::getFMMbyGeoSlot( uint32_t geoslot ) {
 
   checkGeoSlotsUnique();
 
@@ -183,8 +179,7 @@ tts::FMMCard& tts::FMMCrate::getFMMbyGeoSlot( uint32_t geoslot )
   XCEPT_RAISE( xcept::Exception, msg.str() );
 }
 
-void tts::FMMCrate::checkGeoSlotsUnique() 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMCrate::checkGeoSlotsUnique() {
 
   // check that geoslots are unique to be sure that we are in a crate with proper backplane
   for (std::vector<tts::FMMCard*>::size_type id1=0; id1<numFMMs(); id1++) {
@@ -215,8 +210,7 @@ bool tts::FMMCrate::hasTD() {
   return (_td != 0);
 }
 
-tts::FMMTDCard& tts::FMMCrate::getTD() 
-  throw (xcept::Exception) {
+tts::FMMTDCard& tts::FMMCrate::getTD() {
 
   if (_td == 0)
     XCEPT_RAISE( xcept::Exception, "FMMCrate::getTD(): No Trigger Distributor in crate.");
diff --git a/tts/fmm/src/common/FMMDeadTimeMonitor.cc b/tts/fmm/src/common/FMMDeadTimeMonitor.cc
index aa25a16ad..1327a74a0 100755
--- a/tts/fmm/src/common/FMMDeadTimeMonitor.cc
+++ b/tts/fmm/src/common/FMMDeadTimeMonitor.cc
@@ -40,8 +40,7 @@ tts::FMMDeadTimeMonitor::~FMMDeadTimeMonitor() {
 };
 
 
-void tts::FMMDeadTimeMonitor::start( bool resetHW ) 
-  throw (HAL::HardwareAccessException) {
+void tts::FMMDeadTimeMonitor::start( bool resetHW ) {
 
   _update_semaphore.take();
 
@@ -57,8 +56,7 @@ void tts::FMMDeadTimeMonitor::start( bool resetHW )
   _update_semaphore.give();
 }
 
-void tts::FMMDeadTimeMonitor::stop() 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMDeadTimeMonitor::stop() {
 
   _update_semaphore.take();
 
@@ -76,8 +74,7 @@ void tts::FMMDeadTimeMonitor::stop()
 
 }
 
-void tts::FMMDeadTimeMonitor::doReset( bool resetHW ) 
-  throw (HAL::HardwareAccessException) {
+void tts::FMMDeadTimeMonitor::doReset( bool resetHW ) {
 
   tts::FMMTimer timer;
   _t_reset = _t_lastread = _t_lastread_old = timer.getMicroTime();
@@ -98,8 +95,7 @@ void tts::FMMDeadTimeMonitor::doReset( bool resetHW )
 };
 
 
-void tts::FMMDeadTimeMonitor::updateCounters() 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMDeadTimeMonitor::updateCounters() {
 
   _update_semaphore.take();
 
@@ -114,8 +110,7 @@ void tts::FMMDeadTimeMonitor::updateCounters()
 }
 
 
-void tts::FMMDeadTimeMonitor::readCounters(std::vector<tts::FMMDeadTime> & counters, uint64_t& timetag, bool doUpdate)
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMDeadTimeMonitor::readCounters(std::vector<tts::FMMDeadTime> & counters, uint64_t& timetag, bool doUpdate) {
   
   _update_semaphore.take();
 
@@ -138,8 +133,7 @@ void tts::FMMDeadTimeMonitor::readCounters(std::vector<tts::FMMDeadTime> & count
 }
 
 
-void tts::FMMDeadTimeMonitor::readDeadTimeFractions( std::vector<double> & deadTimeFractions, bool doUpdate)   
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMDeadTimeMonitor::readDeadTimeFractions( std::vector<double> & deadTimeFractions, bool doUpdate) {
 
   _update_semaphore.take();
 
@@ -171,8 +165,7 @@ void tts::FMMDeadTimeMonitor::readDeadTimeFractions( std::vector<double> & deadT
 
 
 
-void tts::FMMDeadTimeMonitor::readDeadTimeFractionsLastInterval( std::vector<double> & deadTimeFractions)   
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMDeadTimeMonitor::readDeadTimeFractionsLastInterval( std::vector<double> & deadTimeFractions) {
 
   _update_semaphore.take();
 
@@ -199,8 +192,7 @@ void tts::FMMDeadTimeMonitor::unlock() {
 
 
 
-void tts::FMMDeadTimeMonitor::doUpdateCounters() 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+void tts::FMMDeadTimeMonitor::doUpdateCounters() {
 
   if (!_running) return;
 
diff --git a/tts/fmm/src/common/version.cc b/tts/fmm/src/common/version.cc
index 24933e65a..93668ab50 100755
--- a/tts/fmm/src/common/version.cc
+++ b/tts/fmm/src/common/version.cc
@@ -25,7 +25,7 @@
 
 GETPACKAGEINFO(ttsfmm)
 
-void ttsfmm::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsfmm::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(ttsfmmtd);  
 	CHECKDEPENDENCY(ttscpcibase);  
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/FMMController.hh b/tts/fmmcontroller/include/tts/fmmcontroller/FMMController.hh
index 63c83fb20..8b02be737 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/FMMController.hh
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/FMMController.hh
@@ -60,58 +60,48 @@ namespace tts {
   public:
     XDAQ_INSTANTIATOR();
 	
-    FMMController(xdaq::ApplicationStub * s) 
-      throw (xdaq::exception::Exception);
+    FMMController(xdaq::ApplicationStub * s);
     virtual ~FMMController();
 	
 
   private:
     /// callback function to proccess a SOAP message to change to a different state
-    xoap::MessageReference changeStateCommandHandler (xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    xoap::MessageReference changeStateCommandHandler (xoap::MessageReference msg);
 
     /// find a mask in the mask string passed by Run Control
-    uint32_t findMask(std::string maskstr, uint32_t geoslot) 
-      throw ( toolbox::fsm::exception::Exception);
+    uint32_t findMask(std::string maskstr, uint32_t geoslot);
 
     /// callback for state machine configure action
     ///
     /// configures the FMM using the current exported parameters
-    void ConfigureAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void ConfigureAction(toolbox::Event::Reference e);
 
     /// callback for state machine enable action
     ///
     /// resets the dead time counters of the FMM
-    void EnableAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void EnableAction(toolbox::Event::Reference e);
 
     /// callback for state machine disable action
     ///
     /// 
-    void DisableAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void DisableAction(toolbox::Event::Reference e);
 
     /// callback for state machine halt action
     ///
     /// does nothing special ...
-    void HaltAction(toolbox::Event::Reference e) 
-      throw(toolbox::fsm::exception::Exception);
+    void HaltAction(toolbox::Event::Reference e);
 
     /// callback for state machine transition to failed state
     ///
     /// this function logs the exception to the logger
-    void transitionToFailed(toolbox::Event::Reference e ) 
-      throw (toolbox::fsm::exception::Exception);
+    void transitionToFailed(toolbox::Event::Reference e );
 
     /// callback when a new state is entered
     /// 
-    void stateChanged(toolbox::fsm::FiniteStateMachine & fsm )
-      throw (toolbox::fsm::exception::Exception);
+    void stateChanged(toolbox::fsm::FiniteStateMachine & fsm );
 
     /// display the default web page
-    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out ) 
-      throw (xgi::exception::Exception);
+    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out );
 
     /// action to be called in workloop
     bool autoUpdateAction(toolbox::task::WorkLoop* wl);
@@ -120,16 +110,13 @@ namespace tts {
     bool monitorHistoryAction(toolbox::task::WorkLoop* wl);
 
     /// callback function to process SOAP message for interconnection test
-    xoap::MessageReference readInputStates(xoap::MessageReference msg)   
-      throw (xoap::exception::Exception);
+    xoap::MessageReference readInputStates(xoap::MessageReference msg);
 
     /// callback function to process SOAP message for interconnection test
-    xoap::MessageReference resetHistory(xoap::MessageReference msg)   
-      throw (xoap::exception::Exception);
+    xoap::MessageReference resetHistory(xoap::MessageReference msg);
 
     /// callback function to process SOAP message for interconnection test
-    xoap::MessageReference checkInputSequence(xoap::MessageReference msg)   
-      throw (xoap::exception::Exception);
+    xoap::MessageReference checkInputSequence(xoap::MessageReference msg);
 
 
   private:
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/FMMHistoryMonitor.hh b/tts/fmmcontroller/include/tts/fmmcontroller/FMMHistoryMonitor.hh
index 9207044b5..e7b7ebac7 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/FMMHistoryMonitor.hh
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/FMMHistoryMonitor.hh
@@ -72,15 +72,10 @@ namespace tts {
     ///
     /// @param resetHW. if true, reset the counters;
     ///        if false counters have to be reset after calling start
-    void start( bool resetHW )
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock,
-	     xcept::Exception);
+    void start( bool resetHW );
 
     /// stop periodically monitoring the history memory
-    void stop()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void stop();
 
     /// update the history
     /// 
@@ -99,9 +94,7 @@ namespace tts {
     /// least every 107 seconds in order to be able to determine where
     /// the history memory has been overwritten.
     /// 
-    long update()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    long update();
 
     /// register a new consumer
     void registerConsumer( tts::FMMHistoryConsumer* consumer );
@@ -117,9 +110,7 @@ namespace tts {
     enum { FMMWrapCounterLength = 32768 };
 
     /// the real update job
-    long doUpdate()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    long doUpdate();
 
     /// check if the maximum time between updates has been exceeded
     void checkElapsedTime(uint64_t t_now, uint64_t t_last);
@@ -132,9 +123,7 @@ namespace tts {
 			bool duringReadout);
 
     /// update the time counter
-    void updateTimeCounter() 
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void updateTimeCounter();
 
     /// update the history
     ///
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/FMMInterconnectionTestHandler.hh b/tts/fmmcontroller/include/tts/fmmcontroller/FMMInterconnectionTestHandler.hh
index 1ca046a9d..deb3ac73a 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/FMMInterconnectionTestHandler.hh
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/FMMInterconnectionTestHandler.hh
@@ -43,16 +43,13 @@ namespace tts {
     ~FMMInterconnectionTestHandler();
 
     /// read the current input states
-    xoap::MessageReference  readInputStates(xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    xoap::MessageReference  readInputStates(xoap::MessageReference msg);
 
     /// reset the history memory
-    xoap::MessageReference  resetHistory(xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    xoap::MessageReference  resetHistory(xoap::MessageReference msg);
 
     /// read the current input states
-    xoap::MessageReference  checkInputSequence(xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    xoap::MessageReference  checkInputSequence(xoap::MessageReference msg);
   private:
     xdata::Vector<xdata::Bag<tts::FMMParameters> >& _config;
     tts::FMMCrate* _fmmcrate;
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/FMMMonitor.hh b/tts/fmmcontroller/include/tts/fmmcontroller/FMMMonitor.hh
index 8f5aaa06e..cb8c976a3 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/FMMMonitor.hh
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/FMMMonitor.hh
@@ -80,13 +80,11 @@ namespace tts {
     void setRunNumber(uint32_t runNumber);
 
     /// fire ItemGroupRetrieve on all infospaces in order to push monitoring data
-    void pushAllInfoSpaces()
-      throw (xcept::Exception);
+    void pushAllInfoSpaces();
 
 
   private:
-    void updateAllInfoSpaces()
-      throw (xcept::Exception);
+    void updateAllInfoSpaces();
 
     void lockAllInfoSpaces();
     void unLockAllInfoSpaces();
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/FMMWebInterface.hh b/tts/fmmcontroller/include/tts/fmmcontroller/FMMWebInterface.hh
index aad834861..413ca0b2c 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/FMMWebInterface.hh
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/FMMWebInterface.hh
@@ -58,16 +58,13 @@ namespace tts {
     ~FMMWebInterface();
 
     /// display the default web page
-    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out, std::string const& statename ) 
-      throw (xgi::exception::Exception);
+    void displayDefaultWebPage(xgi::Input * in, xgi::Output * out, std::string const& statename );
 
 
   private:
-    std::string formatTableEntries(std::vector<std::string> entries, std::vector<tts::TTSState> states, uint32_t mask, bool in_config)
-      throw (xgi::exception::Exception);
+    std::string formatTableEntries(std::vector<std::string> entries, std::vector<tts::TTSState> states, uint32_t mask, bool in_config);
 
-    std::string formatStates(std::vector<tts::TTSState> states, uint32_t mask, bool in_config)
-      throw (xgi::exception::Exception);
+    std::string formatStates(std::vector<tts::TTSState> states, uint32_t mask, bool in_config);
 
     std::string formatLabelsSubRow(std::string const& label,
 				   std::string const& inputLabels,
@@ -75,8 +72,7 @@ namespace tts {
 				   std::vector<tts::TTSState> istates,
 				   std::vector<tts::TTSState> ostates,
 				   uint32_t mask, bool in_config,
-				   uint32_t igeoslot)
-      throw (xgi::exception::Exception);
+				   uint32_t igeoslot);
 
     xdata::Vector<xdata::Bag<tts::FMMParameters> >& _config;
     tts::FMMCrate* _fmmcrate;
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/SOAPUtility.hh b/tts/fmmcontroller/include/tts/fmmcontroller/SOAPUtility.hh
index 7aad54dc1..692d6f00b 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/SOAPUtility.hh
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/SOAPUtility.hh
@@ -28,16 +28,14 @@ namespace tts {
     /// The command is the first element tag in the SOAP Body
     ///
     /// returns the command std::string
-    static std::string extractSOAPCommand(xoap::MessageReference msg) 
-      throw (xoap::exception::Exception);
+    static std::string extractSOAPCommand(xoap::MessageReference msg);
 
     /// creates a SOAP response
     ///
     /// @param response is the the name of the response element
     /// @param state is the state passed as an sttribute in the in the response elements state child element
     static xoap::MessageReference createSOAPResponse(std::string const& response, 
-						     std::string const& state)
-      throw (xoap::exception::Exception);
+						     std::string const& state);
   };
 
 }
diff --git a/tts/fmmcontroller/include/tts/fmmcontroller/version.h b/tts/fmmcontroller/include/tts/fmmcontroller/version.h
index 111e08d8b..f2992e6b6 100755
--- a/tts/fmmcontroller/include/tts/fmmcontroller/version.h
+++ b/tts/fmmcontroller/include/tts/fmmcontroller/version.h
@@ -43,7 +43,7 @@ namespace ttsfmmcontroller
 	const std::string summary = "ttsfmmcontroller";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/fmmcontroller/src/common/FMMController.cc b/tts/fmmcontroller/src/common/FMMController.cc
index 9c531b880..2b42e7951 100755
--- a/tts/fmmcontroller/src/common/FMMController.cc
+++ b/tts/fmmcontroller/src/common/FMMController.cc
@@ -52,14 +52,14 @@
 
 #include <sstream>
 #include <unistd.h>
+#include <chrono>
+#include <thread>
 
-#include "log4cplus/helpers/sleep.h"
 
 
 XDAQ_INSTANTIATOR_IMPL(tts::FMMController);
 
 tts::FMMController::FMMController(xdaq::ApplicationStub * s)
-throw (xdaq::exception::Exception)
 : xdaq::WebApplication(s),
 _runNumber(0),
 _useTriggerDistributor(false),
@@ -194,14 +194,12 @@ tts::FMMController::~FMMController() {
 		delete _fmmcrate;
 }
 
-void tts::FMMController::displayDefaultWebPage(xgi::Input * in, xgi::Output * out )
-throw (xgi::exception::Exception) {
+void tts::FMMController::displayDefaultWebPage(xgi::Input * in, xgi::Output * out ) {
 
 	_wi->displayDefaultWebPage( in, out, _stateName);
 }
 
-xoap::MessageReference tts::FMMController::changeStateCommandHandler (xoap::MessageReference msg)
-throw (xoap::exception::Exception) {
+xoap::MessageReference tts::FMMController::changeStateCommandHandler (xoap::MessageReference msg) {
 
 	std::string command = SOAPUtility::extractSOAPCommand( msg );
 
@@ -219,8 +217,7 @@ throw (xoap::exception::Exception) {
 	return SOAPUtility::createSOAPResponse( command + "Response", _stateName);
 }
 
-uint32_t tts::FMMController::findMask(std::string maskstr, uint32_t geoslot)
-throw ( toolbox::fsm::exception::Exception) {
+uint32_t tts::FMMController::findMask(std::string maskstr, uint32_t geoslot) {
 
 	toolbox::StringTokenizer tokenizer( maskstr, ";" );
 
@@ -264,8 +261,7 @@ throw ( toolbox::fsm::exception::Exception) {
 
 
 
-void tts::FMMController::ConfigureAction(toolbox::Event::Reference e)
-throw(toolbox::fsm::exception::Exception) {
+void tts::FMMController::ConfigureAction(toolbox::Event::Reference e) {
 
 	LOG4CPLUS_INFO(getApplicationLogger(), "configuring FMMs ...");
 
@@ -450,7 +446,7 @@ throw(toolbox::fsm::exception::Exception) {
 				  _mons[sn]->setStateName(_stateName);
 				}
 			}
-			catch (toolbox::fsm::exception::Exception) {
+			catch (toolbox::fsm::exception::Exception&) {
 				throw; // rethrow if exception already has correct type
 			}
 			catch (xcept::Exception& e) {
@@ -504,7 +500,7 @@ throw(toolbox::fsm::exception::Exception) {
 		_wl->activate();
 
 	}
-	catch (toolbox::fsm::exception::Exception) {
+	catch (toolbox::fsm::exception::Exception&) {
 		throw; // rethrow if exception already has correct type
 	}
 	catch (xcept::Exception& e) {
@@ -513,8 +509,7 @@ throw(toolbox::fsm::exception::Exception) {
 }
 
 // here we reset some counters
-void tts::FMMController::EnableAction(toolbox::Event::Reference e)
-throw(toolbox::fsm::exception::Exception) {
+void tts::FMMController::EnableAction(toolbox::Event::Reference e) {
 
 
 
@@ -601,7 +596,7 @@ throw(toolbox::fsm::exception::Exception) {
 		_wl->activate();
 
 	}
-	catch (toolbox::fsm::exception::Exception) {
+	catch (toolbox::fsm::exception::Exception&) {
 		throw; // rethrow if exception already has correct type
 	}
 	catch (xcept::Exception& e) {
@@ -609,8 +604,7 @@ throw(toolbox::fsm::exception::Exception) {
 	}
 }
 
-void tts::FMMController::HaltAction(toolbox::Event::Reference e)
-throw(toolbox::fsm::exception::Exception) {
+void tts::FMMController::HaltAction(toolbox::Event::Reference e) {
 
 	if (_fsm.getCurrentState() == 'H')
 		return; // Halting from halted state is supported but there is nothing to do
@@ -703,7 +697,7 @@ throw(toolbox::fsm::exception::Exception) {
 
 
 	}
-	catch (toolbox::fsm::exception::Exception) {
+	catch (toolbox::fsm::exception::Exception&) {
 		throw; // rethrow if exception already has correct type
 	}
 	catch (xcept::Exception& e) {
@@ -713,8 +707,7 @@ throw(toolbox::fsm::exception::Exception) {
 }
 
 
-void tts::FMMController::DisableAction(toolbox::Event::Reference e)
-throw(toolbox::fsm::exception::Exception) {
+void tts::FMMController::DisableAction(toolbox::Event::Reference e) {
 
 	LOG4CPLUS_INFO(getApplicationLogger(), "disabling the FMMs ...");
 	try {
@@ -764,7 +757,7 @@ throw(toolbox::fsm::exception::Exception) {
 		if ( _useTriggerDistributor && _fmmcrate->hasTD() && _fmmcrate->getTD().haveWriteLock() )
 			_fmmcrate->getTD().releaseWriteLock();
 	}
-	catch (toolbox::fsm::exception::Exception) {
+	catch (toolbox::fsm::exception::Exception&) {
 		throw; // rethrow if exception already has correct type
 	}
 	catch (xcept::Exception& e) {
@@ -775,8 +768,7 @@ throw(toolbox::fsm::exception::Exception) {
 
 
 // called when a transition throws an exception ...
-void tts::FMMController::transitionToFailed (toolbox::Event::Reference e)
-throw (toolbox::fsm::exception::Exception) {
+void tts::FMMController::transitionToFailed (toolbox::Event::Reference e) {
 
 	toolbox::fsm::FailedEvent & fe = dynamic_cast<toolbox::fsm::FailedEvent&>(*e);
 
@@ -834,8 +826,7 @@ throw (toolbox::fsm::exception::Exception) {
 }
 
 // called after every state change
-void tts::FMMController::stateChanged (toolbox::fsm::FiniteStateMachine & fsm)
-throw (toolbox::fsm::exception::Exception) {
+void tts::FMMController::stateChanged (toolbox::fsm::FiniteStateMachine & fsm) {
 
 	_stateName = fsm.getStateName (fsm.getCurrentState());
 
@@ -849,8 +840,7 @@ throw (toolbox::fsm::exception::Exception) {
 
 
 
-xoap::MessageReference  tts::FMMController::readInputStates(xoap::MessageReference msg)
-throw (xoap::exception::Exception) {
+xoap::MessageReference  tts::FMMController::readInputStates(xoap::MessageReference msg) {
 
 	if (_stateName!="Ready")
 		XCEPT_RAISE(xoap::exception::Exception, "readInputStates command can only be used in Configured(=Ready) state.");
@@ -858,8 +848,7 @@ throw (xoap::exception::Exception) {
 	return _ictHandler->readInputStates( msg );
 }
 
-xoap::MessageReference  tts::FMMController::resetHistory(xoap::MessageReference msg)
-throw (xoap::exception::Exception) {
+xoap::MessageReference  tts::FMMController::resetHistory(xoap::MessageReference msg) {
 
 	if (_stateName!="Ready")
 		XCEPT_RAISE(xoap::exception::Exception, "resetHistory command can only be used in Configured(=Ready) state.");
@@ -867,8 +856,7 @@ throw (xoap::exception::Exception) {
 	return _ictHandler->resetHistory( msg );
 }
 
-xoap::MessageReference  tts::FMMController::checkInputSequence(xoap::MessageReference msg)
-throw (xoap::exception::Exception) {
+xoap::MessageReference  tts::FMMController::checkInputSequence(xoap::MessageReference msg) {
 
 	if (_stateName!="Ready")
 		XCEPT_RAISE(xoap::exception::Exception, "checkInputSequence command can only be used in Configured(=Ready) state.");
@@ -933,7 +921,7 @@ bool tts::FMMController::autoUpdateAction(toolbox::task::WorkLoop* wl) {
 
 	}
 
-	log4cplus::helpers::sleepmillis(100);
+	std::this_thread::sleep_for(std::chrono::milliseconds(100));
 
 	// instead of sleeping for 1s, we sleep 10 times for 100 ms.
 	// this results in about 1.1s of sleeping time.
@@ -962,7 +950,8 @@ bool tts::FMMController::monitorHistoryAction(toolbox::task::WorkLoop* wl) {
 
 
 	if ( (n_read == 0l) && (_histoyMonitorSleepMilliSeconds.value_ != 0)) {
-	  log4cplus::helpers::sleepmillis(_histoyMonitorSleepMilliSeconds);
+
+	  std::this_thread::sleep_for(std::chrono::milliseconds(_histoyMonitorSleepMilliSeconds));
 	}
 
 	return true; // go on immediately
diff --git a/tts/fmmcontroller/src/common/FMMHistoryMonitor.cc b/tts/fmmcontroller/src/common/FMMHistoryMonitor.cc
index a261b35ff..cbfe1e96f 100755
--- a/tts/fmmcontroller/src/common/FMMHistoryMonitor.cc
+++ b/tts/fmmcontroller/src/common/FMMHistoryMonitor.cc
@@ -56,10 +56,7 @@ tts::FMMHistoryMonitor::~FMMHistoryMonitor() {
 };
 
 
-void tts::FMMHistoryMonitor::start( bool resetHW ) 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock,
-	 xcept::Exception) {
+void tts::FMMHistoryMonitor::start( bool resetHW ) {
 
   if (_selfUpdate && _wl->isActive())
     XCEPT_RAISE(xcept::Exception, "tts::FMMHistoryMonitor::startMonitor: monitor is already running");
@@ -96,9 +93,7 @@ void tts::FMMHistoryMonitor::start( bool resetHW )
   
 };
 
-void tts::FMMHistoryMonitor::stop()   
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMHistoryMonitor::stop() {
 
   if (_selfUpdate)
     _wl->cancel();
@@ -124,9 +119,7 @@ void tts::FMMHistoryMonitor::stop()
 };
 
 
-long tts::FMMHistoryMonitor::update() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+long tts::FMMHistoryMonitor::update() {
 
   long n_read=0l;
   _deque_semaphore.take();
@@ -144,9 +137,7 @@ long tts::FMMHistoryMonitor::update()
   return n_read;
 }
 
-long tts::FMMHistoryMonitor::doUpdate()     
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+long tts::FMMHistoryMonitor::doUpdate() {
 
   uint64_t t_before = tts::FMMTimer::getMicroTime();
   std::pair<uint32_t, uint32_t> current_wradd = _card.readHistoryAddressAndWrapCount();
@@ -256,9 +247,7 @@ void tts::FMMHistoryMonitor::checkOverwrite(uint32_t newAddress,
 
 } 
 
-void tts::FMMHistoryMonitor::updateTimeCounter() 
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMHistoryMonitor::updateTimeCounter() {
 
   //
   // read and extend current time tag 
diff --git a/tts/fmmcontroller/src/common/FMMInterconnectionTestHandler.cc b/tts/fmmcontroller/src/common/FMMInterconnectionTestHandler.cc
index 7a06784b0..283bc681e 100755
--- a/tts/fmmcontroller/src/common/FMMInterconnectionTestHandler.cc
+++ b/tts/fmmcontroller/src/common/FMMInterconnectionTestHandler.cc
@@ -72,8 +72,7 @@ public:
 
 
 // helper functions at file scope to parse SOAP Command
-static void parseReadInputStatesCommand( xoap::MessageReference msg, std::string* geoslotRange, std::string* ioRange) 
-throw (xoap::exception::Exception) {
+static void parseReadInputStatesCommand( xoap::MessageReference msg, std::string* geoslotRange, std::string* ioRange) {
 
 	xoap::SOAPPart part = msg->getSOAPPart();
 	xoap::SOAPEnvelope env = part.getEnvelope();
@@ -103,8 +102,7 @@ throw (xoap::exception::Exception) {
 
 
 // helper functions at file scope to parse SOAP Command
-static void parseResetHistoryCommand( xoap::MessageReference msg, std::string* geoslotRange) 
-throw (xoap::exception::Exception) {
+static void parseResetHistoryCommand( xoap::MessageReference msg, std::string* geoslotRange) {
 
 	xoap::SOAPPart part = msg->getSOAPPart();
 	xoap::SOAPEnvelope env = part.getEnvelope();
@@ -134,8 +132,7 @@ static void parseCheckInputSequenceCommand( xoap::MessageReference msg,
 		std::string* sequence,
 		uint32_t* reps,
 		bool* reset,
-		bool* returnSequence) 
-throw (xoap::exception::Exception) {
+		bool* returnSequence) {
 
 	xoap::SOAPPart part = msg->getSOAPPart();
 	xoap::SOAPEnvelope env = part.getEnvelope();
@@ -199,8 +196,7 @@ throw (xoap::exception::Exception) {
 
 
 // helper functions at file scope to generate SOAP reply
-static xoap::MessageReference makeInputStateReply( xdata::Vector< xdata::Bag<StateBag> > & results )
-throw (xoap::exception::Exception) {
+static xoap::MessageReference makeInputStateReply( xdata::Vector< xdata::Bag<StateBag> > & results ) {
 
 	// create a reply message
 	xoap::MessageReference reply = xoap::createMessage();
@@ -218,8 +214,7 @@ throw (xoap::exception::Exception) {
 
 
 // helper functions at file scope to generate SOAP reply
-static xoap::MessageReference makeCheckSequenceReply( xdata::Vector< xdata::Bag<FoundBag> > & results )
-throw (xoap::exception::Exception) {
+static xoap::MessageReference makeCheckSequenceReply( xdata::Vector< xdata::Bag<FoundBag> > & results ) {
 
 	// create a reply message
 	xoap::MessageReference reply = xoap::createMessage();
@@ -237,8 +232,7 @@ throw (xoap::exception::Exception) {
 
 
 // helper functions at file scope to find if a number is in a range
-static bool inRange (uint32_t index, std::string const& range) 
-throw (xcept::Exception) {
+static bool inRange (uint32_t index, std::string const& range) {
 
 	std::stringstream ss; ss << index;
 
@@ -288,8 +282,7 @@ tts::FMMInterconnectionTestHandler::~FMMInterconnectionTestHandler() {
 };
 
 
-xoap::MessageReference tts::FMMInterconnectionTestHandler::resetHistory(xoap::MessageReference msg) 
-throw (xoap::exception::Exception) {
+xoap::MessageReference tts::FMMInterconnectionTestHandler::resetHistory(xoap::MessageReference msg) {
 
 	std::string geoslotRange;
 	parseResetHistoryCommand( msg, &geoslotRange);
@@ -329,8 +322,7 @@ throw (xoap::exception::Exception) {
 
 
 
-xoap::MessageReference tts::FMMInterconnectionTestHandler::readInputStates(xoap::MessageReference msg) 
-throw (xoap::exception::Exception) {
+xoap::MessageReference tts::FMMInterconnectionTestHandler::readInputStates(xoap::MessageReference msg) {
 
 	std::string geoslotRange;
 	std::string ioRange;
@@ -377,8 +369,7 @@ throw (xoap::exception::Exception) {
 
 
 
-xoap::MessageReference tts::FMMInterconnectionTestHandler::checkInputSequence(xoap::MessageReference msg) 
-throw (xoap::exception::Exception) {
+xoap::MessageReference tts::FMMInterconnectionTestHandler::checkInputSequence(xoap::MessageReference msg) {
 
 	std::string geoslotRange;
 	std::string ioRange;
diff --git a/tts/fmmcontroller/src/common/FMMMonitor.cc b/tts/fmmcontroller/src/common/FMMMonitor.cc
index 2d7549c66..57c704dc4 100755
--- a/tts/fmmcontroller/src/common/FMMMonitor.cc
+++ b/tts/fmmcontroller/src/common/FMMMonitor.cc
@@ -250,8 +250,7 @@ void tts::FMMMonitor::start() {
 }
 
 
-void tts::FMMMonitor::updateAllInfoSpaces()
-   throw (xcept::Exception) {
+void tts::FMMMonitor::updateAllInfoSpaces() {
 
    try {
 
@@ -445,8 +444,7 @@ void tts::FMMMonitor::unLockAllInfoSpaces() {
 }
 
 
-void tts::FMMMonitor::pushAllInfoSpaces()
-  throw (xcept::Exception) {
+void tts::FMMMonitor::pushAllInfoSpaces() {
 
   std::list<std::string> names;
   uint64_t t0 = tts::FMMTimer::getMicroTime();
diff --git a/tts/fmmcontroller/src/common/FMMWebInterface.cc b/tts/fmmcontroller/src/common/FMMWebInterface.cc
index 283471ea2..d929f3283 100755
--- a/tts/fmmcontroller/src/common/FMMWebInterface.cc
+++ b/tts/fmmcontroller/src/common/FMMWebInterface.cc
@@ -47,8 +47,7 @@ tts::FMMWebInterface::FMMWebInterface(xdaq::Application* owner,
 		}
 
 		void tts::FMMWebInterface::displayDefaultWebPage(xgi::Input * in, xgi::Output * out, 
-				std::string const& statename) 
-		throw (xgi::exception::Exception) {
+				std::string const& statename) {
 
 			/// check if we have parameters
 			bool formUsed = false;
@@ -523,8 +522,7 @@ tts::FMMWebInterface::FMMWebInterface(xdaq::Application* owner,
 		std::string tts::FMMWebInterface::formatTableEntries(std::vector<std::string> entries, 
 				std::vector<tts::TTSState> states, 
 				uint32_t mask, 
-				bool in_config) 
-		throw (xgi::exception::Exception) {
+				bool in_config) {
 
 			std::stringstream ss;
 
@@ -556,8 +554,7 @@ tts::FMMWebInterface::FMMWebInterface(xdaq::Application* owner,
 
 
 
-		std::string tts::FMMWebInterface::formatStates(std::vector<tts::TTSState> states, uint32_t mask, bool in_config) 
-		throw (xgi::exception::Exception) {
+		std::string tts::FMMWebInterface::formatStates(std::vector<tts::TTSState> states, uint32_t mask, bool in_config) {
 
 			std::vector<std::string> stateNames(states.size());
 			for (uint32_t i=0; i<states.size(); ++i)
@@ -575,9 +572,7 @@ tts::FMMWebInterface::FMMWebInterface(xdaq::Application* owner,
 				std::vector<tts::TTSState> istates,
 				std::vector<tts::TTSState> ostates,
 				uint32_t mask, bool in_config,
-				uint32_t igeoslot)
-		
-		throw (xgi::exception::Exception) {
+				uint32_t igeoslot) {
 
 			std::stringstream ss;
 
diff --git a/tts/fmmcontroller/src/common/SOAPUtility.cc b/tts/fmmcontroller/src/common/SOAPUtility.cc
index abeec29dd..271f5a6fc 100755
--- a/tts/fmmcontroller/src/common/SOAPUtility.cc
+++ b/tts/fmmcontroller/src/common/SOAPUtility.cc
@@ -21,8 +21,7 @@
 
 #include "xoap/exception/Exception.h"
 
-std::string tts::SOAPUtility::extractSOAPCommand(xoap::MessageReference msg) 
-  throw (xoap::exception::Exception) {
+std::string tts::SOAPUtility::extractSOAPCommand(xoap::MessageReference msg) {
 
   DOMNode* node = msg->getSOAPPart().getEnvelope().getBody().getDOMNode();
   DOMNodeList* bodyList = node->getChildNodes();
@@ -41,8 +40,7 @@ std::string tts::SOAPUtility::extractSOAPCommand(xoap::MessageReference msg)
 }
 
 xoap::MessageReference tts::SOAPUtility::createSOAPResponse(std::string const& response, 
-							  std::string const& state) 
-  throw (xoap::exception::Exception) {
+							  std::string const& state) {
 
   // create a reply message
   xoap::MessageReference reply = xoap::createMessage();
diff --git a/tts/fmmcontroller/src/common/version.cc b/tts/fmmcontroller/src/common/version.cc
index 3918db981..a25039f32 100755
--- a/tts/fmmcontroller/src/common/version.cc
+++ b/tts/fmmcontroller/src/common/version.cc
@@ -28,7 +28,7 @@
 
 GETPACKAGEINFO(ttsfmmcontroller)
 
-void ttsfmmcontroller::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsfmmcontroller::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(ttsfmm);  
 	CHECKDEPENDENCY(ttsfmmtd);  
diff --git a/tts/fmmdbi/Makefile b/tts/fmmdbi/Makefile
index e75fb56e8..64869a95b 100755
--- a/tts/fmmdbi/Makefile
+++ b/tts/fmmdbi/Makefile
@@ -31,11 +31,11 @@ Sources=\
 	version.cc \
 	FMMOracleDBI.cc
 
-#allow user to override if needed
-#ORACLE_HOME = /afs/cern.ch/project/oracle/linux/10103/
+#allow user to override if needed ORACLE_HOME = ../../extern/oracle/x86_64_centos7
+
 
 ifdef ORACLE_HOME
-ORACLE_INCLUDE_PREFIX=${ORACLE_HOME}/rdbms/demo/ ${ORACLE_HOME}/rdbms/public/
+ORACLE_INCLUDE_PREFIX=${ORACLE_HOME}/include ${ORACLE_HOME}/rdbms/demo/ ${ORACLE_HOME}/rdbms/public/
 ORACLE_LIB_PREFIX=${ORACLE_HOME}/lib
 endif
 
@@ -72,7 +72,9 @@ TestExecutables= insert_board_log.cc
 
 TestLibraries= \
 	config \
-	occi clntsh
+	toolbox asyncresolv uuid mimetic log4cplus numa \
+	xcept \
+	occi clntsh clntshcore ons nnz12
 
 
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/Makefile.rules
diff --git a/tts/fmmdbi/include/tts/fmmdbi/version.h b/tts/fmmdbi/include/tts/fmmdbi/version.h
index 88fcbd7f9..1574ae303 100755
--- a/tts/fmmdbi/include/tts/fmmdbi/version.h
+++ b/tts/fmmdbi/include/tts/fmmdbi/version.h
@@ -43,7 +43,7 @@ namespace ttsfmmdbi
 	const std::string summary = "ttsfmmdbi";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/fmmdbi/src/common/version.cc b/tts/fmmdbi/src/common/version.cc
index 8a4393f94..92a0510f7 100755
--- a/tts/fmmdbi/src/common/version.cc
+++ b/tts/fmmdbi/src/common/version.cc
@@ -15,7 +15,7 @@
 
 GETPACKAGEINFO(ttsfmmdbi)
 
-void ttsfmmdbi::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsfmmdbi::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 }
diff --git a/tts/fmmtd/include/tts/fmmtd/FMMTDCard.hh b/tts/fmmtd/include/tts/fmmtd/FMMTDCard.hh
index c3a7a8d1e..48371700d 100755
--- a/tts/fmmtd/include/tts/fmmtd/FMMTDCard.hh
+++ b/tts/fmmtd/include/tts/fmmtd/FMMTDCard.hh
@@ -47,16 +47,12 @@ namespace tts {
     ///
     /// 
     /// @param pcimode is true for PCI mode, false for LEMO mode
-    void togglePCIMode(bool pcimode)
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void togglePCIMode(bool pcimode);
 
     /// generate reset pulse
     ///
     /// only works in PCI mode
-    void generateResetPulse()
-      throw (HAL::HardwareAccessException,
-	     tts::exception::NoWriteLock);
+    void generateResetPulse();
 
     /// get a referene to the HAL PCIDevice
     HAL::PCIDevice& device() { return * ( _dev() ); };
diff --git a/tts/fmmtd/include/tts/fmmtd/version.h b/tts/fmmtd/include/tts/fmmtd/version.h
index 7257a3d98..14a8a300f 100755
--- a/tts/fmmtd/include/tts/fmmtd/version.h
+++ b/tts/fmmtd/include/tts/fmmtd/version.h
@@ -43,7 +43,7 @@ namespace ttsfmmtd
 	const std::string summary = "ttsfmmtd";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/fmmtd/src/common/FMMTDCard.cc b/tts/fmmtd/src/common/FMMTDCard.cc
index 13f9c3956..f33c3eb5d 100755
--- a/tts/fmmtd/src/common/FMMTDCard.cc
+++ b/tts/fmmtd/src/common/FMMTDCard.cc
@@ -21,9 +21,7 @@ tts::FMMTDCard::FMMTDCard( HAL::PCIDevice* device, ipcutils::SemaphoreArray& cra
 tts::FMMTDCard::~FMMTDCard() {
 };
 
-void tts::FMMTDCard::togglePCIMode(bool pcimode) 
-    throw (HAL::HardwareAccessException,
-	   tts::exception::NoWriteLock) {
+void tts::FMMTDCard::togglePCIMode(bool pcimode) {
 
   check_write_lock();
 
@@ -31,9 +29,7 @@ void tts::FMMTDCard::togglePCIMode(bool pcimode)
 }; 
 
 
-void tts::FMMTDCard::generateResetPulse()     
-  throw (HAL::HardwareAccessException,
-	 tts::exception::NoWriteLock) {
+void tts::FMMTDCard::generateResetPulse() {
 
   check_write_lock();
 
diff --git a/tts/fmmtd/src/common/version.cc b/tts/fmmtd/src/common/version.cc
index f0ddf83d6..40936d29d 100755
--- a/tts/fmmtd/src/common/version.cc
+++ b/tts/fmmtd/src/common/version.cc
@@ -24,7 +24,7 @@
 
 GETPACKAGEINFO(ttsfmmtd)
 
-void ttsfmmtd::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsfmmtd::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 	CHECKDEPENDENCY(xcept);  
diff --git a/tts/fmmtester/Makefile b/tts/fmmtester/Makefile
index df00695ec..a64b1f13f 100755
--- a/tts/fmmtester/Makefile
+++ b/tts/fmmtester/Makefile
@@ -32,8 +32,7 @@ Sources=\
 	FMMTesterHardcodedAddressTableReader.cc
 
 
-#allow user to override if needed
-ORACLE_HOME = /afs/cern.ch/project/oracle/linux/10103/
+#allow user to override if needed ORACLE_HOME = ../../extern/oracle/x86_64_centos7
 
 ifdef ORACLE_HOME
 ORACLE_INCLUDE_PREFIX=${ORACLE_HOME}/rdbms/demo/ ${ORACLE_HOME}/rdbms/public/
@@ -100,7 +99,7 @@ TestLibraries= \
 	toolbox asyncresolv uuid mimetic log4cplus numa \
 	xcept \
 	config \
-	ttsfmmdbi occi clntsh nnz12
+	ttsfmmdbi occi clntsh clntshcore ons nnz12
 
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/Makefile.rules
 include $(XDAQ_ROOT)/$(BUILD_SUPPORT)/mfRPM.rules
diff --git a/tts/fmmtester/include/tts/fmmtester/FMMTestCrate.hh b/tts/fmmtester/include/tts/fmmtester/FMMTestCrate.hh
index b309decda..a98140fe9 100755
--- a/tts/fmmtester/include/tts/fmmtester/FMMTestCrate.hh
+++ b/tts/fmmtester/include/tts/fmmtester/FMMTestCrate.hh
@@ -37,8 +37,7 @@ namespace tts {
     /// read the address table and determines the PCI-Devices 
     ///
     /// @param dummy: if true the dummy bus adapter will be used
-    FMMTestCrate(bool dummy=false)
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    FMMTestCrate(bool dummy=false);
 
     /// d-tor
     virtual ~FMMTestCrate();
@@ -53,8 +52,7 @@ namespace tts {
     ///
     /// FIXME: the id is not yet retrieved
     /// for the time being the FMM Testers are reetrieved by their PCI index
-    tts::FMMTesterCard& getFMMTester( uint32_t id )
-      throw (HAL::HardwareAccessException, xcept::Exception);
+    tts::FMMTesterCard& getFMMTester( uint32_t id );
 
   private:
     void cleanup();
diff --git a/tts/fmmtester/include/tts/fmmtester/FMMTesterCard.hh b/tts/fmmtester/include/tts/fmmtester/FMMTesterCard.hh
index 869319f1d..2fb7e6914 100755
--- a/tts/fmmtester/include/tts/fmmtester/FMMTesterCard.hh
+++ b/tts/fmmtester/include/tts/fmmtester/FMMTesterCard.hh
@@ -43,112 +43,85 @@ namespace tts {
     virtual ~FMMTesterCard();
 
     /// reset the test input fifo
-    void resetTFIFO()
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void resetTFIFO();
 
     /// reset the RAMS address generator 
-    void resetSimuRAMAddr()
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void resetSimuRAMAddr();
   
     /// Reset the FMMTester
-    void resetAll()
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void resetAll();
 
     /// Reset the FMMTester
-    void reset()
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void reset();
 
     /// toggle between TestReg and RAM mode
     ///
     /// @param rammode is true for RAM mode, false for Test Register mode.
     ///        toggling to RAM mode starts the sequence.
-    void toggleRAMMode(bool rammode)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void toggleRAMMode(bool rammode);
 
     /// are we in RAM mode?
     ///
     /// returns true for RAM mode, false for test register mode
-    bool isRAMMode()
-      throw (HAL::HardwareAccessException);
+    bool isRAMMode();
 
     /// set a test output
     ///
     /// @param ch is the channel number (0 to 19)
     /// @param state is the state to simulate
-    void setTestOutput(uint32_t channel, tts::TTSState const& state)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void setTestOutput(uint32_t channel, tts::TTSState const& state);
 
     /// set all test outputs 
     ///
     /// This function is used to set the test outputs in test register mode.
     ///
     /// @param states is the std::vector of 20 states to simulate
-    void setTestOutputs(std::vector<tts::TTSState> const& states)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void setTestOutputs(std::vector<tts::TTSState> const& states);
 
     /// read back the test outputs
     ///
     /// To be used in test register mode.
     ///
     /// @param states is the std::vector of 20 states. it is resized to a length of 20.
-    void readTestOutputs(std::vector<tts::TTSState> & states)
-      throw (HAL::HardwareAccessException);
+    void readTestOutputs(std::vector<tts::TTSState> & states);
 
     /// read the current test inputs
     ///
     /// To be used in test register mode.
     ///
     /// @param states is a std::vector into which the 4 test input staes will be read
-    void readTestInputs(std::vector<tts::TTSState> & states)
-      throw (HAL::HardwareAccessException);
+    void readTestInputs(std::vector<tts::TTSState> & states);
 
     /// write a test entry to the test RAMs
     ///
     /// @param addr is the address (0 to 2k) in units of 80-bit blocks
     /// @param states is the std::vector of states to simulate
-    void writeTestEntry(uint32_t addr, std::vector<tts::TTSState> const& states)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException,
-	     xcept::Exception);
+    void writeTestEntry(uint32_t addr, std::vector<tts::TTSState> const& states);
 
     /// read a test entry from the test RAMs
     ///
     /// @param addr is the address (0 to 2k) in units of 80-bit blocks
     /// @param states is the std::vector of states into which teh states are read
-    void readTestEntry(uint32_t addr, std::vector<tts::TTSState> & states)
-      throw (HAL::HardwareAccessException,
-	     xcept::Exception);
+    void readTestEntry(uint32_t addr, std::vector<tts::TTSState> & states);
 
     /// read from the test input FIFOs
     ///
     /// returns true if there was enything to read, false if not
     ///
     /// @param states is a std::vector into which the 4 test input staes will be read
-    bool readTestInputFIFOs(std::vector<tts::TTSState>& states)
-      throw (HAL::HardwareAccessException);
+    bool readTestInputFIFOs(std::vector<tts::TTSState>& states);
 
     /// set the number of sequences to generate
     ///
     /// @param num_seq is the number of sequences (0 to 127) or -1 for an
     ///        indefinite number of sequences.
-    void setNumberOfSequences(int num_seq)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException,
-	     xcept::Exception);
+    void setNumberOfSequences(int num_seq);
   
     /// read back the number of sequences to generate
     ///
     /// returns the number of sequences (0 to 127) or -1 for an
     /// indefinite number of sequences.
-    int readNumberOfSequences()
-      throw (HAL::HardwareAccessException);
+    int readNumberOfSequences();
   
     /// select the sequence clock
     ///
@@ -188,16 +161,12 @@ namespace tts {
     ///       29=  0.037  Hz,
     ///       30=  0.019  Hz,
     ///       31=  0.009  Hz, (100 sec period)
-    void selectSequenceClock(uint32_t clk_sel)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException,
-	     xcept::Exception);
+    void selectSequenceClock(uint32_t clk_sel);
   
     /// read back the sequence clock selection
     ///
     /// return value is the clock selection as in selectSequenceClock().
-    uint32_t readSequenceClockSelection()
-      throw (HAL::HardwareAccessException);
+    uint32_t readSequenceClockSelection();
 
   
     /// set the delay for the input FIFO
@@ -206,51 +175,38 @@ namespace tts {
     ///
     /// A value of 12 works fine with FMMTester firmware 051031_00 and FMM Firmware 051010_00
     /// using short (50 cm) cables between Tester and FMM.
-    void setInputFIFODelay(uint32_t delay)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException,
-	     xcept::Exception);
+    void setInputFIFODelay(uint32_t delay);
 
     /// read back the delay for the input FIFO
     ///
     /// returns the delay in 40 MHz cycles (0..15) 
-    uint32_t readInputFIFODelay()
-      throw (HAL::HardwareAccessException);  
+    uint32_t readInputFIFODelay();  
 
     /// start the sequence
-    void startSequence()
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void startSequence();
 
     /// is a sequence in progress ?
-    bool sequenceRunning()
-      throw (HAL::HardwareAccessException);
+    bool sequenceRunning();
 
     /// stop the sequence
     ///
     /// used to stop a sequence before it ended or to stop and indefinite seqeunce.
-    void stopSequence()
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void stopSequence();
 
     /// read ID of the FMMTester board
-    uint32_t readID()
-      throw (HAL::HardwareAccessException);
+    uint32_t readID();
 
     /// read the Revision of the FMM Tester Firmware (XILINX)
     ///
     /// The std::string contains 9 characters in the format "YYMMDD_RR",
     /// where YY is the year since 2000, MM, the month (1-12), DD the day (1-31) and RR the revision in this day (00-99)
-    std::string readFirmwareRev()
-      throw (HAL::HardwareAccessException);
+    std::string readFirmwareRev();
 
     /// set front panel LEDs
     ///
     /// @param led_setting[3:0] contains 1 bit each for the front panel LEDs 4 to 1 
     ///
-    void setLEDs(uint32_t led_setting)
-      throw (tts::exception::NoWriteLock,
-	     HAL::HardwareAccessException);
+    void setLEDs(uint32_t led_setting);
 
     enum { RAMSsize = 0x400 }; // in units of 80-bit (16byte) blocks (1k)
   private: 
diff --git a/tts/fmmtester/include/tts/fmmtester/version.h b/tts/fmmtester/include/tts/fmmtester/version.h
index 033d4d99b..1449e2be0 100755
--- a/tts/fmmtester/include/tts/fmmtester/version.h
+++ b/tts/fmmtester/include/tts/fmmtester/version.h
@@ -43,7 +43,7 @@ namespace ttsfmmtester
 	const std::string summary = "ttsfmmtester";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/fmmtester/src/common/FMMTestCrate.cc b/tts/fmmtester/src/common/FMMTestCrate.cc
index 610171068..27561a8d8 100755
--- a/tts/fmmtester/src/common/FMMTestCrate.cc
+++ b/tts/fmmtester/src/common/FMMTestCrate.cc
@@ -21,8 +21,7 @@
 // think about recabling scenarios, or card exchange
 
 
-tts::FMMTestCrate::FMMTestCrate(bool dummy) 
-  throw (HAL::HardwareAccessException, xcept::Exception)
+tts::FMMTestCrate::FMMTestCrate(bool dummy)
   : tts::FMMCrate(dummy), _fmm_tester_addresstable(0) {
 
   //
@@ -77,8 +76,7 @@ void tts::FMMTestCrate::cleanup() {
 
 
 
-tts::FMMTesterCard& tts::FMMTestCrate::getFMMTester( uint32_t id ) 
-  throw (HAL::HardwareAccessException, xcept::Exception) {
+tts::FMMTesterCard& tts::FMMTestCrate::getFMMTester( uint32_t id ) {
 
   if (_theFMMTesters.count(id) == 0)
     XCEPT_RAISE(xcept::Exception, "FMMTestCrate::getFMMTester: FMMTester with requested ID is not present.");
diff --git a/tts/fmmtester/src/common/FMMTesterCard.cc b/tts/fmmtester/src/common/FMMTesterCard.cc
index 758619cc6..66c6af309 100755
--- a/tts/fmmtester/src/common/FMMTesterCard.cc
+++ b/tts/fmmtester/src/common/FMMTesterCard.cc
@@ -30,9 +30,7 @@ tts::FMMTesterCard::~FMMTesterCard() {
 };
 
 
-void tts::FMMTesterCard::resetTFIFO() 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::resetTFIFO() {
   
   check_write_lock();
 
@@ -41,9 +39,7 @@ void tts::FMMTesterCard::resetTFIFO()
 }
 
 
-void tts::FMMTesterCard::resetSimuRAMAddr() 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::resetSimuRAMAddr() {
 
   check_write_lock();
 
@@ -51,9 +47,7 @@ void tts::FMMTesterCard::resetSimuRAMAddr()
   _dev()->write("reset_ram_add_gen",0x0); 
 };
   
-void tts::FMMTesterCard::resetAll() 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::resetAll() {
 
   check_write_lock();
 
@@ -61,24 +55,19 @@ void tts::FMMTesterCard::resetAll()
   resetSimuRAMAddr();
 };
 
-void tts::FMMTesterCard::reset() 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::reset() {
 
   resetAll();
 };
 
-void tts::FMMTesterCard::toggleRAMMode(bool rammode) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::toggleRAMMode(bool rammode) {
 
   check_write_lock();
 
   _dev()->write("stimuli_select", rammode?0x1:0x0);
 }; 
 
-bool tts::FMMTesterCard::isRAMMode() 
-  throw  (HAL::HardwareAccessException) {
+bool tts::FMMTesterCard::isRAMMode() {
 
   uint32_t rammode;
   _dev()->read("stimuli_select", &rammode);
@@ -86,9 +75,7 @@ bool tts::FMMTesterCard::isRAMMode()
   return (rammode & 0x1) == 0x1;
 }
 
-void tts::FMMTesterCard::setTestOutput(uint32_t channel, tts::TTSState const& state) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::setTestOutput(uint32_t channel, tts::TTSState const& state) {
 
   check_write_lock();
 
@@ -121,9 +108,7 @@ void tts::FMMTesterCard::setTestOutput(uint32_t channel, tts::TTSState const& st
 
 };
 
-void tts::FMMTesterCard::setTestOutputs(std::vector<tts::TTSState> const& states) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::setTestOutputs(std::vector<tts::TTSState> const& states) {
 
   check_write_lock();
 
@@ -149,8 +134,7 @@ void tts::FMMTesterCard::setTestOutputs(std::vector<tts::TTSState> const& states
 };
 
 
-void tts::FMMTesterCard::readTestOutputs(std::vector<tts::TTSState> & states) 
-  throw  (HAL::HardwareAccessException) {
+void tts::FMMTesterCard::readTestOutputs(std::vector<tts::TTSState> & states) {
 
   states.resize(20, tts::TTSState::READY);
 
@@ -177,8 +161,7 @@ void tts::FMMTesterCard::readTestOutputs(std::vector<tts::TTSState> & states)
 }
 
 
-void tts::FMMTesterCard::readTestInputs(std::vector<tts::TTSState>& states) 
-  throw  (HAL::HardwareAccessException) {
+void tts::FMMTesterCard::readTestInputs(std::vector<tts::TTSState>& states) {
 
   states.resize(4, tts::TTSState::READY);
   
@@ -188,10 +171,7 @@ void tts::FMMTesterCard::readTestInputs(std::vector<tts::TTSState>& states)
   decodeTestInputs(fmm_all, states);  
 };
 
-void tts::FMMTesterCard::writeTestEntry(uint32_t addr, std::vector<tts::TTSState> const& states) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException,
-	 xcept::Exception) {
+void tts::FMMTesterCard::writeTestEntry(uint32_t addr, std::vector<tts::TTSState> const& states) {
 
   if (addr >= RAMSsize) 
     XCEPT_RAISE( xcept::Exception, "FMMTesterCard::writeTestEntry():: addr out of range");
@@ -222,9 +202,7 @@ void tts::FMMTesterCard::writeTestEntry(uint32_t addr, std::vector<tts::TTSState
 
 
 
-void tts::FMMTesterCard::readTestEntry(uint32_t addr, std::vector<tts::TTSState> & states) 
-  throw (HAL::HardwareAccessException,
-	 xcept::Exception) {
+void tts::FMMTesterCard::readTestEntry(uint32_t addr, std::vector<tts::TTSState> & states) {
 
   if (addr >= RAMSsize) 
     XCEPT_RAISE( xcept::Exception, "FMMTesterCard::readTestEntry():: addr out of range");
@@ -255,8 +233,7 @@ void tts::FMMTesterCard::readTestEntry(uint32_t addr, std::vector<tts::TTSState>
 
 
 
-bool tts::FMMTesterCard::readTestInputFIFOs(std::vector<tts::TTSState>& states) 
-  throw  (HAL::HardwareAccessException) {
+bool tts::FMMTesterCard::readTestInputFIFOs(std::vector<tts::TTSState>& states) {
   
   uint32_t tfifo_empty;
   _dev()->read("TFIFO_empty", &tfifo_empty);
@@ -272,10 +249,7 @@ bool tts::FMMTesterCard::readTestInputFIFOs(std::vector<tts::TTSState>& states)
   return has_data;
 };
 
-void tts::FMMTesterCard::setNumberOfSequences(int num_seq) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException,
-	 xcept::Exception) {
+void tts::FMMTesterCard::setNumberOfSequences(int num_seq) {
 
   if (num_seq < -1 || num_seq > 127) 
     XCEPT_RAISE( xcept::Exception, "FMMTesterCard::setNumberOfSequences(): error: number of seqeunces out of range");
@@ -290,8 +264,7 @@ void tts::FMMTesterCard::setNumberOfSequences(int num_seq)
   }
 }
   
-int tts::FMMTesterCard::readNumberOfSequences() 
-  throw  (HAL::HardwareAccessException) {
+int tts::FMMTesterCard::readNumberOfSequences() {
 
   uint32_t data;
   
@@ -304,10 +277,7 @@ int tts::FMMTesterCard::readNumberOfSequences()
   }
 };
   
-void tts::FMMTesterCard::selectSequenceClock(uint32_t clk_sel) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException,
-	 xcept::Exception) {
+void tts::FMMTesterCard::selectSequenceClock(uint32_t clk_sel) {
 
   if (clk_sel > 31)
     XCEPT_RAISE( xcept::Exception, "FMMTesterCard::setSequenceFrequency(): error: frequ_selection out of range");
@@ -317,8 +287,7 @@ void tts::FMMTesterCard::selectSequenceClock(uint32_t clk_sel)
   _dev()->write("sequence_clk_sel", clk_sel);
 }
   
-uint32_t tts::FMMTesterCard::readSequenceClockSelection() 
-  throw  (HAL::HardwareAccessException) {
+uint32_t tts::FMMTesterCard::readSequenceClockSelection() {
 
   uint32_t clk_sel;
   _dev()->read("sequence_clk_sel", &clk_sel);
@@ -326,10 +295,7 @@ uint32_t tts::FMMTesterCard::readSequenceClockSelection()
   return (uint32_t) clk_sel;
 };
 
-void tts::FMMTesterCard::setInputFIFODelay(uint32_t delay) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException,
-	 xcept::Exception) {
+void tts::FMMTesterCard::setInputFIFODelay(uint32_t delay) {
   
   if (delay > 15)
     XCEPT_RAISE( xcept::Exception, "FMMTesterCard::setInputFIFODelay(): error: delay out of range.");
@@ -339,8 +305,7 @@ void tts::FMMTesterCard::setInputFIFODelay(uint32_t delay)
   _dev()->write("fifo_delay", delay);
 };
 
-uint32_t tts::FMMTesterCard::readInputFIFODelay() 
-  throw  (HAL::HardwareAccessException) {
+uint32_t tts::FMMTesterCard::readInputFIFODelay() {
 
   uint32_t delay;
   _dev()->read("fifo_delay", &delay);
@@ -349,9 +314,7 @@ uint32_t tts::FMMTesterCard::readInputFIFODelay()
 }
 
 
-void tts::FMMTesterCard::startSequence() 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::startSequence() {
 
   check_write_lock();
 
@@ -365,17 +328,14 @@ void tts::FMMTesterCard::startSequence()
 
 };
 
-bool tts::FMMTesterCard::sequenceRunning() 
-  throw  (HAL::HardwareAccessException) {
+bool tts::FMMTesterCard::sequenceRunning() {
 
   uint32_t data;
   _dev()->read("sequence_running", &data);
   return data == 0x1;
 }
 
-void tts::FMMTesterCard::stopSequence() 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::stopSequence() {
 
   check_write_lock();
 
@@ -383,16 +343,14 @@ void tts::FMMTesterCard::stopSequence()
 }
 
 
-uint32_t tts::FMMTesterCard::readID() 
-  throw  (HAL::HardwareAccessException) {
+uint32_t tts::FMMTesterCard::readID() {
 
   uint32_t id;
   _dev()->read("ID", &id);
   return id;
 };
 
-std::string tts::FMMTesterCard::readFirmwareRev() 
-  throw  (HAL::HardwareAccessException) {
+std::string tts::FMMTesterCard::readFirmwareRev() {
 
   uint32_t year;
   uint32_t month;
@@ -423,9 +381,7 @@ std::string tts::FMMTesterCard::BCDtoString(uint32_t num, uint32_t ndigit) {
   return txt.str();
 }
 
-void tts::FMMTesterCard::setLEDs(uint32_t led_setting) 
-  throw (tts::exception::NoWriteLock,
-	 HAL::HardwareAccessException) {
+void tts::FMMTesterCard::setLEDs(uint32_t led_setting) {
 
   check_write_lock();
 
diff --git a/tts/fmmtester/src/common/version.cc b/tts/fmmtester/src/common/version.cc
index 71fcea31b..11833110d 100755
--- a/tts/fmmtester/src/common/version.cc
+++ b/tts/fmmtester/src/common/version.cc
@@ -24,7 +24,7 @@
 
 GETPACKAGEINFO(ttsfmmtester)
 
-void ttsfmmtester::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsfmmtester::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(ttsfmm);  
 	CHECKDEPENDENCY(ttsfmmdbi);  
diff --git a/tts/ipcutils/include/tts/ipcutils/version.h b/tts/ipcutils/include/tts/ipcutils/version.h
index 75aeacd9f..c681d49b6 100755
--- a/tts/ipcutils/include/tts/ipcutils/version.h
+++ b/tts/ipcutils/include/tts/ipcutils/version.h
@@ -43,7 +43,7 @@ namespace ttsipcutils
 	const std::string summary = "ttsipcutils";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/ipcutils/src/common/version.cc b/tts/ipcutils/src/common/version.cc
index 4ad443f15..c6d18ac95 100755
--- a/tts/ipcutils/src/common/version.cc
+++ b/tts/ipcutils/src/common/version.cc
@@ -16,7 +16,7 @@
 
 GETPACKAGEINFO(ttsipcutils)
 
-void ttsipcutils::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsipcutils::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 	CHECKDEPENDENCY(xcept);  
diff --git a/tts/ipcutils/test/common/cpci_lock_util.cc b/tts/ipcutils/test/common/cpci_lock_util.cc
index fa5a2460d..05e9dd88d 100755
--- a/tts/ipcutils/test/common/cpci_lock_util.cc
+++ b/tts/ipcutils/test/common/cpci_lock_util.cc
@@ -56,7 +56,7 @@ int main (int argc, char* argv[]) {
       std::cout << "unknown command" << std::endl;
       break;
     }
-  } catch (xcept::Exception e) {
+  } catch (xcept::Exception &e) {
     std::cout << "Exception caught " <<
       xcept::stdformat_exception_history(e) << std::endl;
   }
diff --git a/tts/ttsbase/include/tts/ttsbase/version.h b/tts/ttsbase/include/tts/ttsbase/version.h
index 19d8f72c9..7c622f4f1 100755
--- a/tts/ttsbase/include/tts/ttsbase/version.h
+++ b/tts/ttsbase/include/tts/ttsbase/version.h
@@ -43,7 +43,7 @@ namespace ttsttsbase
 	const std::string summary = "ttsttsbase";
 	const std::string link = "http://xdaqwiki.cern.ch/index.php";
 	config::PackageInfo getPackageInfo();
-	void checkPackageDependencies() throw (config::PackageInfo::VersionException);
+	void checkPackageDependencies();
 	std::set<std::string, std::less<std::string> > getPackageDependencies();
 }
 
diff --git a/tts/ttsbase/src/common/version.cc b/tts/ttsbase/src/common/version.cc
index da309fd60..34f339fc8 100755
--- a/tts/ttsbase/src/common/version.cc
+++ b/tts/ttsbase/src/common/version.cc
@@ -15,7 +15,7 @@
 
 GETPACKAGEINFO(ttsttsbase)
 
-void ttsttsbase::checkPackageDependencies() throw (config::PackageInfo::VersionException)
+void ttsttsbase::checkPackageDependencies()
 {
 	CHECKDEPENDENCY(config);  
 }
diff --git a/xmas/store2g/src/common/Stager.cc b/xmas/store2g/src/common/Stager.cc
index 95a8f479a..d2abd06db 100755
--- a/xmas/store2g/src/common/Stager.cc
+++ b/xmas/store2g/src/common/Stager.cc
@@ -142,23 +142,24 @@ void xmas::store2g::Stager::timeExpired(toolbox::task::TimerEvent& e)
 			properties.lastInsert = e.getTimerTask()->lastExecutionTime;
 			repository_->clear ( *i );
 		}
-		catch (xmas::store2g::exception::Exception& e)
+		catch (const xmas::store2g::exception::Exception& ce)
 		{
-			std::vector<xcept::ExceptionInformation> & history = e.getHistory();
-        		std::vector<xcept::ExceptionInformation>::iterator j = history.begin();
+			xmas::store2g::exception::Exception e = ce;
+			xcept::Exception::const_iterator j = e.begin();
 			std::string identifier = (*j).getProperty("identifier");
 			std::string message = (*j).getProperty("message");
                 	if ((identifier ==  "tstore::exception::Exception" ) && ( message.find("ORA-00001") != std::string::npos ))
 			{
 				// unique constraint violated therefore clear current data and let the system go
-				LOG4CPLUS_DEBUG( this->getOwnerApplication()->getApplicationLogger(),xcept::stdformat_exception_history(e));
+				LOG4CPLUS_DEBUG( this->getOwnerApplication()->getApplicationLogger(),e);
+			
 				this->getOwnerApplication()->notifyQualified("fatal",e);
 				repository_->clear ( *i );
 
 			}
 			else
 			{
-				LOG4CPLUS_DEBUG( this->getOwnerApplication()->getApplicationLogger(),xcept::stdformat_exception_history(e));
+				LOG4CPLUS_DEBUG( this->getOwnerApplication()->getApplicationLogger(),e);
 				this->getOwnerApplication()->notifyQualified("fatal",e);
 				properties.failed = true; // disable so that stager will ignore this flaslist
 				// no way to continue after this, whatever the problem connection is closed and let the xmas store attempt to re-connect at renew time
@@ -168,7 +169,7 @@ void xmas::store2g::Stager::timeExpired(toolbox::task::TimerEvent& e)
 				}
 				catch (xmas::store2g::exception::Exception& e)
                 		{
-					LOG4CPLUS_DEBUG( this->getOwnerApplication()->getApplicationLogger(),xcept::stdformat_exception_history(e));
+					LOG4CPLUS_DEBUG( this->getOwnerApplication()->getApplicationLogger(),e);
 					this->getOwnerApplication()->notifyQualified("error",e);
 				}
 			}
diff --git a/yumgroups.xml b/yumgroups.xml
index da9629946..0dbf3c736 100644
--- a/yumgroups.xml
+++ b/yumgroups.xml
@@ -125,12 +125,6 @@
 			<packagereq type="mandatory">cmsos-worksuite-ferol-devel</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ferol40</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ferol40-devel</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcutils</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcutils-devel</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcmonitoring</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcmonitoring-devel</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcttcci</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcttcci-devel</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttsatts</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttsatts-devel</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttscpcibase</packagereq>
@@ -151,10 +145,12 @@
 			<packagereq type="mandatory">cmsos-worksuite-ttsttsbase-devel</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttcttcci</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttcttcci-devel</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcutils</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcutils-devel</packagereq>
+			<packagereq type="mandatory">cmsos-worksuite-ttcltc</packagereq>
+			<packagereq type="mandatory">cmsos-worksuite-ttcltc-devel</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttcmonitoring</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttcmonitoring-devel</packagereq>
+			<packagereq type="mandatory">cmsos-worksuite-ttcutils</packagereq>
+			<packagereq type="mandatory">cmsos-worksuite-ttcutils-devel</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-jaljtagChain</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-jaljtagController</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-jaljtagSVFSequencer</packagereq>
@@ -282,9 +278,6 @@
 			<packagereq type="mandatory">cmsos-worksuite-pcilinuxbusadapter-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ferol-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ferol40-debuginfo</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcutils-debuginfo</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcmonitoring-debuginfo</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcttcci-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttsatts-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttscpcibase-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttsfmm-debuginfo</packagereq>
@@ -295,8 +288,9 @@
 			<packagereq type="mandatory">cmsos-worksuite-ttsipcutils-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttsttsbase-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttcttcci-debuginfo</packagereq>
-			<packagereq type="mandatory">cmsos-worksuite-ttcutils-debuginfo</packagereq>
+			<packagereq type="mandatory">cmsos-worksuite-ttcltc-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-ttcmonitoring-debuginfo</packagereq>
+			<packagereq type="mandatory">cmsos-worksuite-ttcutils-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-jaljtagChain-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-jaljtagController-debuginfo</packagereq>
 			<packagereq type="mandatory">cmsos-worksuite-jaljtagSVFSequencer-debuginfo</packagereq>
